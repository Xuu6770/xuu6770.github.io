<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Arc 浏览器使用感受</title>
    <link href="/post/Review-Arc-Browser/"/>
    <url>/post/Review-Arc-Browser/</url>
    
    <content type="html"><![CDATA[<p>好像确实也没大家说得那么好用，至少我个人用下来觉得一般。</p><span id="more"></span><h2 id="本身就一堆小问题"><a href="#本身就一堆小问题" class="headerlink" title="本身就一堆小问题"></a>本身就一堆小问题</h2><p>这是我上手这个浏览器仅仅一天就发现的问题，排名不分先后。</p><h3 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h3><ol><li>界面无中文，桌面端没有，移动端也没有，简体中文没有，繁体中文也没有。很难想象这是一个从 2022 年 4 月 19 日发布至今的产品。硬要说一点也没有那倒也不是，网页右键菜单是中文，<code>arc://settings/</code>页面有中文，但是又没翻译全，仍然有部分英文。</li><li>同步数据需要科学上网，这点很麻烦。你可能会说：“那 Chrome 也需要啊”，你说的对，而且不止 Chrome ，Vivaldi 现在也需要……但是它们与 Arc 不同的地方在于，当它们使用扩展程序来接管浏览器的代理时，它们就可以通过扩展程序代理的网络来进行数据同步，但是 Arc 就不行，它一定要是 TUN 模式这种接管系统流量的方案才能进行同步。顺带一提，Chrome 和 Vivaldi 就是因为有需要科学上网才能同步账号数据的限制从而降低了我的使用欲望，于是我现在才开始到处找 macOS 上 Safari 的代替品。</li></ol><h3 id="体验感撕裂"><a href="#体验感撕裂" class="headerlink" title="体验感撕裂"></a>体验感撕裂</h3><p>当你打开浏览器的「偏好设置」（也就是 Preferences ）时，Arc 会弹出一个窗口，你可以在其中进行部分主要设定，但是当你点击「Advanced」标签，然后点击「More Settings…」按钮时，Arc 就会打开 Chromium 原生的设置页面，这种体验上的割裂感让我十分不适。我觉得你要么就直接把所有设置项都放到你自己创建的窗口里，不然你就直接把 Chromium 原生的设置界面搬过来用也不会有人说什么，做了一半剩一半你不如不做呢？</p><h3 id="喜欢吗？喜欢就砍了！"><a href="#喜欢吗？喜欢就砍了！" class="headerlink" title="喜欢吗？喜欢就砍了！"></a>喜欢吗？喜欢就砍了！</h3><p>Note 功能到哪去了？从这支影片 <a href="https://www.youtube.com/watch?v=nlNsCB4SbVc">Arc 真香！腦洞大開的功能讓超多 Chrome 死忠粉決定把 Arc 當作預設瀏覽器了！</a> 的 9:57 处可以看到，当你点击侧边栏下方的 + 号时可以在弹出的菜单中看到「New Note」这个选项，通过点击它你可以创建一个笔记。但是我现在在使用时却没有这个选项了，我估计它应该是和 Easel 整合起来了。可是为什么要这么做呢？在 Easel 上你可以在页面的任何位置创建文字，这在联想或者记录灵感时十分有用，但是当我只想一行一行有序地记录文字时（就像使用 Word 那样），Easel 明显就不行了。</p><h3 id="强制垂直标签页"><a href="#强制垂直标签页" class="headerlink" title="强制垂直标签页"></a>强制垂直标签页</h3><p>在 Microsoft Edge 、Vivaldi 等浏览器中，你可以选择标签页的位置，或位于顶部，或位于左&#x2F;右。但是在 Arc 中，你只有一个选择，那就是放在左边。无论这是否挤占了网页的显示空间，无论这是否能提升你的效率，你都只能放在左边。当然，你可以选择将侧边栏隐藏，在这种情况下，当浏览器上没有活动标签时，侧边栏会自动出现，有标签时，侧边栏会隐藏，当你把鼠标移动到屏幕左侧时，侧边栏也会弹出——就看你能不能习惯和接受了。</p><h3 id="性能错觉"><a href="#性能错觉" class="headerlink" title="性能错觉"></a>性能错觉</h3><p>我刚开始打开 Arc 浏览网页，感觉它的反应真快！难道它确实是优化做得非常到位，代码写得非常好？直到我打开了设置，发现它的「预加载网页」默认是打开的，但是在别的浏览器中，这个功能我是默认关闭的。</p><p>其次在「预加载网页」的上面有一个「省内存模式」，这个它反而默认是关闭的……诶我就纳闷儿了，你这么爱把标签页 pin 住，但是对于那些 pin 在那里但是暂时用不着的标签页你为什么不把它们的资源释放出来呢？</p><h2 id="「无书签」并不适合所有人"><a href="#「无书签」并不适合所有人" class="headerlink" title="「无书签」并不适合所有人"></a>「无书签」并不适合所有人</h2><p>「无书签」的设定可以说是 Arc 浏览器的一个特点，它把书签所承载的功能移交到 tab 、space 等概念上了，再结合 pin 这个动作，试图取代书签。事实上，书签功能在 Arc 中并没有被完全移除，只是被藏起来了。我们仍然在地址栏手动输入<code>arc://bookmarks/</code>来跳转到书签页面，在这里我们依然可以编辑书签、导入和导出。但是问题在于，这个功能现在和浏览器已经是一点都不相干了，就算你导入了书签，你也无法在地址栏中通过输入已有书签的部分地址，然后让浏览器进行地址补全，因为浏览器根本就不补，它根本就不管你有没有导入书签，它同步数据的时候也不会去同步书签，并且 Arc 浏览器也没有「添加当前网址到书签」的功能。</p><p>但我感觉用户的使用习惯并不是能那么轻易改变的，至少我个人还是很依赖书签，经过这么多年的使用和维护，我现在依然存有上百个书签。确实，每个人每天要打开的网站可能也就那么几个，但是这不代表剩下那上百个书签对我来说毫无意义。既然你要“去书签化”，那你就把相关的功能给删干净了吧，删又不删干净，搞得我用也不是不用也不是。</p><h2 id="Max-里的功能简直可有可无"><a href="#Max-里的功能简直可有可无" class="headerlink" title="Max 里的功能简直可有可无"></a>Max 里的功能简直可有可无</h2><p>Max 是 Arc 提供的一些由 AI 驱动的功能，这些功能的动作基本上都是整理、重命名、快速预览、快速提问。这些功能共有 7 个，其中有 6 个我平时基本都用不上，有一个叫「Ask on Page」，我输入了问题，Arc 加载了半天没响应。我以为是网络问题，我就开启 Clash 的系统代理——没响应，我开启 TUN 模式——还是没响应，那我还用个屁？后来我看了介绍 Max 的视频，发现这个「Ask on Page」的功能应该是结合网页来回答你的问题，也就是你问的问题要和网页内容有关……无论怎样我反正用不了。</p><p>如果你想不受限制地发问，你可以使用 Max 中内置的 ChatGPT 快速提问功能，但是这个功能也只是提供一个输入框给你输入问题，然后它就会跳转到 ChatGPT 的网页版，也就是说，当你输入完问题按下搜索以后，就没 Arc 什么事了……我也是挺无语的，而且通过这个搜索框创建的对话，ChatGPT 那边似乎使用的还是 3.5 版本的模型，这……</p><h2 id="也不能光骂不夸"><a href="#也不能光骂不夸" class="headerlink" title="也不能光骂不夸"></a>也不能光骂不夸</h2><p>浏览器本身也并非毫无亮点，且听我慢慢道来。</p><h3 id="界面设计优雅清爽"><a href="#界面设计优雅清爽" class="headerlink" title="界面设计优雅清爽"></a>界面设计优雅清爽</h3><p>Arc 浏览器的各种窗口效果、动画都做得很好，或者说都做得和 macOS 很搭，都有一种很优雅的感觉。你说颜值重要吗，它固然不是一个工具的核心，但「美」是人无法拒绝的。尽管这个浏览器用起来可能不是很顺手，让用户想立刻卸载了它，但是超高的颜值却又让用户在按下卸载按钮前多了几分犹豫。只是在新鲜感过后，Arc 要靠什么来留住用户，那就不得而知了。</p><p>好看又好用那就是宝藏，就是杀手级 app ；好看不中用，那就是花里胡哨，就是花瓶。</p><h3 id="还有吗？"><a href="#还有吗？" class="headerlink" title="还有吗？"></a>还有吗？</h3><p>还有……还有……呃……，哦对了，还有浏览器内置的截图功能，这应该是我用过的最好用的内置截图工具，截图时可以选择元素进行截图（跟 Firefox 一样），截图完成后可以进行标注……呃不过这个功能对于国人来说可能也没什么用，因为大家都喜欢用微信和 QQ 的截图。</p><p>还有吗？</p><p>还真没了，整体下来，Arc 浏览器能让我发现的优点也就只有「好看」这一个了。我是真没想到，也是真的无语。只能说独特的设计理念让它注定无法成为大众产品。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我 V 你 50 ，召唤仪式让我来做！</title>
    <link href="/post/Review-My-Undead-Yokai-Girlfriend/"/>
    <url>/post/Review-My-Undead-Yokai-Girlfriend/</url>
    
    <content type="html"><![CDATA[<p>今天看完了一个亚马逊的剧——《我的女友是妖怪》，我的评价是：好看，爱看，速速出下一季！</p><p><img src="/../../images/ACGN/My.Undead.Yokai.Girlfriend.S01E08.If.You.Love.Someone.1080p.AMZN.WEB-DL.DDP5.1.H.264-ZeroTV-0001.jpg" alt="OP 画面"></p><span id="more"></span><p>首先这部剧的受众群体是哪些人呢？虽然我不愿意承认，但是这种带有恋爱元素的喜剧片，同时女方又是强势的一方的片子，多半是给那些生活不顺的单身死肥宅男看的吧……我说的是我自己，如有冒犯还请原谅。像这种「女方强势」的类型的片子有很多，什么「我的老婆是赌圣」啊，什么怎么怎么的突然就被富婆爱上了这些，不过像这些在我看来都太 low 了，根本没兴趣去看，更别说看完了还在这里敲键盘。</p><p>那么本剧的亮点有哪些呢？从最表面上来看就是选角，选择 吉川爱 来饰演女主几乎是完美的，超高的颜值以及她在剧中的表演，会让你觉得她就是公主本人，这种契合程度就像：</p><ul><li>六小龄童 饰演 孙悟空</li><li>亨利·卡维尔 饰演 利维亚的杰洛特</li><li>安德鲁·加菲尔德 饰演 蜘蛛侠</li><li>小罗伯特·唐尼 饰演 钢铁侠</li><li>……</li></ul><p>除了女主，男主的父亲的选角也很不错，作为一位老父亲同时又是一位警署的队长，那种成熟沉稳的姿态、认真对待工作的态度、忽视了与儿子的相处与沟通等等一系列出演都十分到位。</p><p>男主呢？男主的设定就很奇怪了，因为我前面说过这种「女方强势」的类型的片子多半是瞄准那些生活不顺的单身死肥宅男去的，但是男主的各方面条件都不算差，要基友有基友，要社交有社交，家境也不差，老爸当警察队长，老妈每天早上起来做丰盛的早餐给大家吃，自己还是个大学生……你这样子让我怎么代入呢？我除了在「没有女朋友」这一点上和你一样，我其它地方怎么比得过你？反观男主自己，在有了这些条件的加持下，每天还是表现得那么唯唯诺诺……给我的感觉就像是剧情需要。</p><p>总之值得一提的也就这三个角色了，至于反派，也就那样，设定一般，出演得也一般。</p><p>等等，我为什么要说「反派」？这是个很有意思的问题，成年人的世界中不存在好人与坏人，只是大家的立场不一样罢了。这部剧中的“反派”的行动目的从表面上来看只是为了消灭女主，因为女主是妖怪，“反派”们是古代镇妖的「守护者」（在剧中被称为「五矛」），他们认为人类和妖怪是无法共存的，故而为了世界和平而消灭妖怪。而女主才更像是“坏人”，因为她为了解放她被封印的家人们，她自己一被召唤出来就杀了一个「五矛」的后代……所以到底是孰对孰错呢？</p><p>这里就不深入讨论了，只是想到了这个话题就随手写下来而已，我只是想说其他的角色，包括主角团的其他人和所谓的“反派”，大家的演出不能说很好，只能说是不算差。</p><hr><p>说完了角色，再来看看剧情。最近在刷抖音的时候经常看到一些影视剪辑下面跟着一个标签：「因为一个片段看了一部剧」……我看这部剧的契机也是因为我看了别人在 QQ 群里发的截图，截图的内容应该是第一集女主和男主签订契约的部分。你猜他们是怎么签订契约的？那当然不可能是白纸黑字，而是通过发生关系……虽然在剧中大家都把这段关系视为一种诅咒，不过这都不重要了。妈的能通过和美少女做爱然后让她和自己绑定在一起，然后她还是个什么公主，然后还是个狐妖，然后还法力高强，这种事情想想都让人流口水啦！</p><p><img src="/../../images/ACGN/My.Undead.Yokai.Girlfriend.S01E08.If.You.Love.Someone.1080p.AMZN.WEB-DL.DDP5.1.H.264-ZeroTV-0002.jpg" alt="让我来！"></p><p>咳咳，事实上，我想说的是，编剧在这方面确实是懂的，他懂得怎么在第一集就快速抓住人的眼球，因为他知道作品本身已经没有什么非常新的东西了，只能靠擦边球来留住观众，到了后面再慢慢通过矛盾和感情戏来加深观众与剧中角色的连结。整部剧只有 8 集，只有第一第二集有这种擦边球，到了后面也是只字不提了。</p><p>结局方面也是给到了我一点意外，前面提到女主为了解放她被封印的家人们而杀了一个「五矛」的后代，事实上，她需要杀掉总计 5 个「五矛」的后代并把他们的头颅放在法阵上才能解开封印。前面四个头颅都拿得挺顺利的，直到最后一集女主才发现，最后一个她需要杀的人——竟然是男主……你看看，所以我说编剧是懂搞矛盾的，这下是杀还是不杀呢？那当然是下不去手了对吧，先别提男女主的感情如何，从设定上来说，契约的任意一方死去，另一方也会随着死去，这下你是想杀也杀不了了23333。</p><p>这里还需要补充一点是我为什么说结局给到了我一点意外，因为一开始剧情中表明女主要杀的最后一个人其实是另一个角色，直到最后女主要下杀手的时候才发生了反转。那女主是如何定位要杀的人在哪的呢？因为连杀谁都搞不清楚的话你这个妖怪未免也太逊了，你这个设定做得不行。事实上，在剧中女主确实是有一个用于定位要杀的人在哪里的道具，但是这个道具似乎只能定个位置，不能定位到具体是哪个人。而男主到了后期就和女主以为要杀的那个角色一直在一个位置，所以直到男主最后拿着道具站在女主面前跟她说明真相之前，大家都是蒙在鼓里的，包括男主自己，因为他一开始也不知道自己是「五矛」的后代之一，而那个定位道具也不是一开始就在女主手上的。</p><hr><p>这么看来，在设定这一块，编剧还是下了点功夫的，不能说天衣无缝，只能说勉强合理。但是话又说回来了，这种一季只有 8 集的恋爱喜剧也没必要那么较真设定了，只要不是太离谱，大家看个爽看个乐就完事了。这就像你看死侍一样，他都打破第四面墙了，你还跟他谈什么正经？</p><p>总而言之，结局不说 happy 但也不算 bad ，女主的离开也让男主有所成长，「五矛」组织死了他妈 4 个后代了后续估计也不成气候了，估计编剧也要想想搞个新的“反派”集团出来了吧。</p><p>后续怎么样我不知道，我知道的是编剧在片尾留了很多很多很多很多坑，而且直接明示了女主还没死（甚至都没被封印回去），所以只要反响还行、经费足够，那我觉得是很有可能出第二季的。不过也不是说你有续集就是好事，你质量要是下去了那和喂大家吃屎有什么区别。</p><blockquote><p><strong>最终评分：8 &#x2F; 10</strong></p></blockquote><p><img src="/../../images/ACGN/My.Undead.Yokai.Girlfriend.S01E08.If.You.Love.Someone.1080p.AMZN.WEB-DL.DDP5.1.H.264-ZeroTV-0003.jpg" alt="男主最后也成长了"></p><p><img src="/../../images/ACGN/My.Undead.Yokai.Girlfriend.S01E08.If.You.Love.Someone.1080p.AMZN.WEB-DL.DDP5.1.H.264-ZeroTV-0004.jpg" alt="女主还在人间"></p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin 协程学习笔记 ① - 基础知识</title>
    <link href="/post/Kotlin-Coroutine-Study-Guide-1-Basic/"/>
    <url>/post/Kotlin-Coroutine-Study-Guide-1-Basic/</url>
    
    <content type="html"><![CDATA[<p>协程是 Kotlin 的一个亮点，内容也比较多，故而拎出来单独做一篇笔记。本节只是对协程进行一个基础性的概述。</p><span id="more"></span><blockquote><p>本篇内容主要还是以基于 JVM 的 Kotlin 和 Android 开发的角度为主。</p></blockquote><h2 id="协程的历史"><a href="#协程的历史" class="headerlink" title="协程的历史"></a>协程的历史</h2><p>Kotlin 的协程是 2017 年初在 1.1 版本加入进来的，那时协程还只是实验性的（Experimental）。等到 2018 年底，Kotlin 更新到 1.3 版本的时候，协程才成为 Kotlin 的正式特性。接着到 2019 年 Kotlin 协程才推出 Flow 相关的 API。</p><p>事实上早在 1967 年的 Simula 语言当中，就已经出现了协程。不过在之后的几十年里，协程并没有被推广开，后续的 C、C++、Java 之类的语言，更多的是使用线程来进行异步和并发。直到 2012 年左右，C# 重新拾起了协程这个特性，实现了 async、await、yield。之后，JavaScript、Python、Kotlin 等语言才继续跟进实现了对应的协程。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>首先需要明确，虽然 Kotlin 现在已经是跨平台的了，但是协程在不同平台的底层实现并不完全一样。</p><p>协程和线程的作用是一样的，都是用来管理并发，有的语言用线程来管理并发，有的则是用协程，有的则两个都用。例如 Java 就是用线程的，而 Kotlin 则是用协程。并且 Kotlin 的协程在使用体验上要比线程好，这就是为什么在 JVM 上明明都已经有 Java 线程了，Kotlin 也是可以直接用线程的，可是 Kotlin 还是要封装一下线程，发明出个协程出来。协程中最大的亮点就在于它可以用线性的结构编写异步的代码，例如需要在子线程中进行网络请求，然后在主线程中显示结果时，用传统的线程的做法也好，用第三方库例如 RxJava 也好，难免要进行回调嵌套或者是链式调用，但是用协程就可以做到所有的代码都在同一个层级上，结构清晰明了。</p><p>虽然协程和线程的作用大致相同，但是它们的概念模型却不太一样，以下是对协程的几句简单介绍：</p><ul><li>可以简单理解为「相互协作的程序」，例如针对某个协程，可以通过<code>yield()</code>将其挂起，让出执行权。</li><li>可以理解为更加轻量的线程，成千上万个协程可以同时运行在一个线程当中，但是成千上万个线程就可能会出现内存溢出。</li><li>可以理解为是运行在线程当中的轻量的 Task ，这些 Task 支持挂起和恢复，当 Task 挂起时，就不会阻挡到后续的 Task 。</li><li>不会与特定的线程绑定，可以在不同的线程之间灵活切换。</li><li>协程是非阻塞式的，比如<code>delay()</code>，而线程是阻塞式的，比如<code>Thread.sleep()</code>。</li></ul><p>协程说白了就是用线程来实现的并发管理库，它要做的无非这么 3 件事：</p><ol><li>线程间的切换；<ol><li>例如：切换到 并行&#x2F;子 线程；</li><li>或者：在 Android 开发中，我们需要切换到 UI 线程，也就是主线程去更新界面（一般使用 Handler 或者 View 来操作）；</li></ol></li><li>线程间的配合，包括在各个线程的执行过程中去等待别的线程；</li><li>线程安全，也就是锁，也就是对共享资源访问的互斥，以达到保护资源的目的，确保资源正确性的作用；</li></ol><h2 id="引入协程库"><a href="#引入协程库" class="headerlink" title="引入协程库"></a>引入协程库</h2><p>在开始之前，还需要在项目中对协程进行进入，毕竟它是个库。通过<a href="https://github.com/Kotlin/kotlinx.coroutines">官方 GitHub 页面</a>的指示可以得知，如果项目是使用 Gradle 进行构建，那么就需要在其配置文件中引入：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    implementation(<span class="hljs-string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.9.0-RC&quot;</span>)<br>    <span class="hljs-comment">// ↓ 如果是 Android 开发，则额外引入以下这条依赖</span><br>    implementation(<span class="hljs-string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.9.0-RC&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="launch"><a href="#launch" class="headerlink" title="launch()"></a>launch()</h2><p>首先还是先来看一下在基于 JVM 的 Kotlin 中如何创建线程：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Thread &#123;<br>    <span class="hljs-comment">// 这是第一种方式</span><br>&#125;.start()<br><br><span class="hljs-comment">// ↓ 这是 Kotlin 封装的函数，本质上和第一种方式的实现是一样的</span><br>thread &#123;<br>    <span class="hljs-comment">// 这是第二种方式</span><br>&#125;<br></code></pre></td></tr></table></figure><p>还算是挺简单挺简洁的，不过在实际工作中，我们可能更多地会去使用线程池来管理和复用线程（而不是总是使用以上两种方法来独立创建线程）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> executor = Executors.newCachedThreadPool()<br>executor.execute &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一种启动协程的方式是通过协程作用域的扩展函数<code>launch()</code>，这种方式是 <strong>非阻塞式</strong> 的，但是 <strong>拿不到</strong> 执行的结果。</p><p>什么是「协程作用域」？协程作用域（CoroutineScope）首先是一个接口，用于管理协程的生命周期。其次它定义了一个作用域，所有在这个作用域内启动的协程都将受到它的控制。例如 ViewModel 库给我们提供了一个<code>viewModelScope</code>，这就是一个和 ViewModel 的生命周期绑定的作用域，当 ViewModel 的生命周期结束，该作用域也会随之结束，作用域内的所有协程都会被终止。</p><p><code>launch()</code>又是干什么的？<code>launch()</code>是协程作用域的扩展函数，协程作用域有很多种，但是<code>launch()</code>的目的只有一个，那就是在调用它的作用域内启动协程。</p><p>接下来先来看个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// ↓ 作用域    ↓ 启动协程</span><br>    GlobalScope.launch &#123;<br>        delay(<span class="hljs-number">1000</span>)<br>        println(Thread.currentThread().name)<br>    &#125;<br>    Thread.sleep(<span class="hljs-number">2000</span>)<br>    println(Thread.currentThread().name)<br>&#125;<br></code></pre></td></tr></table></figure><p>程序运行，打印结果如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">DefaultDispatcher</span>-worker-<span class="hljs-number">1</span> @coroutine#<span class="hljs-number">1</span><br><span class="hljs-attribute">main</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，<code>GlobalScope</code>虽然是一个可以启动协程的协程作用域，但是并不推荐使用它。一个更加贴合实际的做法是使用<code>CoroutineScope()</code>这个函数来创建一个协程作用域对象，并向其传递相应的协程上下文作为参数，就像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//                         ↓ 传递参数，用于指定上下文</span><br>    <span class="hljs-keyword">val</span> scope = CoroutineScope(Dispatchers.Default)<br>    scope.launch &#123;<br>        println(<span class="hljs-string">&quot;协程启动了&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>「协程上下文」是什么？协程上下文（CoroutineContext）是用于提供协程执行所需的信息和功能的，它和协程作用域是协程中两个很重要的概念。在上面的例子中，我们向构造函数中传入了<code>Dispatchers.Default</code>，其中<code>Dispatchers</code>可以理解为“调度器”，而<code>Default</code>则是协程提供的 4 个调度器中的一个，完整的调度器表格如下：</p><table><thead><tr><th align="center">名称</th><th align="center">用途</th><th align="center">线程池</th></tr></thead><tbody><tr><td align="center">Default</td><td align="center">默认调度器，用于执行计算密集型任务（一般指的是不与内存之外进行交互的操作，例如排序、拼接字符串等等）。</td><td align="center">使用共享的后台线程池，为了效率最大化，该线程池的线程数通常等于 CPU 核心数。</td></tr><tr><td align="center">Main</td><td align="center">主线程调度器，通常用于更新 UI 。</td><td align="center">该调度器不会使用线程池，而是直接把操作扔到主线程中去执行，比如在 Android 开发中就是这样。而如果在 Spring 或者 Ktor 这种服务端开发环境中使用了这个调度器的话就会报错，因为服务端没有这个需求。</td></tr><tr><td align="center">IO</td><td align="center">I&#x2F;O 调度器，用于执行 I&#x2F;O 密集型任务（例如文件读写、网络请求等等）。</td><td align="center">使用共享的 I&#x2F;O 线程池，一般情况下，线程数为固定的 64 条，但是当 CPU 的核心数大于 64 核时，线程数将被调整为与核心数相等。</td></tr><tr><td align="center">Unconfined</td><td align="center">不限制调度器，开始时在调用者线程中运行，随后在遇到第一个挂起点时根据具体的挂起函数决定运行线程。</td><td align="center">无特定线程池，适用于不需要指定特定线程的任务，或在某些情况下为了避免线程切换的开销；该调度并不如前面三个那么常用。</td></tr></tbody></table><p>除了使用已有的调度器（每种调度器决定了使用怎么样的线程池）以外，还可以通过<code>newFixedThreadPoolContext()</code>这个函数来创建自定义的线程池：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//                                   ↓ 线程数 ↓ 线程名称</span><br>    <span class="hljs-keyword">val</span> pool = newFixedThreadPoolContext(<span class="hljs-number">8</span>, <span class="hljs-string">&quot;myPool&quot;</span>)<br>    <span class="hljs-comment">//                          ↓ 传入创建好的线程池</span><br>    <span class="hljs-keyword">val</span> scope = CoroutineScope(pool)<br>    scope.launch &#123;<br>        println(<span class="hljs-string">&quot;协程启动了&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">//     ↓ 不用了要记得关掉线程池</span><br>    pool.close()<br>&#125;<br></code></pre></td></tr></table></figure><p><code>newFixedThreadPoolContext()</code>接收两个参数，一个是线程的数量（整型），一个是线程的名字（字符串）。此外这个函数还被<code>@DelicateCoroutinesApi</code>修饰，意在传达这是一个需要谨慎使用的函数，原因在于创建出来的自定义线程池当不再被使用时，要记得调用<code>close()</code>将其关闭。</p><p>那为什么<code>Dispatchers.Default</code>和<code>Dispatchers.IO</code>不需要手动关闭呢？这是因为它们是由 Kotlin 协程库内部管理的全局调度器，它们的生命周期与应用程序的生命周期同步，系统会在适当的时候自动管理这些调度器的资源。</p><p><code>launch()</code>用于启动协程并返回一个<code>Job</code>对象，要注意，该对象仅代表协程的句柄（Handle），而不是协程的执行结果。进入<code>launch()</code>内部会发现该函数接收 3 个参数，分别是：</p><ol><li>协程上下文<code>CoroutineContext</code>，默认为<code>EmptyCoroutineContext</code>，代表空上下文。</li><li>协程启动模式<code>CoroutineStart</code>，默认为<code>CoroutineStart.DEFAULT</code>，代表立即执行。</li><li>一个函数类型的参数：<code>suspend CoroutineScope.() -&gt; Unit</code>，该参数就是我们要让协程执行的具体代码，在调用<code>launch()</code>的地方以 Lambda 表达式传入。此外，该参数的函数类型是挂起函数，并且是<code>CoroutineScope</code>的成员函数或者扩展函数，最后就是该函数没有返回值。</li></ol><p>在<code>CoroutineScope()</code>中可以传入具体的上下文，在<code>launch()</code>中也可以，就像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//                         ↓ 这里先传入空的上下文</span><br>    <span class="hljs-keyword">val</span> scope = CoroutineScope(EmptyCoroutineContext)<br>    <span class="hljs-comment">//           ↓ 此处传入具体的上下文</span><br>    scope.launch(Dispatchers.Default) &#123;<br>        println(<span class="hljs-string">&quot;协程启动了&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>launch()</code>中传入上下文与在<code>CoroutineScope()</code>中传入上下文的区别就在于传入的上下文是否可以被复用。具体来说，在<code>CoroutineScope()</code>创建的协程作用域内启动的协程默认都是使用这个作用域的上下文，例如我使用<code>CoroutineScope(Dispatchers.Default)</code>创建协程作用域，那么每次调用<code>launch()</code>启动的协程的上下文都是<code>Dispatchers.Default</code>。但是如果我在调用<code>launch()</code>时特地往里面传递上下文，那么启动的这个协程就会忽略所在作用域提供的上下文，并以我传递的上下文为准，非常灵活。</p><h2 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h2><p>在 Kotlin 协程中，可以用<code>suspend</code>关键字来修饰函数，被修饰的函数被称为“挂起函数”，挂起函数只能在协程里或者是被别的挂起函数调用。协程之所以在切换线程后还能自动“切回来”，主要依靠的就是这种函数。例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    CoroutineScope(Dispatchers.Main).launch &#123;<br>        foo()<br>        <span class="hljs-comment">// 做一些界面更新操作</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 自定义挂起函数</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    delay(<span class="hljs-number">1000</span>)  <span class="hljs-comment">// 模拟网络请求</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以上是一个定义并使用了挂起函数的简单用例，其中<code>foo()</code>为挂起函数，函数为了模拟网络请求（或者其它耗时操作），在函数体内调用了<code>delay()</code>进行了 1 秒钟的延迟。<code>foo()</code>执行的延时操作并不会阻塞主线程，这是因为它是挂起函数，它的执行伴随着协程的挂起。而在主函数中，我们首先在主线程中启动了一个协程，并在其中调用了挂起函数<code>foo()</code>，在<code>foo()</code>下面，我们可以执行一些界面更新操作（这里将这些代码省略了）。假设<code>foo()</code>返回了一些请求的结果，当我们需要将这些结果展示在界面上时，我们就可以在调用<code>foo()</code>的位置的下面去执行界面的更新操作，这是因为协程是运行在主线程中的。</p><h3 id="客户端场景"><a href="#客户端场景" class="headerlink" title="客户端场景"></a>客户端场景</h3><p>上面的例子也算是协程在涉及界面（例如 Android 客户端开发）的项目中一个比较常见的做法：在主线程启动一个协程，然后在其中通过调用挂起函数来执行耗时任务，执行完成后再回到主线程，这样就可以把耗时操作扔到后台去，从而不影响界面交互和响应。</p><p>值得注意的是，在这个过程中，我们通常也不会通过<code>CoroutineScope(Dispatchers.Main)</code>来创建位于主线程的协程，而是通过 Jetpack 库里已有的接口。例如<code>lifecycleScope</code>——这是<code>LifecycleOwner</code>这个接口的扩展属性，而<code>LifecycleOwner</code>这个接口有两个很典型的实现类，一个是位于<code>androidx</code>之下的<code>ComponentActivity</code>，也就是 Activity ，另一个则是 Fragment ，也是位于<code>androidx</code>之下的。也就是说，在这两个类里，我们可以直接调用<code>lifecycleScope</code>。</p><p><code>lifecycleScope</code>是一个现成的协程作用域（可以用来直接启动协程），其特点之一在于它启动的协程默认使用的是<code>Dispatchers.Main</code>上下文，这和我们上面手动指定<code>Dispatchers.Main</code>的例子的效果是一样的。但是严谨来说，<code>lifecycleScope</code>内部使用的上下文其实是<code>Dispatchers.Main.immediate</code>，它与<code>Dispatchers.Main</code>的区别在于后者启动的协程不管当前是在什么线程，都会把任务以 Handler.post() 的方式发布到主线程的消息队列中；而前者则会先判断一下当前所在线程，如果不在主线程，那么就和后者做一样的事，如果当前已经在主线程中了，那就会直接执行协程中的代码。总之结论就是尽可能使用<code>Dispatchers.Main.immediate</code>，因为它是经过性能优化的，换句话说，可以的话，请使用<code>lifecycleScope</code>而不是<code>CoroutineScope(Dispatchers.Main)</code>。</p><p><code>lifecycleScope</code>的特点之二是其会与所在组件的生命周期进行绑定，例如在 Activity 里调用，那么它就会与 Activity 进行绑定，当 Activity 销毁时，<code>lifecycleScope</code>会自动去取消该作用域内的所有协程，从而达到避免内存泄漏和不必要资源浪费的目的。</p><p>除了<code>lifecycleScope</code>以外，Jetpack 中的 ViewModel 组件也提供了类似的作用域——<code>viewModelScope</code>。<code>viewModelScope</code>是 ViewModel 的扩展属性，所以只能在 ViewModel 中使用，这在我们进行界面数据管理时帮助很大。除此之外，它和<code>lifecycleScope</code>基本一样，<code>viewModelScope</code>使用的上下文也是<code>Dispatchers.Main.immediate</code>，并且也会绑定生命周期，自动释放资源。</p><h3 id="withContext"><a href="#withContext" class="headerlink" title="withContext"></a>withContext</h3><p><code>withContext()</code>就是一个挂起函数，一般用于在协程中切换上下文。它与<code>launch()</code>的区别在于，<code>launch()</code>启动的是并行的协程，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">CoroutineScope(Dispatchers.Main).launch &#123; <br>    launch(Dispatchers.IO) &#123; <br>        <br>    &#125;<br>    println()<br>&#125;<br></code></pre></td></tr></table></figure><p>所谓「并行」，就是<code>launch(Dispatchers.IO)</code>这行代码执行完后，下面的打印就会接着立刻执行，而不会理会上面启动协程的代码的运行情况，无论启动的这个协程是否执行完成，下面的代码都会继续执行。</p><p>而，如果想要串行地切换协程上下文，就要使用挂起函数，就像前面讲到的客户端开发场景一样，使用挂起函数去执行耗时操作，执行完成后，再回到主线程执行更新界面的操作。这就是「串行」，一件事情到一件事情。例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">CoroutineScope(Dispatchers.Main).launch &#123;<br>    <span class="hljs-comment">// ↓ 把 launch() 改成了 withContext()</span><br>    withContext(Dispatchers.IO) &#123;<br><br>    &#125;<br>    println()<br>&#125;<br></code></pre></td></tr></table></figure><p><code>withContext()</code>也接收一个协程上下文的参数，用于指定它切换到哪个调度器上。在上面的例子中，<code>println()</code>以及它以下的代码（如果它下面还有代码的话）就会在<code>withContext()</code>中的代码执行完成后再执行，并且<code>withContext()</code>中的代码的上下文是<code>Dispatchers.IO</code>，而<code>withContext()</code>外的代码的上下文还是<code>Dispatchers.Main</code>。</p><p><code>withContext()</code>的用法基本上就是这样，还有一点值得注意的是，<code>withContext()</code>是有返回值的，它的 Lambda 表达式的最后一行将作为协程执行结果返回。</p><p>接下来再讲一下使用类似于<code>withContext()</code>这种官方提供的挂起函数的时候的一个比较好的编码习惯，且看下面这个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">CoroutineScope(Dispatchers.Main).launch &#123;  <br>    <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = withContext(Dispatchers.IO) &#123;  <br>        delay(<span class="hljs-number">2000</span>)  <span class="hljs-comment">// 模拟网络请求  </span><br>        <span class="hljs-string">&quot;data&quot;</span>  <span class="hljs-comment">// 返回请求到的结果  </span><br>    &#125;  <br>    println(<span class="hljs-string">&quot;请求结果：<span class="hljs-variable">$data</span>&quot;</span>)  <span class="hljs-comment">// 打印请求结果  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我首先创建了一个使用主线程上下文的协程作用域并启动了一个协程，随后在这个协程中，我又通过<code>withContext()</code>切换到另一个基于 IO 上下文的协程中去进行网络请求，最后将请求到的结果进行打印。</p><p>上面的代码在功能上来说是没问题的，但是当我们为了追求更好的可读性和复用性的时候，可能会考虑对结构进行以下优化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">CoroutineScope(Dispatchers.Main).launch &#123;  <br>    <span class="hljs-comment">//         ↓ 将切换到 IO 上下文做网络请求的操作单独提取至一个函数中  </span><br>    <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = getData()  <br>    println(<span class="hljs-string">&quot;请求结果：<span class="hljs-variable">$data</span>&quot;</span>)  <span class="hljs-comment">// 打印请求结果  </span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span></span> = withContext(Dispatchers.IO) &#123;  <br>    delay(<span class="hljs-number">2000</span>)  <span class="hljs-comment">// 模拟网络请求  </span><br>    <span class="hljs-string">&quot;data&quot;</span>  <span class="hljs-comment">// 返回请求到的结果  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个改动的重点在于，将<code>withContext()</code>连同其它操作一并提取出来，而非是像下面这样，只提取业务逻辑（以下代码仅作为示例，并非推崇的做法）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">CoroutineScope(Dispatchers.Main).launch &#123;  <br>    <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = withContext(Dispatchers.IO) &#123;  <br>        getData()  <br>    &#125;  <br>    println(<span class="hljs-string">&quot;请求结果：<span class="hljs-variable">$data</span>&quot;</span>)  <span class="hljs-comment">// 打印请求结果  </span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span></span>: String &#123;  <br>    delay(<span class="hljs-number">2000</span>)  <span class="hljs-comment">// 模拟网络请求  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;data&quot;</span>  <span class="hljs-comment">// 返回请求到的结果  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样的改动除了提高可读性以外，还可以确保网络请求正确无误地在 IO 上下文中执行，并且就算是在<code>Dispatchers.IO</code>中调用<code>getData()</code>，也不会出现性能问题。</p><h3 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h3><p>前面提到挂起函数可以自动切换到后台线程，然后在执行完任务后又切换回主线程执行剩下的任务，挨在一起的上下两行代码就有可能出现上面的代码执行在后台线程，下面的代码执行在主线程的情况，这样的特性虽然带来了简洁和高效的写法，但是却也容易误导开发者，因为它隐藏了一些细节。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">CoroutineScope(Dispatchers.Main).launch &#123;  <br>    <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = withContext(Dispatchers.IO) &#123;  <br>        delay(<span class="hljs-number">2000</span>)  <span class="hljs-comment">// 模拟网络请求  </span><br>        <span class="hljs-string">&quot;data&quot;</span>  <span class="hljs-comment">// 返回请求到的结果  </span><br>    &#125;  <br>    println(<span class="hljs-string">&quot;请求结果：<span class="hljs-variable">$data</span>&quot;</span>)  <span class="hljs-comment">// 打印请求结果  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>比如还是之前的这个例子，<code>withContext()</code>中的代码就是在 IO 上下文中执行的，赋值给变量<code>data</code>的操作和下面打印的操作是在 Main 上下文中执行的，这些在 Main 上下文的操作都会等到 IO 上下文的操作执行完成后再执行，原因前面也说过了（<code>withContext()</code>是串行切换协程的）。这就带来一个问题：这些在 Main 上下文的操作既然要等，那这样的等待难道不会导致主线程阻塞吗？那肯定是不会的，答案我们都能猜到，但是原因是什么呢？</p><p>首先我们要知道，在 Java 中，我们是可以在主线程去启动一个子线程的，另外，我们也可以指定某个线程池去执行某个任务，这些我们都可以做到。但是有那么几件事我们是实现不了的：</p><ol><li>从主线程切换到某个指定的子线程中；</li><li>从任意子线程切换回主线程中；</li><li>我们虽然能指定线程池去执行某个任务，但是具体是线程池中的哪个线程去执行，这是由线程池自己决定的，我们也无法人为干预；</li></ol><p>但是在 Android 开发中，我们又确实存在从后台线程回到主线程的能力，用 Handler 呗，对吧。但是我们之所以能这么做，也是由 Android 本身的特性决定的，Android 的主线程或者说 UI 线程是一个无限循环的线程，它始终都在工作，比如刷新界面，然后检查消息队列里有没有需要执行的任务，所以我们才能在有需要的时候回到主线程去执行类似于更新界面之类的工作。</p><p>说到这里，我们就已经对挂起函数为什么能回到主线程有一个非常初步的认知了：不是因为它创造了 Java 中不存在的东西，而是它利用了 Android 系统的特性而已。我们接着往下说。</p><p>其实在 Android 开发中，我们还是能指定某个子线程来执行任务的，那个子线程就是<code>HandlerThread</code>，但它终究是个特例，因为它就是被官方定制过的，我们能切换到它上面也是因为它也是个无限循环的线程。</p><p>说回协程，我们直接从<code>launch()</code>入手。<code>launch()</code>是个高阶函数，我们在它的大括号里写的代码其实是被封装起来作为参数传递了，传递的目的地就是协程的上下文，传递后如何被执行则取决于上下文的实现。接下来我们就来看看协程的上下文，首先是<code>Dispatchers.Default</code>和<code>Dispatchers.IO</code>，这两个上下文都间接继承了<code>Executor</code>，表明它们内部都有着自己维护的线程池，我们在<code>launch()</code>大括号中的代码最终会被它们的<code>dispatch()</code>函数扔到它们自己的线程池当中去执行，这也就是我们能切换到后台线程的大致原理了。事实上，<code>Dispatchers.Main</code>也是类似这样工作的，因为它也有一个<code>dispatch()</code>函数，在调用这个函数前，它会去获取主线程的 Looper ，然后在这个函数中，再通过 handler.post() 去将代码传递到主线程中。</p><p>所以说白了协程并没有跳出 Java ，Java 里切线程是基于回调的，协程里切线程也是基于回调的，只不过协程通过封装，隐藏了细节，让开发者做的事情变少了，它自己则是在后期的编译过程中去把这些操作加上。具体的做法，我们也可以参考 Retrofit ，当我们调用了<code>enqueue()</code>后，我们的网络请求任务就会被丢到线程池中，线程池将从后台启动线程来执行我们的网络请求，这就是第一次线程切换。当网络请求完成后，线程池还会把请求的结果（无论是成功还是失败）通过 Handler 扔回主线程，让主线程去执行相应的回调，这就是第二次线程切换。协程也是这样，在挂起函数执行前切换一次线程，在挂起函数执行后又切换一次线程。我们甚至可以说挂起函数和<code>launch()</code>是相似的，都是通过线程池切到后台，然后通过平台机制（Android 的 Handler）切回前台。</p><p>最后我们再回到最初的问题上，在 Main 上下文的操作要等到 IO 上下文的操作执行完成后再执行，这里的「等」只是我们的口头表述而已，实际上挂起函数里的代码早都已经离开主线程，被扔到后台线程中去执行了，等执行完了，再把结果扔回主线程，主线程在这个过程中该干嘛干嘛，等到后台线程执行完了，将结果扔到主线程的消息队列里的时候，主线程再去里面取出来就好了，所以也就不会存在阻塞主线程一回事了。</p><h2 id="协程更轻？"><a href="#协程更轻？" class="headerlink" title="协程更轻？"></a>协程更轻？</h2><p>Kotlin 官方文档将协程描述为一个轻量级的线程，并且还附上了代码来证明：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    repeat(<span class="hljs-number">50_000</span>) &#123; <span class="hljs-comment">// launch a lot of coroutines</span><br>        launch &#123;<br>            delay(<span class="hljs-number">5000L</span>)<br>            print(<span class="hljs-string">&quot;.&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里我们启动了五万个协程，程序依旧能正常运行并完成任务，但是如果我们启动的是五万个线程的话，程序就会出现内存溢出的情况。</p><p>但是这并不能说明什么，毕竟我们都知道协程终究还是跳不出线程的，这里之所以能创建五万个协程而不会导致程序崩溃主要还是因为<code>runBlocking()</code>。究其原因就是这个函数将五万个协程都放进一个线程中去工作了，在上面的例子中就是都放进主线程去了。也就是说，如果我在 Java 线程也能有把这五万个任务都放到一个线程里去工作的方法的话，那我也不会内存溢出。</p><p>官方文档甚至还告诉我们，如果我们把示例代码中的<code>runBlocking()</code>移除，然后把<code>launch</code>换成<code>thread</code>，然后再把<code>delay</code>换成<code>Thread.sleep</code>，程序运行就会消耗大量的内存，但是文档压根就不提<code>delay()</code>和<code>Thread.sleep()</code>的区别。<code>delay()</code>是一个挂起函数，可以将协程暂停执行一段时间，它和 Java 的<code>Thread.sleep()</code>有点像，但又不一样，因为<code>delay()</code>并不会阻塞线程。<code>delay()</code>的本质让它只能成为一个「延时操作」而非「耗时操作」，但是<code>Thread.sleep()</code>是会堵塞线程的，在 sleep 的这段时间里线程什么也干不了，所以<code>delay()</code>和<code>Thread.sleep()</code>不一样。</p><p>综上所述，在线程中，如果我们既要执行类似于协程的延时操作，又要把任务都放到一个线程中去执行，那我们就可以使用<code>ScheduledExecutorService</code>的<code>schedule()</code>。就像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> executor = Executors.newSingleThreadScheduledExecutor()  <br>repeat(<span class="hljs-number">50_000</span>) &#123;  <br>    executor.schedule(&#123; print(<span class="hljs-string">&quot;.&quot;</span>) &#125;, <span class="hljs-number">5</span>, TimeUnit.SECONDS)  <br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，官方的这个文档似乎又有点误导人的嫌疑……但是我们再换个角度想，在线程中，如果要做延时操作，我们要用到<code>schedule()</code>，这个函数本身就已经有点麻烦了，更别提实际场景中还有更复杂的并发逻辑。但是在协程中，我们就只需要一句<code>delay()</code>就行了……这种简洁高效的写法，相比线程来说，也不失为一种「轻量」。</p><h2 id="取消协程"><a href="#取消协程" class="headerlink" title="取消协程"></a>取消协程</h2><p>取消协程可以被归纳到结构化并发的知识中，所谓结构化并发（Structured Concurrency）是一种编程模型和设计原则，旨在使并发代码更具可读性、更易于管理，并减少常见的并发错误。其核心思想是将并发任务的生命周期绑定到特定的作用域中，从而确保这些任务在作用域结束时要么完成，要么被取消。</p><p>比如，我们在启动协程时需要有一个协程作用域（CoroutineScope），这玩意儿既可以提供协程所需要的上下文，同时也具备取消协程的能力：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> scope = CoroutineScope(Dispatchers.Default)  <br>scope.launch &#123;  <br>    delay(<span class="hljs-number">5000</span>)  <br>&#125;  <br>scope.cancel()<br></code></pre></td></tr></table></figure><p>在客户端项目中，我们能很容易联想到一个需要取消协程的场景：例如在用户发起网络请求后，这个请求的结果将被用于更新界面，但是在获取到结果前，用户离开了，那为了避免出现资源浪费和内存泄漏的风险，我们就可以在 Activity 的<code>onDestroy()</code>中去取消协程。</p><p>除了能通过协程作用域去取消协程，对于通过<code>launch()</code>启动的单个协程，我们也可以调用它的<code>cancel()</code>来取消它：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//   ↓ 我们前面提到通过`launch()`启动的协程是无法返回执行结果的</span><br><span class="hljs-comment">//   ↓ 相对的它会返回一个`Job`对象用来管理这个协程</span><br><span class="hljs-keyword">val</span> job = CoroutineScope(Dispatchers.Default).launch &#123;  <br>    delay(<span class="hljs-number">5000</span>)  <br>&#125;  <br>job.cancel()<br></code></pre></td></tr></table></figure><p>这两个<code>cancel()</code>的区别在于，协程作用域的<code>cancel()</code>会把其作用域内启动的所有协程都取消掉，而后者只会取消其对应的那个协程。</p><p>除了这种「作用域管理」外，「父子协程关系」也是在结构化并发中需要了解的。简单来说，协程可以嵌套启动，形成父子关系：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//                                   ↓ 启动一个协程  </span><br>CoroutineScope(Dispatchers.Default).launch &#123;  <br>    <span class="hljs-comment">// ↓ 在内部又启动一个子协程  </span><br>    launch &#123;   <br>          <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>父协程需要等待其所有子协程完成，然后才会自己完成。如果父协程被取消，它的所有子协程也会被递归地取消。这种关系有助于保持并发操作的一致性和可预测性。</p><h2 id="async-和-join"><a href="#async-和-join" class="headerlink" title="async() 和 join()"></a>async() 和 join()</h2><p>先来回顾一下<code>launch()</code>和挂起函数，<code>launch()</code>用来启动协程，多个相同层级的<code>launch()</code>会启动多个并行的协程，但是这些协程之间无法进行交互（比如一个协程获取另一个协程的执行结果）。而挂起函数相比<code>launch()</code>来说则更多是用在串行的工作流当中，因为它会把当前协程挂起，等后台任务执行完成后再返回到当前协程执行接下来的代码，这样一来，我们就可以轻松拿到并使用后台任务的执行结果了（比如前面提到的将网络请求得到的结果用于更新界面的例子）。</p><p>所以现在的问题在于并行的协程该如何交互，比如有一个场景是要同时发起多个网络请求，并将这些请求的结果进行统一处理，虽然<code>launch()</code>是并行的，但是它并不能返回执行结果。面对这种情况，我们就需要引入<code>async()</code>了。</p><p><code>async()</code>也是一种启动协程的方式，它和<code>launch()</code>一样是非阻塞式的，不同的地方在于<code>async()</code>会返回一个<code>Deferred</code>对象，这个对象可以在将来某个时间点通过调用它的<code>await()</code>来获取协程的执行结果，所以<code>async</code>通常与<code>await()</code>一起使用。例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 模拟第一个网络请求，获取用户名  </span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getUserName</span><span class="hljs-params">()</span></span>: String &#123;  <br>    delay(<span class="hljs-number">1000</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Aiden&quot;</span>  <br>&#125;  <br>  <br><span class="hljs-comment">// 模拟第二个网络请求，获取用户年龄  </span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getUserAge</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;  <br>    delay(<span class="hljs-number">1000</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">24</span>  <br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码定义了两个挂起函数，用于模拟两个网络请求。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> deferred = lifecycleScope.async &#123;  <br>    getUserName()  <br>&#125;  <br>lifecycleScope.launch &#123;  <br>    <span class="hljs-keyword">val</span> age = getUserAge()  <br>    <span class="hljs-keyword">val</span> name = deferred.await()  <br>    println(<span class="hljs-string">&quot;Name: <span class="hljs-variable">$name</span>, Age: <span class="hljs-variable">$age</span>&quot;</span>)  <br>&#125;<br></code></pre></td></tr></table></figure><ol><li>接下来首先使用<code>async</code>启动一个协程，并在其中调用获取用户名的挂起函数，同时定义一个变量用来持有<code>async</code>返回的<code>Deferred</code>对象。</li><li>然后再用<code>launch()</code>启动一个并行的协程，并在其中先调用获取用户年龄的挂起函数，此时两个网络请求都在运行，当获取用户年龄的挂起函数执行完成后会返回到当前线程进行赋值。</li><li>赋值完成便来到下一行，通过调用前面保存的<code>Deferred</code>对象的<code>await()</code>来拿到获取用户名的挂起函数的执行结果，此时如果这个挂起函数已经执行完成，那这个地方就能正常拿到结果，否则<code>await()</code>就会将协程挂起，并等待获取用户名的挂起函数执行完成，因为<code>await()</code>也是个挂起函数。</li><li>当用户年龄和用户名都拿到以后，最后就整合并打印信息。</li></ol><p>事实上，第一个部分的代码（那两个模拟网络请求的挂起函数）在不变的情况下，第二部分的代码还是可以再调整一下，使其可读性会高一些且易于管理：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">lifecycleScope.launch &#123;  <br>    <span class="hljs-keyword">val</span> name = async &#123; getUserName() &#125;  <br>    <span class="hljs-keyword">val</span> age = async &#123; getUserAge() &#125;  <br>    println(<span class="hljs-string">&quot;Name: <span class="hljs-subst">$&#123;name.await()&#125;</span>, Age: <span class="hljs-subst">$&#123;age.await()&#125;</span>&quot;</span>)  <br>&#125;<br></code></pre></td></tr></table></figure><hr><p>接下来再说说<code>join()</code>，这个函数是个挂起函数，它的功能就好像它的名字一样，在调用它的地方将协程挂起，等待被调用者（也是个协程）里的任务执行完成后，再恢复协程。</p><p>可以想象这么一个开发场景：某个程序启动了多个并行的协程，其中一个用于初始化工作，并且在后续的工作中有需要依赖这个初始化工作的结果的地方，那么在开始后续的工作之前，我可以先通过调用<code>join()</code>来确保这个负责初始化工作的协程已经执行完成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">lifecycleScope.launch &#123;  <br>    <span class="hljs-keyword">val</span> initJob = launch &#123;  <br>        delay(<span class="hljs-number">3000</span>)  <span class="hljs-comment">// 模拟初始化工作  </span><br>    &#125;  <br>    launch &#123;  <br>        <span class="hljs-comment">// 假设在这里开启了其它的并行协程  </span><br>    &#125;  <br>    <span class="hljs-comment">//       ↓ 等待初始化完成  </span><br>    initJob.join()  <br>    <span class="hljs-comment">//  进行后续的工作  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>其实这里也可以把<code>launch()</code>换成<code>async()</code>，把<code>join()</code>换成<code>await()</code>，但是我们的初始化工作并没有返回值，就没必要使用<code>async()</code>。说到底设计<code>async()</code>和<code>join()</code>的目的就是不一样的，当我们需要等待某个协程执行完成，但是这个协程并不返回执行结果时，就可以使用<code>join()</code>来确保程序执行的正确性。</p><h2 id="suspendCoroutine"><a href="#suspendCoroutine" class="headerlink" title="suspendCoroutine()"></a>suspendCoroutine()</h2><p><code>suspendCoroutine()</code>是一个挂起函数，其作用就是包裹住那些使用传统回调机制的代码，使其整体上成为协程代码，以适配项目其它地方的协程风格。</p><p><code>suspendCoroutine()</code>的使用要点就是把原本的回调机制结构的代码直接放进<code>suspendCoroutine()</code>中，然后在回调函数中对结果的返回方式进行修改，前者很简单，问题在于后者应该怎么改。比如使用传统的回调机制结构的代码进行了网络请求，请求成功要返回请求结果，请求失败要返回 Exception ，这是第一个点。第二个点是在传统的回调机制的代码中，我们有时候会在回调函数里去进行接下来的工作，比如回调函数返回了网络请求的结果，我们拿到结果后就直接在回调函数里更新界面了。</p><p>基于以上这两个点，我们将引入<code>Continuation</code>接口的<code>resume(value: T)</code>，这个函数接收一个泛型参数，其功能用于恢复已挂起的协程，并将接收到的参数作为返回值进行返回。所以在上面提到的场景中，对于回调函数提供的网络请求成功的结果，我们应该直接使用<code>resume(value: T)</code>对其进行返回，随后在挂起函数的调用处在对返回的结果进行应用。</p><p>除了<code>resume(value: T)</code>以外，<code>Continuation</code>接口中还有一个函数是<code>resumeWithException(exception: Throwable)</code>，这个函数同样用来恢复挂起函数，并且也有返回值，只不过它所返回的是异常。在网络请求等场景中，我们通常都会有成功和失败两种情况，对于失败这条分支而言，我们通常就会调用<code>resumeWithException(exception: Throwable)</code>将异常抛出，随后在挂起函数的调用处在对异常进行捕获。</p><p>接下来是一个极度简化的例子，首先是在没有使用<code>suspendCoroutine()</code>的情况下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 网络请求回调接口  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NetworkCallback</span> &#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(response: <span class="hljs-type">String</span>)</span></span>  <br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(error: <span class="hljs-type">Throwable</span>)</span></span>  <br>&#125;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 模拟网络请求  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">makeNetworkRequest</span><span class="hljs-params">(callback: <span class="hljs-type">NetworkCallback</span>)</span></span> &#123;  <br>    <span class="hljs-keyword">val</span> success = <span class="hljs-literal">true</span>  <span class="hljs-comment">// 假设请求成功或失败  </span><br>  <br>    <span class="hljs-keyword">if</span> (success) &#123;  <br>        <span class="hljs-comment">// 模拟成功的响应  </span><br>        <span class="hljs-keyword">val</span> response = <span class="hljs-string">&quot;请求成功，这是结果：&quot;</span>  <br>        callback.onSuccess(response)  <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-comment">// 模拟失败的响应  </span><br>        <span class="hljs-keyword">val</span> error = Exception(<span class="hljs-string">&quot;请求失败，这是原因：&quot;</span>)  <br>        callback.onFailure(error)  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>接着我在 Activity 中去开启一个子线程然后调用函数进行网络请求：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">thread &#123;  <br>    makeNetworkRequest(<span class="hljs-keyword">object</span> : NetworkCallback &#123;  <br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(response: <span class="hljs-type">String</span>)</span></span> &#123;  <br>            println(response)  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(error: <span class="hljs-type">Throwable</span>)</span></span> &#123;  <br>            println(error.message)  <br>        &#125;  <br>    &#125;)  <br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们再来看看使用<code>suspendCoroutine()</code>的版本，网络请求回调接口和模拟网络请求的代码都不需要变更，我们首先新增一个挂起函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suspendMakeNetworkRequest</span><span class="hljs-params">()</span></span> = suspendCoroutine &#123;  <br>    makeNetworkRequest(<span class="hljs-keyword">object</span> : NetworkCallback &#123;  <br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(response: <span class="hljs-type">String</span>)</span></span> &#123;  <br>            it.resume(response)  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(error: <span class="hljs-type">Throwable</span>)</span></span> &#123;  <br>            it.resumeWithException(error)  <br>        &#125;  <br>    &#125;)  <br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我直接把之前网络请求的代码复制粘贴进来了，并且修改了成功和失败两个回调函数对于结果的处理方式，如果成功，就返回结果，如果失败，就抛出异常。</p><p>Activity 中的代码也需要改成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">lifecycleScope.launch &#123;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">val</span> result = suspendMakeNetworkRequest()  <br>        println(<span class="hljs-string">&quot;Result: <span class="hljs-variable">$result</span>&quot;</span>)  <br>    &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;  <br>        println(<span class="hljs-string">&quot;Error: <span class="hljs-subst">$&#123;e.message&#125;</span>&quot;</span>)  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>val result = suspendMakeNetworkRequest()</code>这一行代码就跟前面很多使用挂起函数的例子一样了，如此一来便完成了将使用线程的代码封装成挂起函数，从而实现了传统回调机制结构的代码风格到协程代码风格的转变。</p><p>值得注意的是，在这里我还是手动编写了 try catch 语句块用于捕获异常，这个异常如果不在这里捕获，那么它就会被丢给更外层的协程去处理。另外对于协程异常的捕获，存在一种错误的写法，同样以上面的代码为例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">lifecycleScope.launch &#123;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// ↓ 额外启动了一个协程  </span><br>        launch &#123;  <br>            <span class="hljs-keyword">val</span> result = suspendMakeNetworkRequest()  <br>            println(<span class="hljs-string">&quot;Result: <span class="hljs-variable">$result</span>&quot;</span>)  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;  <br>        println(<span class="hljs-string">&quot;Error: <span class="hljs-subst">$&#123;e.message&#125;</span>&quot;</span>)  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，launch 代码块内的异常，try 是捕获不到的，这是因为 launch 只是用来启动协程，它一执行完，try catch 语句块也跟着结束了。</p><hr><p>我们最后再来看一个相关的函数——<code>suspendCancellableCoroutine()</code>，看名字我们就大概能猜到，这是一个支持取消的<code>suspendCoroutine()</code>。</p><p>前面我们提到，想要取消一个协程，直接调用它的<code>cancel()</code>就行了。但是有一个前提我们也需要知道，那就是哪怕是线程的取消，它也只是一个标记位而已，至于能不能立刻取消，那也得看 JVM 怎么操作。同样的，协程的取消，也要挂起函数配合，所以如果在协程中遇到线程的 API ，那就算你调用<code>cancel()</code>，也无法保证协程一定能取消。</p><p>不仅如此，<code>suspendCoroutine()</code>它虽然是个挂起函数，但是它也不配合协程的取消，所以我们才要使用到<code>suspendCancellableCoroutine()</code>，接下来我们以上面的代码为基础写一个示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//          ↓ 首先是这个函数这里需要把 suspendCoroutine 替换成 suspendCancellableCoroutine</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suspendMakeNetworkRequest</span><span class="hljs-params">()</span></span> = suspendCancellableCoroutine &#123;  <br>    <span class="hljs-comment">// 省略其余代码 </span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//   ↓ 随后定义一个变量持有这个作用域  </span><br><span class="hljs-keyword">val</span> job = lifecycleScope.launch &#123;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">val</span> result = suspendMakeNetworkRequest()  <br>        println(<span class="hljs-string">&quot;Result: <span class="hljs-variable">$result</span>&quot;</span>)  <br>    &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;  <br>        println(<span class="hljs-string">&quot;Error: <span class="hljs-subst">$&#123;e.message&#125;</span>&quot;</span>)  <br>    &#125;  <br>&#125;  <br>job.cancel()  <span class="hljs-comment">// 在这里调用作用域的 cancel() 用于取消协程</span><br></code></pre></td></tr></table></figure><p>这样一来，假设网络请求需要消耗一定的时间，比如说几秒钟，那么上面的代码就会在网络请求还没完成前就把协程取消掉了。</p><p>另外，当我们需要<code>suspendCancellableCoroutine()</code>在被取消前执行一些收尾工作时，就可以这么写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suspendMakeNetworkRequest</span><span class="hljs-params">()</span></span> = suspendCancellableCoroutine &#123;  <br>    it.invokeOnCancellation &#123;  <br>        <span class="hljs-comment">// 在这里做一些取消前的收尾工作  </span><br>    &#125;  <br>  <br>    <span class="hljs-comment">// 省略其余代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后总结一下：</p><ul><li>当我们需要将传统的回调机制的代码封装成挂起函数时，可以使用<code>suspendCoroutine()</code>，大致做法就是将回调机制的代码都复制进去，然后改一下返回结果的方式。<ul><li>正常返回使用<code>resume(value: T)</code>；</li><li>抛出异常使用<code>resumeWithException(exception: Throwable)</code>；</li></ul></li><li>当我们将传统的回调机制的代码封装成挂起函数，并且希望其支持取消功能时，就可以使用<code>suspendCancellableCoroutine()</code>。<ul><li>取消仍然是通过调用<code>cancel()</code>；</li><li>可以通过<code>invokeOnCancellation()</code>设置取消前的收尾工作，注意这是在协程被取消时才会执行的工作，如果是正常的收尾工作则该写哪就在哪写。</li></ul></li></ul><h2 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking()"></a>runBlocking()</h2><p><code>runBlocking()</code>也是一个用于启动协程的函数，它和前面<code>launch()</code>、<code>async()</code>的区别有两点，一是它的执行不需要协程作用域，之所以如此，是因为它不需要我们前面提到的协程作用域提供的功能（协程上下文和取消协程）。第二个区别就是它的运行会阻塞当前线程，无论它是运行在线程的代码里还是协程的代码里，阻塞一直持续到它自己代码块内的代码执行完成后才会恢复线程。</p><p><code>runBlocking()</code>之所以这样设计也是和它的定位有关。前面我们提到可以通过<code>suspendCoroutine()</code>将线程风格代码封装成协程风格的代码，而<code>runBlocking()</code>的作用就刚好反过来。这么一来，无论是线程的代码还是协程的代码，我们都能在它们之间来回交互了。</p><p>在后端开发中，还可以通过等号将<code>runBlocking()</code>与<code>main()</code>函数相连，以此为整个<code>main()</code>函数提供协程作用域：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;  <br>    launch &#123;   <br><span class="hljs-comment">// 可以直接启动协程  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外，<code>runBlocking()</code>还可以用来测试代码。总之，<code>runBlocking()</code>是一个特殊的启动协程的函数，但是其主要目的不在于启动协程，而是将协程风格的代码封装成阻塞式的，以便传统线程风格代码调用。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>正当防卫 3 - 测评</title>
    <link href="/post/Review-Just-Cause-3/"/>
    <url>/post/Review-Just-Cause-3/</url>
    
    <content type="html"><![CDATA[<p>历时 24 个小时，把《正当防卫 3》的主线推完了，也把空中和海上的 DLC 任务做完了，也把所有的地区都解放了，这么看来，整个游戏的流程也不算长。</p><span id="more"></span><p>这游戏是 2021 年 2 月 13 日买的，但是一直到现在才玩，很巧的是，二代是 2020 年 6 月份玩的，三代也是 6 月份玩的，可以说刚好隔了 4 年。</p><p>除了画面这种理所当然的进步以外，其它层面例如剧情、玩法都没有什么大的变化，剧情上也和前作没什么联系，所以就算没玩过前作，直接玩本作也不会说让人摸不着头脑。</p><p>正当防卫系列的主角都是里科（Rico）一个人，剧情上，里科在本作回到了自己的故乡梅迪西（Medici），并与自己的好兄弟等一众人一同推翻拉维罗（Ravello）将军的统治，解放故乡。仅此而已，跟前作一样，剧情上可以说是毫无深度，没有什么复杂的关系和背景，也没有什么尖锐的矛盾，这游戏的剧情就和它的玩法一样，简单粗暴，一句话就能概括。</p><p><img src="/../../images/ACGN/Just-Cause-3-1.jpg" alt="和兄弟一起解放家乡"></p><p>虽然玩法上没有太大变化，不过我在前作的评测中也没怎么提过玩法，这里还是简单说一下。在本作的地图中有十多个省份，每个省份中有一定数量的据点，这些据点可能是敌人的军事基地，也可能是由敌人统管的小镇等等，不同类型的据点只是需要破坏的建筑和设施的数量和种类不一样而已。所以无论是什么据点，你只需要进去，然后根据屏幕左边的提示，把里面需要破坏的东西例如水塔、广播、拉维罗将军的雕像等等统统 blow shit up 就行了。所以在游玩的过程中，新鲜感的来源之一就是你如何把这些东西炸毁，比如游戏本体可以允许你利用枪械和投掷物进行破坏，或者是用钩爪把油桶和需要破坏的设施连在一起，然后按下按键让油桶向设施靠拢，最后相撞产生爆炸。而 DLC 提供的内容就有意思多了：</p><ul><li>比如做完空中基地的任务后，我们的滑翔翼就有了喷射燃料的功能，这样我们就能持续滑翔了，同时滑翔翼还增加了机枪和导弹，这就让我们成为了人形自走战斗机。</li><li>我们在监狱解放了反叛军后还解锁了机甲，后续还能通过空投召唤机甲进行战斗。</li><li>在做完破坏黑手在海上控制天气的设施的任务后，我们还拿到一把叫「eDEN星火」的武器，这是我见过比较有创意的武器了：准星对准一个位置，长按鼠标左键使武器蓄力，蓄力完成后会从空中降下雷电对目标进行强力打击。</li></ul><p>此外，本作还增加了类似于 天赋&#x2F;技能树 的系统，怎么说呢，常规操作了，这游戏要是没有这系统才奇怪，毕竟这东西还是会增加一些玩家肝游戏的动力。</p><p>游戏全程就是 炸东西 → 做主线 → 炸东西 → 做主线。但是正当防卫系列的特色——钩爪，在本作还是有改进的。在前作的测评中我提到，前作里的移动基本上只能靠你那逼钩爪，并且距离十分有限。但是本作增加了在使用钩爪时可以打开降落伞和展开滑翔翼的功能，其中滑翔就可以让你以较快的速度进行移动了。我个人在前期一般在使用完钩爪后会先打开降落伞，因为这会使我的高度提升，然后我再开启滑翔翼进行滑翔。</p><p><img src="/images/ACGN/Just-Cause-3-2.jpg" alt="传统艺能-骑导弹"></p><hr><p>说完了剧情和改进的地方，接下来我就要开喷了，排名不分先后。</p><ol><li>首先，这个逼游戏还是没中文。</li><li>我估计用手柄玩这游戏的体验应该不是很好，前期我用手柄试玩了一下，发现这逼游戏没有给射击提供辅助瞄准的功能，射击的体验简直一坨。还有，游戏在用键鼠操作时，鼠标左键是射击，鼠标右键是钩爪，那我就很好奇，开镜瞄准应该怎么触发？噢，原来是要按下鼠标滚轮……而且开镜瞄准，或者叫精确瞄准，这个功能还要你到天赋树里把它点上它才能用，这是我见到的第一个要点技能才能精确瞄准的射击游戏。</li><li>当你按下 Esc 键打开菜单时，你可以再按一次 Esc 键将其关闭，但是当你进入子菜单或者说当你进入次级菜单的时候，你必须要通过按下 Ctrl 键来返回上一级，我都傻了。</li><li>车辆的的驾驶手感简直就是一坨。</li><li>物理引擎有些怪怪的，你说它真实吧，它在某些方面的细节也确实到位。比如直升机降落在草地的时候，附近的花和草都会因为降落带来的强力的风而摆动。但是有时候这个引擎又会让你觉得很抽象，比如当你从滑翔状态变成降落伞状态的时候，你滑翔时的那个速度似乎并没有继承到降落伞这里，并且当你收起降落伞的时候，引擎会让你的人物直接 90° 自由落体。</li><li>还有个问题就是战场上总是伴随着各种爆炸和枪声，人物之间的对话基本上听不清。</li><li>感觉游戏内还是比较缺乏指引性的提示，比如在破坏据点的时候，有时候就剩那一两个建筑或者设施，但是你总是找不到，这就会浪费一大堆时间。后来我才发现，这时候你打开地图，那些还没被破坏的设施会在地图上显示出来，但是你不跟我说我怎么知道？我光看着 HUD 上的小地图了，小地图上就没有菜单里的大地图这么详细啊。其实这也还好，因为最难受的是有时候你都不知道一个任务点该从哪里进入。</li><li>还有，我很不喜欢这种实时联网上传分数跟别人进行排名的功能。且不说有没有意义，在中国这种网络条件下，GFW 会教你做人，在没有加速器的情况下，玩这个游戏时不时就会弹个窗口出来跟你说连接服务器失败，体验真的很差。</li></ol><p>基本上就是这样了，我玩这游戏还是要开修改器，没那个耐心慢慢玩。但是你要说它很烂，当你回头看到游戏本体和好几个 DLC 加起来也才十几块钱的时候想想也就算了。最终评分 6&#x2F;10 。</p><p><img src="/images/ACGN/Just-Cause-3-3.jpg" alt="风景还行"></p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Compose 学习笔记 ④ - derivedStateOf</title>
    <link href="/post/Compose-Study-Guide-04/"/>
    <url>/post/Compose-Study-Guide-04/</url>
    
    <content type="html"><![CDATA[<p>本节主要讲一下<code>derivedStateOf()</code>这个函数是什么，怎么用。</p><span id="more"></span><p>简单概括一下<code>derivedStateOf()</code>的功能：状态对象 A 的更新被委托给了<code>derivedStateOf()</code>，<code>derivedStateOf()</code>又会去订阅另一个状态对象 B ，当 B 的状态变化后，<code>derivedStateOf()</code>会根据已给出的逻辑去更新 A 。接下来我们看一下官方文档中的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">TodoList</span><span class="hljs-params">(highPriorityKeywords: <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt; = listOf(<span class="hljs-string">&quot;Review&quot;</span>, <span class="hljs-string">&quot;Unblock&quot;</span>, <span class="hljs-string">&quot;Compose&quot;</span>)</span></span>) &#123;<br><br>    <span class="hljs-keyword">val</span> todoTasks = remember &#123; mutableStateListOf&lt;String&gt;() &#125;<br><br>    <span class="hljs-comment">// Calculate high priority tasks only when the todoTasks or highPriorityKeywords</span><br>    <span class="hljs-comment">// change, not on every recomposition</span><br>    <span class="hljs-keyword">val</span> highPriorityTasks <span class="hljs-keyword">by</span> remember(highPriorityKeywords) &#123;<br>        derivedStateOf &#123; todoTasks.filter &#123; it.containsWord(highPriorityKeywords) &#125; &#125;<br>    &#125;<br><br>    Box(Modifier.fillMaxSize()) &#123;<br>        LazyColumn &#123;<br>            items(highPriorityTasks) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>            items(todoTasks) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>        &#125;<br>        <span class="hljs-comment">/* Rest of the UI where users can add elements to the list */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>文档地址：<a href="https://developer.android.com/jetpack/compose/side-effects?hl=zh-cn#derivedstateof">https://developer.android.com/jetpack/compose/side-effects?hl=zh-cn#derivedstateof</a></p><p>首先代码的用意其实也就是根据函数参数中给到的字符串列表<code>highPriorityKeywords</code>去对列表<code>todoTasks</code>进行过滤，得到一个新列表<code>highPriorityTasks</code>，然后在一个纵向布局中先展示<code>highPriorityTasks</code>中的内容，后展示<code>todoTasks</code>的内容。其中重点在于<code>highPriorityKeywords</code>和<code>todoTasks</code>这两个列表：</p><ul><li><code>highPriorityKeywords</code>作为参数被传递进了<code>remember()</code>中，而<code>remember()</code>这个函数，我们前面提到过它大概是起到一个缓存的作用。在这个场景中，如果<code>remember()</code>的参数发生变化，Compose 在重组时就会重新执行<code>remember()</code>中的代码，然后将执行后得到的新结果进行缓存。</li><li><code>todoTasks</code>在<code>derivedStateOf()</code>中被<code>derivedStateOf()</code>订阅，当<code>todoTasks</code>内部发生变化时，<code>derivedStateOf()</code>会重新执行 Lambda 表达式中的代码，通过<code>filter()</code>计算出新的值（当然在别的场景中不一定是<code>filter()</code>）。</li></ul><p>无论是<code>remember()</code>被重新执行还是<code>derivedStateOf()</code>被重新执行，它们重新执行的部分都是一样的，也就是<code>todoTasks.filter &#123; it.containsWord(highPriorityKeywords) &#125;</code>这条语句，并且最终都会去更新变量<code>highPriorityTasks</code>的值。</p><p>官方所提供的这个例子可以说是<code>derivedStateOf()</code>使用场景的“最终形态”，因为官方将<code>derivedStateOf()</code>和带参数的<code>remember()</code>结合起来使用了。但是为了更好理解，我们需要先从几个简单的场景来渐进到官方的这个“最终形态”。</p><h2 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h2><p>前面提到<code>derivedStateOf()</code>的作用就是根据一个状态的变化计算出另一个状态，接下来就这个定义来编写一个最简单的用例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">setContent &#123;<br><span class="hljs-keyword">var</span> name <span class="hljs-keyword">by</span> remember &#123; mutableStateOf(<span class="hljs-string">&quot;Aiden&quot;</span>) &#125;<br><span class="hljs-keyword">val</span> upperCaseName <span class="hljs-keyword">by</span> remember &#123;<br>derivedStateOf &#123; name.uppercase() &#125;<br>&#125;<br>Column &#123;<br>Text(text = upperCaseName)<br>Button(onClick = &#123; name = <span class="hljs-string">&quot;Marcus&quot;</span> &#125;) &#123;<br>Text(text = <span class="hljs-string">&quot;修改名字&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序的功能很简单，用<code>derivedStateOf()</code>订阅一个字符串类型的 state object 的变化，将这个字符串转换成大写然后赋值给变量<code>upperCaseName</code>，最后再把<code>upperCaseName</code>显示出来。此外还有几个要点：</p><ol><li>变量<code>upperCaseName</code>被使用<code>by</code>关键字委托给了<code>derivedStateOf()</code>，尽管<code>derivedStateOf()</code>函数本身返回的是一个<code>State</code>对象，但是因为委托，变量<code>upperCaseName</code>在这里只会是<code>String</code>类型；</li><li>变量<code>upperCaseName</code>被<code>val</code>修饰，这是因为<code>derivedStateOf()</code>会帮我们去更新<code>upperCaseName</code>的值，我们并不需要也并不能去手动更新<code>upperCaseName</code>，如果手动更新，那就违背了使用<code>derivedStateOf()</code>的目的；</li><li><code>derivedStateOf()</code>返回的对象和<code>mutableStateOf()</code>返回的对象都是会被订阅状态变化的；</li></ol><p>程序运行，<code>derivedStateOf()</code>和<code>remember()</code>都会执行一次，前者是为了进行第一次的委托计算并赋值（也就是将变量<code>name</code>的字符串转换为大写），而后者是为了缓存这个结果。于是界面上会显示一行大写的文本“AIDEN”以及在它下方的一个按钮，当我点击按钮改变<code>name</code>的值后，由于<code>derivedStateOf()</code>内部使用（订阅）到了<code>name</code>，所以<code>derivedStateOf()</code>中的代码会再次执行，从而计算出新的值，也就是“MARCUS”，并将其赋值给<code>upperCaseName</code>，最后<code>Text()</code>这边也会进行重组，界面上最终显示着一行大写的文本“MARCUS”以及在它下方的一个按钮。</p><p>这个例子看起来还挺简单的，而且这个“根据变化重复执行代码”的特性好像在之前也遇到过……好像用带参数的<code>remember()</code>也可以实现上面代码相同的效果来着……我们来看一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">setContent &#123;<br><span class="hljs-keyword">var</span> name <span class="hljs-keyword">by</span> remember &#123; mutableStateOf(<span class="hljs-string">&quot;Aiden&quot;</span>) &#125;<br><span class="hljs-comment">//                     ↓ 使用带参数的 remember() 来更新</span><br><span class="hljs-keyword">val</span> upperCaseName = remember(name) &#123; name.uppercase() &#125;<br>Column &#123;<br>Text(text = upperCaseName)<br>Button(onClick = &#123; name = <span class="hljs-string">&quot;Marcus&quot;</span> &#125;) &#123;<br>Text(text = <span class="hljs-string">&quot;修改名字&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序运行，由于点击按钮改变了<code>name</code>的值，这就导致在重组时 Compose 发现传入<code>remember()</code>中的参数有变化，于是就刷新了缓存（也就是重复执行了<code>remember()</code>中的代码），<code>upperCaseName</code>的值得到更新，程序最终的运行效果和上面使用<code>derivedStateOf()</code>时是一样的……带参数的<code>remember()</code>和<code>derivedStateOf()</code>运行的效果竟然是一样的……这就不禁让人开始思考这两者的区别在哪里……</p><h2 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h2><p>在上面的场景中可以看到带参数的<code>remember()</code>和<code>derivedStateOf()</code>都可以根据变化在重组时重新执行代码，这是它们相同的地方，而不同的地方就在于它们判断变化的依据：</p><ul><li><code>remember()</code>在重组时是否会重新执行代码，是依据于它的参数本身有没有发生变化，比如从一个<code>String</code>变成另一个<code>String</code>，这种对象的变化往往伴随着赋值操作。也就是说，当参数是集合类型时，就属于特殊情况了，因为集合内部发生的变化（例如增加元素或者移除元素）是不会引起<code>remember()</code>的注意的，从而也就不会刷新缓存；</li><li><code>derivedStateOf()</code>是否会重新执行代码，是依据于它所订阅的 state object 的变化，比如说当订阅的是<code>mutableStateOf()</code>创建的 state object 时，一旦这个 state object 发生了赋值操作，那就会引起<code>derivedStateOf()</code>内部代码的再执行。包括<code>mutableStateListOf()</code>创建的集合对象也是一样，当集合内发生变动时，就会触发<code>derivedStateOf()</code>内部代码的再执行；</li></ul><p>接下来根据上面的结论再来看个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">setContent &#123;<br><span class="hljs-keyword">val</span> names = remember &#123; mutableStateListOf(<span class="hljs-string">&quot;Aiden&quot;</span>, <span class="hljs-string">&quot;Marcus&quot;</span>) &#125;<br><span class="hljs-keyword">val</span> upperCaseNames <span class="hljs-keyword">by</span> remember &#123;<br>derivedStateOf &#123; names.map &#123; it.uppercase() &#125; &#125;<br>&#125;<br>Column &#123;<br><span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> upperCaseNames) &#123;<br>Text(text = name)<br>&#125;<br>Button(onClick = &#123; names.add(<span class="hljs-string">&quot;Wrench&quot;</span>) &#125;) &#123;<br>Text(text = <span class="hljs-string">&quot;添加名字&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一次使用了<code>mutableStateListOf()</code>创建了一个可被订阅内部状态变化的列表<code>names</code>，接着同样使用<code>derivedStateOf()</code>对<code>names</code>进行订阅，当<code>names</code>的内部发生变化时，<code>derivedStateOf()</code>内的代码就会被再次执行，从而计算出新的值并赋给变量<code>upperCaseNames</code>。</p><p>程序的功能就是把列表中的名字全部变成大写然后展示出来。程序跑起来以后，会先显示两行大写的名字，分别是<code>AIDEN</code>和<code>MARCUS</code>，当我点击按钮后，列表中就会添加一个新的名字，列表这个变化会引起<code>derivedStateOf()</code>内代码的再次执行，原本只显示两行大写名字的界面在点击按钮后显示了第三行大写名字，运行效果很理想。</p><p>接着再来看看如果将<code>names</code>作为参数传递进<code>remember()</code>以后会怎么样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">setContent &#123;<br><span class="hljs-keyword">val</span> names = remember &#123; mutableStateListOf(<span class="hljs-string">&quot;Aiden&quot;</span>, <span class="hljs-string">&quot;Marcus&quot;</span>) &#125;<br><span class="hljs-comment">//                     ↓ 使用带参数的 remember() 来更新</span><br><span class="hljs-keyword">val</span> upperCaseNames = remember(names) &#123;<br>names.map &#123; it.uppercase() &#125;<br>&#125;<br>Column &#123;<br><span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> upperCaseNames) &#123;<br>Text(text = name)<br>&#125;<br>Button(onClick = &#123; names.add(<span class="hljs-string">&quot;Wrench&quot;</span>) &#125;) &#123;<br>Text(text = <span class="hljs-string">&quot;添加名字&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序运行，点击按钮，界面是没反应的。原因其实就是尽管列表<code>names</code>中添加了新的元素，但是<code>remember()</code>并不关心这样的变化，除非<code>names</code>被用等号<code>=</code>赋值成了另一个列表。</p><p>到此为止，我们似乎就对什么时候该使用<code>derivedStateOf()</code>和什么时候该使用带参数的<code>remember()</code>有一个初步的概念了，那就是“当涉及到集合内部变化时，我们使用<code>derivedStateOf()</code>，当涉及到赋值操作时，我们就使用带参数的<code>remember()</code>”，对吧？对，但是还不够。</p><h2 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h2><p>把话挑明了说，<code>remember()</code>和<code>derivedStateOf()</code>的本质从头到尾都没变过，<code>remember()</code>的作用其实就是我们前面说到的“缓存”，它的参数只是作为一个“是否要刷新缓存”的依据；而<code>derivedStateOf()</code>的作用就是监听其订阅对象的状态变化，当变化发生时，重新执行代码，执行的结果是根据其订阅对象的变化而变化的。<code>remember()</code>加<code>derivedStateOf()</code>这个组合其实与<code>remember()</code>加<code>mutableStateOf()</code>这个组合类似，<code>remember()</code>和它们都在各司其职。</p><p>最后来看一个类似于官方例子的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">UpperCaseNames</span><span class="hljs-params">(names: <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt;, onAddElement: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    <span class="hljs-comment">//                             ↓ 我该添加参数吗？</span><br>    <span class="hljs-keyword">val</span> upperCaseNames <span class="hljs-keyword">by</span> remember( ) &#123;<br>        <span class="hljs-comment">// ↓ 我该使用 derivedStateOf 吗？</span><br>        derivedStateOf &#123; names.map &#123; it.uppercase() &#125; &#125;<br>    &#125;<br>    Column &#123;<br>        <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> upperCaseNames) &#123;<br>            Text(text = name)<br>        &#125;<br>        Button(onClick = &#123; onAddElement.invoke() &#125;) &#123;<br>            Text(text = <span class="hljs-string">&quot;增加元素&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先可以看到上面的例子是一个自定义的 Composable 函数，这意味着这个例子具有一定的通用性，包括官方给的例子也是一个自定义的 Composable ，因为在实际开发中我们不可能像前面的例子那样把代码都写在<code>setContent()</code>里。</p><p>接着再来看看这个函数的功能，我的想法很简单，就是在调用这个 Composable 的时候传入一个储存着名字的列表，函数把列表里的名字全部变成大写再展示出来，并且当我点击按钮以后，我希望往列表里添加一个名字，最后函数要把更新后的列表里的名字全部变成大写再展示出来。那么现在问题就来了，对于这个需求，我是应该使用带参数的<code>remember()</code>还是应该使用<code>derivedStateOf()</code>？还是说两个都用？</p><p>首先我在点击按钮往列表里增加新的名字的时候，我需要这个变化能被感知到，也就是要能触发重组刷新界面，所以这个列表应该是一个由<code>mutableStateListOf()</code>创建的可被订阅内部变化的列表才行。接着我把这个列表作为参数传递进<code>UpperCaseNames()</code>中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">setContent &#123;<br><span class="hljs-comment">//                            ↓ 可被订阅内部变化的列表</span><br><span class="hljs-keyword">val</span> names = remember &#123; mutableStateListOf(<span class="hljs-string">&quot;Aiden&quot;</span>, <span class="hljs-string">&quot;Marcus&quot;</span>) &#125;<br><span class="hljs-comment">//                       ↓ 传递参数</span><br>UpperCaseNames(names = names) &#123;<br>names.add(<span class="hljs-string">&quot;Wrench&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然我传递的是一个可以被订阅的列表，那我直接用<code>derivedStateOf()</code>订阅它不就好了吗？我试试只用<code>derivedStateOf()</code>而不用带参数的<code>remember()</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">UpperCaseNames</span><span class="hljs-params">(names: <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt;, onAddElement: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> upperCaseNames <span class="hljs-keyword">by</span> remember &#123;<br><span class="hljs-comment">//                 ↓ 订阅列表的内部变化</span><br>        derivedStateOf &#123; names.map &#123; it.uppercase() &#125; &#125;<br>    &#125;<br>    Column &#123;<br>        <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> upperCaseNames) &#123;<br>            Text(text = name)<br>        &#125;<br>        Button(onClick = &#123; onAddElement.invoke() &#125;) &#123;<br>            Text(text = <span class="hljs-string">&quot;增加元素&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行程序，当我点击按钮后，列表<code>names</code>增加了一个新名字，<code>names</code>的内部变化让<code>derivedStateOf()</code>重新执行了 Lambda 中的代码，从而计算出了新的列表，最后再刷新界面把新的名字的大写形态展示出来，整体效果理想。这样看来，我似乎真的就不需要带参数的<code>remember()</code>了……</p><p>那倒还真不是，我们再来看一个场景：我现在有两个名字列表和一个代表年龄的变量，我现在不想往列表里增加新的名字了，我也不 care 名字是不是大写了，我现在的新需求就是要根据年龄显示不同的名字列表，当年龄大于或等于 18 岁时，我显示一个列表，否则我显示另一个。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">setContent &#123;<br>Column &#123;<br><span class="hljs-keyword">var</span> age <span class="hljs-keyword">by</span> remember &#123; mutableIntStateOf(<span class="hljs-number">17</span>) &#125;<br><span class="hljs-keyword">val</span> names = remember(age) &#123;<br><span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">18</span>) mutableStateListOf(<span class="hljs-string">&quot;Aiden&quot;</span>, <span class="hljs-string">&quot;Marcus&quot;</span>)<br><span class="hljs-keyword">else</span> mutableStateListOf(<span class="hljs-string">&quot;想不出别的英文呢名了&quot;</span>, <span class="hljs-string">&quot;随便写两个字符串&quot;</span>)<br>&#125;<br>UpperCaseNames(names = names) &#123; names.add(<span class="hljs-string">&quot;Wrench&quot;</span>) &#125;<br>Button(onClick = &#123; age = <span class="hljs-number">18</span> &#125;) &#123;<br>Text(text = <span class="hljs-string">&quot;成年了&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>UpperCaseNames()</code>函数的代码暂时不动。程序运行，因为<code>age</code>初始化为<code>17</code>，所以先展示<code>&quot;想不出别的英文呢名了&quot;, &quot;随便写两个字符串&quot;</code>这个列表，当我点击按钮后，<code>age</code>被改为<code>18</code>，触发重组，又因为<code>age</code>是<code>remember()</code>的参数，所以<code>remember()</code>中的代码也会重新执行，所以不用担心<code>names</code>不更新。程序继续往下跑，<code>names</code>被更新为<code>&quot;Aiden&quot;, &quot;Marcus&quot;</code>这个列表以后被作为参数传递进<code>UpperCaseNames()</code>函数中，照理说<code>UpperCaseNames()</code>接下来应该会根据新的参数来显示新的列表，但实际上界面并没有变化。</p><p>我们回看<code>UpperCaseNames()</code>函数其实也很容易发现问题，问题就在于<code>remember()</code>没参数。尽管重组带着新的名字列表进入了<code>UpperCaseNames()</code>函数内部，但是因为<code>remember()</code>没参数导致缓存没刷新，<code>upperCaseNames</code>这个变量所持有的列表仍然是之前缓存过的<code>&quot;想不出别的英文呢名了&quot;, &quot;随便写两个字符串&quot;</code>这个列表，这也就是界面显示没变化的原因了。</p><p>解决方案也很简单，为<code>remember()</code>添加参数即可，并且这个参数就是<code>UpperCaseNames()</code>函数的参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">UpperCaseNames</span><span class="hljs-params">(names: <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt;, onAddElement: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    <span class="hljs-comment">//                               ↓ 添加参数</span><br>    <span class="hljs-keyword">val</span> upperCaseNames <span class="hljs-keyword">by</span> remember(names) &#123;<br>        derivedStateOf &#123; names.map &#123; it.uppercase() &#125; &#125;<br>    &#125;<br>    Column &#123;<br>        <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> upperCaseNames) &#123;<br>            Text(text = name)<br>        &#125;<br>        Button(onClick = &#123; onAddElement.invoke() &#125;) &#123;<br>            Text(text = <span class="hljs-string">&quot;增加元素&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，当列表内部元素发生变动的时候，就由<code>derivedStateOf()</code>来负责重新执行代码，而当列表本身变成另一个对象的时候，就由<code>remember()</code>来负责重新执行代码。这也符合了我前面说到的两者各司其职并不冲突。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说了那么多只是为了搞清楚<code>remember()</code>和<code>derivedStateOf()</code>的本质而已，前者首先是起到一个缓存作用，其次是根据参数是否变化决定是否要刷新缓存；后者则是用于监听状态变化从而重新执行代码的。剩下的就是要结合实际场景来决定使用哪一个以及是否需要搭配使用了。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Compose 学习笔记 ③ - 性能优化</title>
    <link href="/post/Compose-Study-Guide-03/"/>
    <url>/post/Compose-Study-Guide-03/</url>
    
    <content type="html"><![CDATA[<p>本节接着说一下 Compose 为了「自动更新」这个特性所带来的性能缺陷而做了哪些优化。</p><span id="more"></span><p>除了我们之前提到的使用<code>remember()</code>来进行缓存，在保证正确性同时提高性能以外，Compose 的另一项优化措施就是在重组过程中会自动判断某些 Composable 是否需要被再次执行，不过这也分几个场景，我们一个一个来看。</p><h2 id="不跳过"><a href="#不跳过" class="headerlink" title="不跳过"></a>不跳过</h2><p>首先是 Compose 对于那些不会跳过的代码的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> name <span class="hljs-keyword">by</span> mutableStateOf(<span class="hljs-string">&quot;Aiden&quot;</span>)<br>setContent &#123;<br>Log.d(<span class="hljs-string">&quot;ScopeTest&quot;</span>, <span class="hljs-string">&quot;在 Column 的上面&quot;</span>)<br>Column &#123;<br>Text(text = name)<br>Log.d(<span class="hljs-string">&quot;ScopeTest&quot;</span>, <span class="hljs-string">&quot;在 Column 的里面&quot;</span>)<br>Button(onClick = &#123; name = <span class="hljs-string">&quot;Marcus&quot;</span> &#125;) &#123;<br>Text(text = <span class="hljs-string">&quot;改变名称&quot;</span>)<br>&#125;<br>&#125;<br>Log.d(<span class="hljs-string">&quot;ScopeTest&quot;</span>, <span class="hljs-string">&quot;在 Column 的下面&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码就是在程序运行后先打印 3 条 Log ，然后在点击按钮更改变量<code>name</code>的值后触发重组，让<code>Column()</code>内部的代码再次被执行，从而让界面显示新的内容，同时我非常肯定是<code>Column()</code>内部发生了重组。然而实际上当我按下按钮以后，被再次执行的不止有<code>Column()</code>内部的代码，和<code>Column()</code>处于同一层级的上下两条打印 Log 的语句也被再次执行了……</p><p>这实际上是因为：</p><ol><li><code>Column()</code>是个内联函数，在编译时其所在位置的代码被其函数内的代码替换了；</li><li><code>Column()</code>函数内的核心代码其实就是调用了它的函数类型的参数<code>content</code>而已；</li></ol><p>所以上面的<code>Column()</code>在编译时大概会变成这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> name <span class="hljs-keyword">by</span> mutableStateOf(<span class="hljs-string">&quot;Aiden&quot;</span>)<br>setContent &#123;<br>Log.d(<span class="hljs-string">&quot;ScopeTest&quot;</span>, <span class="hljs-string">&quot;在 Column 的上面&quot;</span>)<br>Text(text = name)<br>Log.d(<span class="hljs-string">&quot;ScopeTest&quot;</span>, <span class="hljs-string">&quot;在 Column 的里面&quot;</span>)<br>Button(onClick = &#123; name = <span class="hljs-string">&quot;Marcus&quot;</span> &#125;) &#123;<br>Text(text = <span class="hljs-string">&quot;改变名称&quot;</span>)<br>&#125;<br>Log.d(<span class="hljs-string">&quot;ScopeTest&quot;</span>, <span class="hljs-string">&quot;在 Column 的下面&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>所以实际上是因为上下这两条打印 Log 的语句和<code>Column()</code>是位于同一层级的，所以它们也被<code>Column()</code>的重组波及到了。更糟糕的是，如果被波及的只是打印日志的代码那倒也还好，但是如果是一些很消耗性能的操作，那就会造成不必要的资源开销。</p><h2 id="无参数跳过"><a href="#无参数跳过" class="headerlink" title="无参数跳过"></a>无参数跳过</h2><p>比如对于重复执行一个自定义 Composable 函数来说，它的性能开销肯定是比重复执行一条打印日志的语句要大的，那么 Compose 对于 Composable 的跳过机制又是怎样的呢。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">HeavyFun</span><span class="hljs-params">()</span></span> &#123;<br>    Log.d(<span class="hljs-string">&quot;优化测试&quot;</span>, <span class="hljs-string">&quot;位于 HeavyFun() 内部&quot;</span>)<br>    Text(text = <span class="hljs-string">&quot;假设在这里进行了网络请求……&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>首先自定义一个 Composable 用于模拟消耗资源的操作，其中会打印一条 Log 。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> name <span class="hljs-keyword">by</span> mutableStateOf(<span class="hljs-string">&quot;Aiden&quot;</span>)<br>setContent &#123;<br>Column &#123;<br>Text(text = name)<br>HeavyFun()<br>Button(onClick = &#123; name = <span class="hljs-string">&quot;Marcus&quot;</span> &#125;) &#123;<br>Text(text = <span class="hljs-string">&quot;改变名称&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>随后在<code>Column()</code>中调用上面那个 Composable ，当程序运行，按下按钮后，由<code>Text()</code>引起的重组会波及到<code>HeavyFun()</code>，其内部的代码应该会被再次执行。</p><p>然而在实际运行时，<code>HeavyFun()</code>这个 Composable 中的代码并没有因为重组而被再次执行……这其实是因为 Compose 的插件检测到<code>HeavyFun()</code>并没有发生变化，所以在执行到它时跳过了它内部的代码，这就是 Compose 的性能优化措施之一。</p><h2 id="一般数据类型参数跳过"><a href="#一般数据类型参数跳过" class="headerlink" title="一般数据类型参数跳过"></a>一般数据类型参数跳过</h2><p>接下来如果为自定义 Composable 添加参数呢，比如这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">HeavyFun</span><span class="hljs-params">(age: <span class="hljs-type">Int</span>)</span></span> &#123;<br>    Log.d(<span class="hljs-string">&quot;优化测试&quot;</span>, <span class="hljs-string">&quot;位于 HeavyFun() 内部&quot;</span>)<br>    Text(text = <span class="hljs-string">&quot;年龄：<span class="hljs-variable">$age</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>并且在调用它时传递一个参数进去，同时在按钮的点击事件当中修改变量<code>age</code>的值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> name <span class="hljs-keyword">by</span> mutableStateOf(<span class="hljs-string">&quot;Aiden&quot;</span>)<br><span class="hljs-keyword">var</span> age = <span class="hljs-number">23</span><br>setContent &#123;<br>Column &#123;<br>Text(text = name)<br>HeavyFun(age)<br>Button(onClick = &#123;<br>age = <span class="hljs-number">24</span><br>name = <span class="hljs-string">&quot;Marcus&quot;</span><br>&#125;) &#123;<br>Text(text = <span class="hljs-string">&quot;改变名称&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次运行程序，点击按钮触发重组后，Compose 发现传入<code>HeavyFun()</code>中的参数有变化，于是<code>HeavyFun()</code>中的代码就会被再次执行了。</p><p>这里有两点值得一提：</p><ol><li>在上面的例子中，往<code>HeavyFun()</code>内传入的是一个普通的<code>Int</code>类型的对象，所以如果只有这个对象发生变化的话是不会触发重组的。当然如果想要往<code>HeavyFun()</code>内传入<code>MutableState</code>对象也可以，比如把传入<code>Text()</code>的变量<code>name</code>也传进<code>HeavyFun()</code>中，在这种情况下，当变量<code>name</code>发生变化时，<code>HeavyFun()</code>和<code>Text()</code>都会被标记为失效，也就是说，标记失效这个动作执行了两次，但是重组这个行为只会执行一次，这也是 Compose 的性能优化措施之一；</li><li>尽管<code>HeavyFun()</code>有一个参数，但是如果<code>HeavyFun()</code>内部没有用到这个参数，那么不管在调用<code>HeavyFun()</code>时如何传递这个参数，重组时<code>HeavyFun()</code>中的代码仍然会被跳过……由此看出来 Compose 真的很聪明。</li></ol><p>总的来说，Compose 在重组时是否会重复执行某个 Composable 中内部的代码，取决于这个 Composable 函数是不是有基本数据类型的参数，如果没有，那就会直接跳过，如果有并且参数有变，那就重复执行，否则同样跳过。</p><h2 id="类对象参数跳过"><a href="#类对象参数跳过" class="headerlink" title="类对象参数跳过"></a>类对象参数跳过</h2><p>但是如果 Composable 函数中的参数是非基本数据类型的话，比如说是我们自定义的一个<code>User</code>类的话，那这里就要分两种情况了，同时每种情况下又会再分两种情况，也就是说总共有四种情况。</p><p><strong>情况一</strong> ，<code>User</code>类是普通类（由<code>class</code>声明），属性由<code>val</code>修饰：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-keyword">val</span> name: String)<br><br><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">Greeting</span><span class="hljs-params">(user: <span class="hljs-type">User</span>)</span></span> &#123;<br>    Log.d(<span class="hljs-string">&quot;优化测试&quot;</span>, <span class="hljs-string">&quot;位于 Greeting() 内部&quot;</span>)<br>    Text(text = <span class="hljs-string">&quot;Hello <span class="hljs-subst">$&#123;user.name&#125;</span>!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> str <span class="hljs-keyword">by</span> mutableStateOf(<span class="hljs-string">&quot;点击按钮前&quot;</span>)<br><span class="hljs-keyword">var</span> user = User(<span class="hljs-string">&quot;Aiden&quot;</span>)<br>setContent &#123;<br>Column &#123;<br>Text(text = str)<br>Greeting(user = user)<br>Button(onClick = &#123;<br>user = User(<span class="hljs-string">&quot;Aiden&quot;</span>)<br>str = <span class="hljs-string">&quot;点击按钮后&quot;</span><br>&#125;) &#123;<br>Text(text = <span class="hljs-string">&quot;改变 str 的值&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这种情况下，Compose 在重组时对新旧<code>User</code>类对象进行比较时所使用的<code>equals()</code>是父类的<code>equals()</code>，也就是用来比较引用性相等的<code>equals()</code>，相当于 Kotlin 中的三等号<code>===</code>。又因为我们在按钮的点击监听中创建了一个新的<code>User</code>类对象并将其赋值给了<code>user</code>变量，导致在重组时，Compose 发现传入<code>Greeting()</code>内的<code>User</code>类对象变成了另外一个，所以<code>Greeting()</code>内的代码就被重复执行了。这也就是运行程序后点击按钮触发重组，<code>Greeting()</code>内的日志被打印了的原因。</p><p><strong>情况二</strong> ，<code>User</code>类是普通类（由<code>class</code>声明），属性由<code>var</code>修饰：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//          ↓ 改用 var 修饰属性</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-keyword">var</span> name: String)<br><br><span class="hljs-comment">// Greeting() 没有变化，省略不写</span><br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> str <span class="hljs-keyword">by</span> mutableStateOf(<span class="hljs-string">&quot;点击按钮前&quot;</span>)<br> ↓ 这里改用 <span class="hljs-keyword">val</span> 对 user 变量进行修饰<br><span class="hljs-keyword">val</span> user = User(<span class="hljs-string">&quot;Aiden&quot;</span>)<br>setContent &#123;<br>Column &#123;<br>Text(text = str)<br>Greeting(user = user)<br><span class="hljs-comment">// 按钮的点击监听中取消赋值的操作</span><br>Button(onClick = &#123; str = <span class="hljs-string">&quot;点击按钮后&quot;</span> &#125;) &#123;<br>Text(text = <span class="hljs-string">&quot;改变 str 的值&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这种情况下，Compose 发现<code>User</code>类的属性被<code>var</code>修饰，于是 Compose 决定只要发生重组，它就会无脑重复执行<code>Greeting()</code>内的代码。另外，在上面的代码中，我使用了<code>val</code>来修饰变量<code>user</code>，同时取消了按钮的点击监听中的赋值操作，我做这些只是想表达参数的变化已经不能影响 Compose 重复执行代码了，因为你在不改变参数的情况下，代码都会被重复执行，更何况你改了参数。</p><p><strong>情况三</strong> ，<code>User</code>类是数据类（由<code>data class</code>声明），属性由<code>val</code>修饰：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// ↓ 数据类      ↓ val 修饰属性</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-keyword">val</span> name: String)<br><br><span class="hljs-comment">// Greeting() 没有变化，省略不写</span><br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 主要部分的代码与情况一相同，省略不写</span><br></code></pre></td></tr></table></figure><p>在这种情况下，Compose 在重组时对新旧<code>User</code>类对象进行比较时所使用的<code>equals()</code>是数据类重写过的<code>equals()</code>，也就是用来比较结构性相等的<code>equals()</code>，相当于 Kotlin 中的双等号<code>==</code>。所以尽管我们在按钮的点击监听中创建了一个新的<code>User</code>类对象并将其赋值给了<code>user</code>变量，但是在重组时，Compose 经过比较发现新旧两个<code>User</code>类对象的属性是相等的，所以跳过了<code>Greeting()</code>内的代码，<code>Greeting()</code>内的日志就没有被打印。</p><p><strong>情况四</strong> ，<code>User</code>类是数据类（由<code>data class</code>声明），属性由<code>var</code>修饰：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//               ↓ 改用 var 修饰属性</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-keyword">var</span> name: String)<br><br><span class="hljs-comment">// Greeting() 没有变化，省略不写</span><br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 主要部分的代码与情况二相同，省略不写</span><br></code></pre></td></tr></table></figure><p><strong>情况四</strong> 和 <strong>情况二</strong> 类似，尽管判断参数变化的条件由引用性相等变为结构性相等，但是由于类的属性被<code>var</code>修饰，所以 Compose 会无脑重复执行<code>Greeting()</code>内的代码。</p><p>综合上述四种情况能得到一个比较可靠的结论就是，当一个类的属性被<code>var</code>修饰时，这个属性就有可能在程序中的任何位置被修改，这样的类是不被信任的。对此，Compose 为了保证准确性，选择了最保险的方法，也就是无脑重复执行 Composable 中的代码。</p><p>无脑重复执行的做法最大程度上保证了程序正确，但是资源的消耗也变得不可避免了，为此，Compose 提供了一个用于修饰类或者接口的注解<code>@Stable</code>。比如在上面的例子中，我们用<code>@Stable</code>注解修饰<code>User</code>类，这样一来，无论<code>User</code>类是普通类还是数据类，就算它的属性是被<code>var</code>修饰的，只要<code>equals()</code>返回<code>true</code>，Compose 就会跳过<code>Greeting()</code>。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Compose 学习笔记 ②</title>
    <link href="/post/Compose-Study-Guide-02/"/>
    <url>/post/Compose-Study-Guide-02/</url>
    
    <content type="html"><![CDATA[<p>这一节进一步讲一些 Compose 的概念，包括 Composable 、界面自动更新、架构原则、可被订阅内部变化的集合、CompositionLocal 等。</p><span id="more"></span><h2 id="Composable"><a href="#Composable" class="headerlink" title="Composable"></a>Composable</h2><p>首先是一些有关 Composable 的基础信息：</p><ul><li>Composable 有点像传统 XML 布局写法中的 View ，例如 Compose 中的文本控件<code>Text()</code>和按钮控件<code>Button()</code>就是一个 Composable 。</li><li>从写法上来看，Composable 就是一个被<code>@Composable</code>注解修饰的函数。</li><li>View 可以自定义，Composable 也可以自定义（但是两者不一样），具体做法就是编写一个函数，然后给它添加上<code>@Composable</code>注解即可。</li><li>被<code>@Composable</code>注解修饰的函数在编译时，Compose 的编译器插件（Compiler Plugin）会在幕后进行一些操作，例如为这些函数添加额外的参数（比如会添加一个<code>Composer</code>类型的参数）。</li><li>Compose 的编译器插件（Compiler Plugin）在这里体现了 AOP（面向切面编程）的理念，并且以“插件”的形式来实现 AOP ，不仅做的事情更多，也可以更好地支持跨平台。</li><li>Composable 官方翻译为“可组合项”，并且 Composable 只能在 Composable 中被调用。</li></ul><h3 id="setContent"><a href="#setContent" class="headerlink" title="setContent()"></a>setContent()</h3><p>首先要提到的就是<code>setContent()</code>，<code>setContent()</code>就像是 Compose 代码的入口，我们平时就在它的 Lambda（大括号）内通过调用 Composable 来设计界面。值得注意的是：<code>setContent()</code>这个函数并没有被<code>@Composable</code>注解修饰，这并不符合前面提到的“Composable 只能在 Composable 中被调用”的规则……在这里不妨先来看一下<code>setContent()</code>的函数签名：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> ComponentActivity.<span class="hljs-title">setContent</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    parent: <span class="hljs-type">CompositionContext</span>? = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    content: @<span class="hljs-type">Composable</span> () -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><p>可以看到，<code>setContent()</code>是一个高阶函数，在<code>MainActivity</code>中，<code>setContent()</code>的 Lambda 内的代码都被打包成了一个函数类型的参数，也就是这些代码实际上是被“传递”而不是被“调用”的，所以<code>setContent()</code>本身并不需要被<code>@Composable</code>注解修饰。但是问题就来了，Compose 要求我们在 Composable 中调用 Composable ，但是<code>setContent()</code>又不是 Composable ，既然如此，最初的那个 Composable 是在哪里被调用的呢？</p><p><code>setContent()</code>不是那个最初调用 Composable 的，真正作为一般函数和 Composable 函数之间的桥梁的是<code>internal fun invokeComposable(composer: Composer, composable: @Composable () -&gt; Unit)</code>，它成为了调用 Composable 的特例。在这个函数中，<code>composable</code>这个函数类型的参数被强转成了一般函数并在最后被调用了，而一旦有一个 Composable 被调用了，那么接下来就在这个 Composable 中调用其它的 Composable 就行了。</p><h3 id="自定义-Composable"><a href="#自定义-Composable" class="headerlink" title="自定义 Composable"></a>自定义 Composable</h3><p>自定义 Composable 是什么？它做到了什么传统 View 写法做不到的事情吗？</p><p>前面提到 View 可以自定义，Composable 也可以自定义，但是两者不一样，至于为什么，且看下面这个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">Foo</span><span class="hljs-params">()</span></span> &#123;<br>    Column &#123;<br>        Text(text = <span class="hljs-string">&quot;Name: Aiden&quot;</span>)<br>        Button(onClick = &#123; <span class="hljs-comment">/*TODO*/</span> &#125;) &#123;<br>            Text(text = <span class="hljs-string">&quot;Click&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是我自定义的一个 Composable ，主要有 3 部分：</p><ol><li>调用<code>Column()</code>创建一个纵向布局；</li><li>在<code>Column()</code>内调用<code>Text()</code>创建一个文本控件显示一串文本；</li><li>在<code>Text()</code>下方调用<code>Button()</code>创建一个按钮，按钮上显示“Click”；</li></ol><p>这是个很简单的自定义 Composable ，我只要在需要的地方调用<code>Foo()</code>就可以重用这个界面。但是同样的需求，如果是在传统的 View 系统中我要怎么实现呢？我并不会去使用自定义 View ，因为它太复杂了，有点牛刀杀鸡的感觉。相对的，我只需要写一个 XML 布局文件就可以了，因为这只是涉及到简单的显示而已，这就是自定义 View 和自定义 Composable 之间不能直接划等号的原因。</p><p>那自定义 Composable 可以和 XML 文件划等号吗？再看下面这个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">Greeting</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, modifier: <span class="hljs-type">Modifier</span> = Modifier)</span></span> &#123;<br>    Text(<br>        text = <span class="hljs-string">&quot;Hello <span class="hljs-variable">$name</span>!&quot;</span>,<br>        modifier = modifier<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>这是新版 Android Studio 创建的 Compose 项目中的示例代码，可以看到相比我上面那个自定义 Composable 来说，<code>Greeting()</code>多了两个函数参数，这就意味着你在调用<code>Greeting()</code>的时候需要向其中传入参数，并且<code>Greeting()</code>还会根据传入的参数来显示不同的内容。这种动态显示内容甚至可以根据业务逻辑来显示内容的功能是 XML 写法所不具备的，XML 就是单纯的标记语言，是写死的，这也是前面说到为什么“涉及到简单的显示”的时候会使用 XML 。所以如果我想要在 View 系统中具备这种“动态显示”的能力，我就只能回到自定义 View 上了。</p><p>总结来说：</p><ul><li>在传统 View 系统中并没有一个能和自定义 Composable 完全等价的存在；</li><li>在显示简单内容时，自定义 Composable 比自定义 View 要方便多了；</li><li>在显示复杂内容时，自定义 Composable 可以做到 XML 做不到的事情；</li></ul><p>自定义 Composable &#x3D;&#x3D; 自定义 View + XML 。</p><h2 id="MutableState"><a href="#MutableState" class="headerlink" title="MutableState"></a>MutableState</h2><p>之前说过 Compose 的写法属于声明式，特点在于 UI 会自动更新，接下来就大致说说这个自动更新是什么情况。</p><h3 id="被订阅的对象"><a href="#被订阅的对象" class="headerlink" title="被订阅的对象"></a>被订阅的对象</h3><p>首先是一个很简单的例子，有一个文本控件<code>Text()</code>，当向其中传入的文本发生变化时，界面就会自动更新，随后显示新的内容：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Aiden&quot;</span><br>setContent &#123;<br>Text(text = name)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码在逻辑上看起来好像没问题，定义一个变量<code>name</code>并将其作为参数传递到文本控件<code>Text()</code>中，之后我只需要更改变量<code>name</code>的值，文本控件应该就会自动更新显示相应的新内容……然而实际并不是这样。</p><p>这是因为我们一直以来写代码时用到的这些类型（无论是<code>String</code>、<code>Int</code>等等）是没办法直接和 Compose 进行合作的。简单来说，<code>name</code>确实作为参数传递给<code>Text()</code>了，后期你也确实修改<code>name</code>的值了，但是<code>Text()</code>并不知道它发生了改变，不仅是<code>Text()</code>，所有的 Composable 都不知道，也就没办法刷新界面了。</p><p>这里就需要引入<code>MutableState</code>这个对象，它可以被 Compose 监听，当它的值发生变化时，界面会去进行响应：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> name = mutableStateOf(<span class="hljs-string">&quot;Aiden&quot;</span>)<br>setContent &#123;<br>Text(text = name.value)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中使用了<code>mutableStateOf()</code>创建了一个<code>MutableState</code>的对象，这个对象当中包裹着一个<code>String</code>类型的值，当这个的值发生变化时，<code>MutableState</code>让它的变化可以被调用它的地方感知到，从而去更新界面——也就是上面例子中的<code>Text()</code>。此外就是向<code>Text()</code>中传入的参数不再是<code>name</code>而是<code>name.value</code>了，这是因为变量<code>name</code>已经不再是<code>String</code>类型了。</p><h3 id="初探自动更新"><a href="#初探自动更新" class="headerlink" title="初探自动更新"></a>初探自动更新</h3><p>现在我们知道了当我们需要读取或是修改一个<code>MutableState</code>对象的值的时候，实际上是要调用它的<code>value</code>属性，同时我们也知道，读写一般会涉及到 getter 和 setter 方法，接下来我们就通过<code>value</code>属性的 getter 和 setter 方法来简单看一下界面是怎么知道该什么时候更新的。</p><p>首先是要定位到 getter 和 setter 方法的位置，先看<code>mutableStateOf()</code>这个函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@StateFactoryMarker</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">mutableStateOf</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    value: <span class="hljs-type">T</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    policy: <span class="hljs-type">SnapshotMutationPolicy</span>&lt;<span class="hljs-type">T</span>&gt; = structuralEqualityPolicy()</span></span><br>): MutableState&lt;T&gt; = createSnapshotMutableState(value, policy)<br></code></pre></td></tr></table></figure><p>可以看到它是通过调用<code>createSnapshotMutableState(value, policy)</code>来创建并返回一个<code>MutableState&lt;T&gt;</code>对象的，接下来就点进<code>createSnapshotMutableState(value, policy)</code>看一看：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">createSnapshotMutableState</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    value: <span class="hljs-type">T</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    policy: <span class="hljs-type">SnapshotMutationPolicy</span>&lt;<span class="hljs-type">T</span>&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: SnapshotMutableState&lt;T&gt; = ParcelableSnapshotMutableState(value, policy)<br></code></pre></td></tr></table></figure><p>同样是一个等号，继续往下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParcelableSnapshotMutableState</span>&lt;<span class="hljs-type">T</span>&gt;(<br>    value: T,<br>    policy: SnapshotMutationPolicy&lt;T&gt;<br>) : SnapshotMutableStateImpl&lt;T&gt;(value, policy), Parcelable &#123;<br><br><span class="hljs-comment">// 省略中间代码</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>ParcelableSnapshotMutableState</code>类内的代码就是一些对<code>Parcelable</code>接口中的方法的重写而已，这里就省略不贴上来了。也就是说，<code>ParcelableSnapshotMutableState</code>类的作用就是在继承<code>SnapshotMutableStateImpl</code>类的基础上实现<code>Parcelable</code>接口而已，关键还得看<code>SnapshotMutableStateImpl</code>类，点进去：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SnapshotMutableStateImpl</span>&lt;<span class="hljs-type">T</span>&gt;(<br>    value: T,<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> policy: SnapshotMutationPolicy&lt;T&gt;<br>) : StateObject, SnapshotMutableState&lt;T&gt; &#123;<br>    <span class="hljs-meta">@Suppress(<span class="hljs-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> value: T<br>        <span class="hljs-keyword">get</span>() = next.readable(<span class="hljs-keyword">this</span>).value<br>        <span class="hljs-keyword">set</span>(value) = next.withCurrent &#123;<br>            <span class="hljs-keyword">if</span> (!policy.equivalent(it.value, value)) &#123;<br>                next.overwritable(<span class="hljs-keyword">this</span>, it) &#123; <span class="hljs-keyword">this</span>.value = value &#125;<br>            &#125;<br>        &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> next: StateStateRecord&lt;T&gt; = StateStateRecord(value)<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> firstStateRecord: StateRecord<br>        <span class="hljs-keyword">get</span>() = next<br><br><span class="hljs-comment">// 省略剩余代码</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这个类首先实现了<code>SnapshotMutableState</code>接口，从而间接实现了<code>MutableState</code>接口。而在<code>MutableState</code>接口中，有一个<code>value</code>属性，这就是我们在读写时调用的那个<code>value</code>。根据 Kotlin 接口的特性：接口中可以声明属性，但是属性不能被赋值，实现接口的同时需要实现接口中属性的 getter 和 setter 方法（如果属性被<code>var</code>修饰的话）。所以回到上面的代码中可以看到，<code>MutableState</code>接口中的<code>value</code>属性已经被重写了，或者说已经被实现 getter 和 setter 方法了，这样一来，我们就算找到了 getter 和 setter 方法的位置，接下来就是简单看一看这两个方法。</p><p>但是在那之前还有一点要提一下，就是到目前为止虽然都在讲<code>MutableState</code>接口，但实际上它并不具备被订阅的能力，也就是说界面的刷新和它的关系并不大，真正与之有关的是被<code>SnapshotMutableStateImpl</code>实现的<code>StateObject</code>接口，接下来先说一些和这个接口有关的内容。</p><p>点进<code>StateObject</code>这个接口中我们就可以看到这样一个属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The first state record in a linked list of state records.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">val</span> firstStateRecord: StateRecord<br></code></pre></td></tr></table></figure><p>到这里又要稍微提一下，在 Compose 中，一个 state object 的状态其实并不只有一个，Compose 会将多个状态保存在一个链表中，以方便后续去进行添加或是合并的操作。从这个属性的注释中也大概可以得知这是“状态记录链表中的第一个记录”，也就是链表中的头节点。</p><p>接着我们回到<code>SnapshotMutableStateImpl</code>类中，由于<code>SnapshotMutableStateImpl</code>类实现了<code>StateObject</code>接口，所以它要实现<code>firstStateRecord</code>的 getter 方法，我们看到这个 getter 方法也很简单，就一句话<code>get() = next</code>，但是这个<code>next</code>是什么意思呢？往上看一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//                                      ↓ 直接调用构造函数实例化</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> next: StateStateRecord&lt;T&gt; = StateStateRecord(value)<br></code></pre></td></tr></table></figure><p>可以看到<code>next</code>是一个<code>StateStateRecord</code>类型的属性，接着我们点进<code>StateStateRecord</code>看一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StateStateRecord</span>&lt;<span class="hljs-type">T</span>&gt;(myValue: T) : StateRecord() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">assign</span><span class="hljs-params">(value: <span class="hljs-type">StateRecord</span>)</span></span> &#123;<br>        <span class="hljs-meta">@Suppress(<span class="hljs-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>        <span class="hljs-keyword">this</span>.value = (value <span class="hljs-keyword">as</span> StateStateRecord&lt;T&gt;).value<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>: StateRecord = StateStateRecord(value)<br>    <span class="hljs-comment">//    ↓ 把构造函数传递进来的参数也保存了一份</span><br>    <span class="hljs-keyword">var</span> value: T = myValue<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到<code>StateStateRecord</code>的构造函数接收一个泛型参数，在源码中，官方是直接将<code>SnapshotMutableStateImpl</code>构造函数中同样为泛型参数的<code>value</code>作为参数传递进<code>StateStateRecord</code>的构造函数中的，并且<code>StateStateRecord</code>自己还创建了一个属性用于保存传递进来的这个 value（传递进来后的名字是<code>myValue</code>），然后这个<code>myValue</code>（其实就是<code>value</code>），其实就是最开始我们在调用<code>mutableStateOf()</code>创建一个可以被监听&#x2F;订阅的对象时传递进去的值！</p><p>又因为<code>next</code>直接调用了构造函数，所以在<code>SnapshotMutableStateImpl</code>类对象实例化的时候，<code>next</code>自己也实例化了，并且在实例化后还持有着我们最开始传递进去的那个<code>value</code>，这么一看，这时候的<code>next</code>其实就是 state object 的第一个状态，或者说是链表的头节点！如此一来，<code>firstStateRecord</code>的 getter 方法为什么直接返回<code>next</code>就变得很好理解了！</p><p>还有一点就是尽管<code>next</code>是<code>StateStateRecord</code>类型，但是<code>StateStateRecord</code>也是继承自<code>StateRecord</code>的，所以<code>next</code>可以被直接赋值给<code>firstStateRecord</code>。不过既然都说到这了，不如点进<code>StateRecord</code>看一看：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StateRecord</span> &#123;<br><br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> snapshotId: <span class="hljs-built_in">Int</span> = currentSnapshot().id<br><br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> next: StateRecord? = <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">assign</span><span class="hljs-params">(value: <span class="hljs-type">StateRecord</span>)</span></span><br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>: StateRecord<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到不仅有一个整型属性代表 ID ，同时还有一个名为<code>next</code>的属性代表下一个节点，由此不妨大胆推测<code>StateStateRecord</code>&#x2F;<code>StateRecord</code>就是存储在链表里的节点的数据类型。</p><p>接下来终于要开始看 getter 方法了，虽然它就一条语句。其中<code>next</code>已经大概知道是什么东西了，后面的<code>readable(this)</code>则是主要做了两件事：</p><ol><li><code>snapshot.readObserver?.invoke(state)</code>：通知快照观察系统（read observers）这个 state object 被读取了，并让系统对读取它的位置进行记录，后续当状态发生变化时，这个位置需要进行重组。</li><li><code>readable(this, snapshot.id, snapshot.invalid)</code>：在链表中找到最新且可用的状态并返回这个状态。</li></ol><p>最后的<code>.value</code>就简单了，因为返回的这个状态是和<code>next</code>的类型是相同的，也就是<code>StateStateRecord</code>类型，这个<code>.value</code>就是<code>StateStateRecord</code>类里的一个属性，这个属性保存着我们传递进去的值。</p><p>getter 看完了，接着来看一下 setter ，在 setter 中首先调用了<code>StateStateRecord</code>&#x2F;<code>StateRecord</code>类的一个扩展函数<code>withCurrent()</code>，这个扩展函数同时还是个高阶函数，函数内部做的事情就是调用了它的函数类型的参数，并传入了一个同为<code>StateStateRecord</code>&#x2F;<code>StateRecord</code>类型的对象——这个对象是怎么来的呢？实则是调用了在 getter 方法第二步那里用到的那个三参数的<code>readable()</code>，从而达到在不通知 read observers 的情况下获取链表中最新且可用的状态。</p><p>拿到状态以后我们把视角从<code>withCurrent()</code>内部拉回到 setter 方法中的<code>withCurrent()</code>的 Lambda 表达式中，在这里，我们拿到的那个状态用变量<code>it</code>代表，Compose 接下来会做下面这些事：</p><ol><li><code>if (!policy.equivalent(it.value, value))</code>：判断我们拿到的这个状态的值与 setter 方法要写的值是否相等，如果相等那就不用再赋值了，直接结束即可。</li><li>如果不相等，那就需要写入新的值了，但是这又会分为两种情况：<ul><li>首先将拿到的这个状态的 snapshot ID 和当前快照（Snapshot）的 ID 进行比较，如果相等，则直接把新值写进拿到的这个状态中。</li><li>如果不相等，Compose 会去创建一个新状态，这个状态的 snapshot ID 会和当前快照（Snapshot）的 ID 相同，最后再将新值写进这个新状态中。</li></ul></li><li><code>notifyWrite(snapshot, state)</code>：找到那些用过这个<code>MutableState</code>的位置，并将它们标记为失效，以便在下一次界面刷新时进行重组。</li></ol><h3 id="利用委托简化写法"><a href="#利用委托简化写法" class="headerlink" title="利用委托简化写法"></a>利用委托简化写法</h3><p>到目前为止，每次在使用<code>MutableState</code>对象时都要加上<code>.value</code>才能获取到它包裹住的那个值，对此，Compose 也提供了利用 Kotlin 的委托来进行简化后的写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> name <span class="hljs-keyword">by</span> mutableStateOf(<span class="hljs-string">&quot;Aiden&quot;</span>)<br>setContent &#123;<br>    Text(text = name)<br>&#125;<br></code></pre></td></tr></table></figure><p>同样是之前的例子，在使用了<code>by</code>关键字进行委托以后，每次在读写时就可以直接用变量名而不需要加上<code>.value</code>了。</p><p>当然这样的便利并不是 Compose 的特权，Compose 只是使用了 Kotlin 中的自定义委托，在<code>MutableState</code>接口的代码附近可以看到为<code>State</code>接口和<code>MutableState</code>接口编写的扩展函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> State<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">getValue</span><span class="hljs-params">(thisObj: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: T = value<br><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> MutableState<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">setValue</span><span class="hljs-params">(thisObj: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">T</span>)</span></span> &#123;<br>    <span class="hljs-keyword">this</span>.value = value<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个函数符合了自定义委托的规则，所以在 import 以后就可以直接使用<code>by</code>关键字了。</p><h2 id="remember"><a href="#remember" class="headerlink" title="remember"></a>remember</h2><p>到目前为止我写出来的例子中，<code>MutableState</code>对象的创建都是放在 setContent 代码块之外的，如果我放在 setContent() 代码块内，就会得到 Android Studio 的一个警告：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">setContent &#123;<br>    <span class="hljs-comment">//          ↓ mutableStateOf 会被划红色波浪线</span><br>    <span class="hljs-keyword">var</span> name <span class="hljs-keyword">by</span> mutableStateOf(<span class="hljs-string">&quot;Aiden&quot;</span>)<br>    Text(text = name)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个警告并不会阻止程序编译运行，那既然如此它为什么还要警告呢？</p><p>这是因为 setContent() 代码块内是一个 Composable ，而 Composable 是有可能会经历重组的，所谓 <strong>重组（Recompose）</strong> 就是界面刷新过程中的一个步骤，比如对象<code>name</code>的值由<code>Aiden</code>改成<code>Marcus</code>，这个变化就会触发重组，重组会让文本控件<code>Text(text = name)</code>显示了新的文本<code>Marcus</code>。这看起来是好的，毕竟我改了东西，界面上就应该要显示出来，但是问题在于重组这个步骤会导致 <strong>重组作用域（Recompose scope）</strong> 中的代码被再次执行。所谓重组作用域就是在 Composable 中的某段代码，尽管它并没有非常明确的范围提示，但是我们知道它大概就是在那个读取了发生变化的<code>MutableState</code>对象的代码的附近，就比如<code>Text(text = name)</code>这行代码的上下几行都在重组作用域中，也就是说，你明明把对象<code>name</code>的值由<code>Aiden</code>改为了<code>Marcus</code>，但是由于重组，<code>var name by mutableStateOf(&quot;Aiden&quot;)</code>这条语句又被执行了一次，导致对象<code>name</code>又被创建了一次，它的值还是<code>Aiden</code>，文本控件最终显示的也是<code>Aiden</code>……</p><p>也许你会想：“那我不在 setContent() 里面创建变量不就好了吗？”是，这样确实可以避免被 setContent() 里的 Composable 在重组时波及到，但是你并不能保证你在其它的 Composable 当中没有创建变量的需求，比如在自定义 Composable 中……</p><p>所以这时候就要用到<code>remember()</code>这个解决方案了，当我们引入<code>remember()</code>以后，Android Studio 的警告也会随之消失：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">setContent &#123;<br>    <span class="hljs-keyword">var</span> name <span class="hljs-keyword">by</span> remember &#123; mutableStateOf(<span class="hljs-string">&quot;Aiden&quot;</span>) &#125;<br>    Text(text = name)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>remember()</code>其实是起到一个缓存的作用，在初次调用时会去保存函数内的对象，在后续调用中就直接返回保存的这个对象了，这样也就避免了因为再次创建对象从而产生的问题，之后如果修改了<code>name</code>的值，文本控件也能正确显示新内容了。</p><p>但是<code>remember()</code>还是很灵活的，它缓存的内容还是可以刷新的，这就要提到<code>remember()</code>还有带其它参数的重载版本了。具体来说就是可以向<code>remember()</code>中传入一个或多个 key ，这些 key 可以是任意类型，比如<code>String</code>或者<code>Int</code>等等，这些 key 起到一个控制缓存有效性的作用，当<code>remember()</code>检测到 key 发生变化时，它就会重新执行 Lambda 中的代码。来看个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">HttpRequestSample</span><span class="hljs-params">(url: <span class="hljs-type">String</span>)</span></span> &#123;<br>    <span class="hljs-comment">//                  ↓ 传入 1 个 key</span><br>    <span class="hljs-keyword">val</span> foo = remember(url) &#123; <span class="hljs-string">&quot;// 在这里模拟网络请求&quot;</span> &#125;<br>    <span class="hljs-comment">// 在这里模拟使用请求到的结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上方的自定义 Composable 主要是模拟了一个 HTTP 请求的场景，请求的 URL 作为 key 参数传递进<code>remember()</code>中，这样一来，初次执行代码时，请求会被发起，并且请求获取到的结果会被缓存。后续如果再次执行到这段代码时，如果请求的 URL 没变化，那么<code>remember()</code>就直接返回缓存的结果就可以了，如果 URL 变了，<code>remember()</code>就会再次发起请求然后缓存结果以便下次使用。这样一来就可以避免多次发起相同的请求，节约了资源。</p><h2 id="架构原则"><a href="#架构原则" class="headerlink" title="架构原则"></a>架构原则</h2><p>单向数据流是 Compose 中的一个很重要的概念，但是在讲它之前，还是要先讲点铺垫的内容。</p><h3 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h3><p>首先是“状态”，状态的体现在 View 系统和 Compose 中是不同的。在之前的 View 系统中，widget（控件）都有着自己内部的状态（属性），这些状态既可以在前期通过 XML 设置，也可以在后期通过在代码中利用<code>findViewById()</code>等形式获取到对象实例后，再通过 getter &#x2F; setter 方法来设置。例如 TextView ，它有着<code>text</code>这一状态，这个状态可以通过<code>getText()</code>来读取，也可以通过<code>setText()</code>来设置。</p><p>但是 Compose 中的 widget 却不是这样的，在 Compose 中同样用于显示文本的<code>Text()</code> widget 是没有内部状态的，就更别提使用 getter &#x2F; setter 方法来维护状态了。这一时间也许你会觉得 Compose 很没用，因为它连获取一个文本 widget 显示的文本内容这件事都做不到。</p><p>事实倒也不是这样，前面也提到 Compose 的 widget 只是没有内部状态而已，并不是说它没有状态，而是它的内部状态被提到外部来了。就以<code>Text()</code> widget 为例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> greeting = <span class="hljs-string">&quot;Hello! Aiden&quot;</span><br>setContent &#123;<br>    Text(text = greeting)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Text()</code> widget 中的状态<code>text</code>表示显示的文本内容，它被提到了外部变成了<code>Text()</code>这个函数的参数，当我们在调用<code>Text()</code>的时候需要向其中传入相应的内容，又因为这个参数是由我们主动传进去的，所以状态的后期维护也是可行的，就比如我现在要读取<code>Text()</code> widget 显示的内容，其实我只要读取<code>greeting</code>变量就行了，又比如我想让显示的内容变成“Hello! Marcus”，那我只需要修改变量<code>greeting</code>即可。</p><p>这种将内部的状态提到外部的模式在 Compose 中叫 <strong>“State hoisting”</strong> &#x2F; <strong>“状态提升”</strong> ，这是所有 Compose widget 甚至自定义 Composable 都要遵循的模式。</p><h3 id="SSOT"><a href="#SSOT" class="headerlink" title="SSOT"></a>SSOT</h3><p>接下来以<code>TextField(value = , onValueChange = )</code>作为例子来讲一个概念，TextField 是一个 Compose 内置的具有 Material 3 风格的文本输入框，调用它的时候会要求我们填入两个参数，根据函数签名以及注释可以知道，参数<code>value</code>的类型是<code>String</code>，它将作为显示在文本框中的文本，注意，它并不是 placeholder ，而是你在文本框中输入的文本的载体，你输入的文本会存储在这个对象中。参数<code>onValueChange</code>是一个函数类型的参数，作用是用户在文本框中进行输入操作时的回调，接下来看一个实际用例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 创建一个可被订阅的空字符串</span><br><span class="hljs-keyword">var</span> text <span class="hljs-keyword">by</span> mutableStateOf(<span class="hljs-string">&quot;&quot;</span>)<br>setContent &#123;<br>    TextField(value = text, onValueChange = &#123;<br>        <span class="hljs-comment">//     ↓ it 在这里为用户输入的内容</span><br>        text = it<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>首先<code>value</code>和<code>onValueChange</code>这两个参数都是状态提升的体现。其次是这个 widget 的工作逻辑：TextField 显示的内容被存储在<code>String</code>类型的变量<code>text</code>中，当用户进行输入操作后，新的值会通过<code>onValueChange</code>这个回调赋值给变量<code>text</code>，变量<code>text</code>发生了变化，触发重组，最后由 TextField 显示新的内容，由此形成闭环。但是如果 onValueChange 回调里面什么都不写，那么无论怎么输入，文本框都是没反应的。</p><p>一个文本框不就是让用户来进行输入操作的吗？输入的时候为什么不直接显示出来？显示内容的更新逻辑还要我自己写？这就要提到 Compose 所提倡的另一个架构原则—— <strong>Single source of truth</strong> &#x2F; <strong>单一数据源</strong> &#x2F; <strong>单一可信来源</strong> 。这个模式的最大优势在于将数据的更改行为集中到一个地方 &#x2F; 保护数据不会被其它地方修改 &#x2F; 易于跟踪数据的修改源，从而更易于发现 BUG 。这个理念在 TextField 等 Compose widget 上体现得淋漓尽致，接下来讲一个很简单的例子你一定会明白。</p><p>假设我要让用户在一个 TextField 中输入年龄，并且假设 Compose 已经帮我实现了 TextField 显示内容自动更新的逻辑，即用户输入的内容不会经过我，而是直接显示在 TextField 中。现在我有一个需求，我要求这个 TextField 只能输入阿拉伯数字，因为年龄就是阿拉伯数字。然后当程序运行时你就会发现出问题了，当用户输入非阿拉伯数字时，TextField 也是会接收并且显示的。对此我想到两个方案：</p><ol><li>再添加一个监听事件，把 TextField 里面的非阿拉伯数字删掉就行了；</li><li>等用户把所有的表单填完，点“提交”的时候我在统一审查，不合格就不给提交；</li><li>……</li></ol><p>对于第 1 个方案，用户在输入完以后，TextField 中可能会短暂出现非法字符，虽然最后都被我删掉了，但是这个过程的体验就不好了，尽管只是一个很细小的问题。对于第 2 个方案看起来好像比第一个方案好，但是这两个方案无论是哪一个，顶多只能算是补救措施，并不满足我的需求。我的需求是这个 TextField 中完全不能出现非阿拉伯数字，之所以会出现，就是因为我假设 Compose 帮我实现了 TextField 显示内容自动更新的逻辑，导致 TextField 的数据源除了我以外，还多了个“用户输入”。我是可以在代码上去修改 TextField 显示的内容的，但是用户也可以在运行时通过和 TextField 交互来改变其显示的内容——这就乱套了。</p><p>好在实际情况是 Compose 把 TextField 内容更新的回调交由开发者来实现，这样一来，TextField 的数据来源就永远只有开发者一个了。</p><h3 id="UDF"><a href="#UDF" class="headerlink" title="UDF"></a>UDF</h3><p>在 Compose 中的 widget 一般有状态（State）和事件（Event）这么两个概念，同样以前面的 TextField 为例，<code>value</code>就是状态，而<code>onValueChange</code>就是事件。我们在使用 TextField 时会把状态<code>value</code>传递给 TextField 让它去显示内容，然后 TextField 又会把输入回调事件<code>onValueChange</code>提取出来反向传递给我们，让我们来自定义，这么一来一回的过程在 Compose 中就被称为 <strong>Unidirectional data flow</strong> &#x2F; <strong>单向数据流</strong> 。</p><p>Compose 推荐将 Single source of truth（单一数据源）与 Unidirectional data flow（单向数据流）模式一起使用，此模式可以更好地保证数据一致性，不易出错、更易于调试，并且具备 SSOT 模式的所有优势。</p><h2 id="可变状态集合"><a href="#可变状态集合" class="headerlink" title="可变状态集合"></a>可变状态集合</h2><p>接下来借一个例子来简单讲一下在大多数时候应该怎样使用集合才能正常触发重组，先看下面这段代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> numberList <span class="hljs-keyword">by</span> mutableStateOf(mutableListOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br>setContent &#123;<br>Column &#123;<br>Button(onClick = &#123; numberList.add(numberList.last() + <span class="hljs-number">1</span>) &#125;) &#123;<br>Text(<span class="hljs-string">&quot;加 1&quot;</span>)<br>&#125;<br><span class="hljs-keyword">for</span> (number <span class="hljs-keyword">in</span> numberList) &#123;<br>Text(text = number.toString())<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先解释一下代码：</p><ol><li>首先使用了<code>mutableStateOf()</code>创建了一个可变列表<code>numberList</code>，目的是希望当列表中的内容发生变化时就触发重组然后刷新界面；</li><li>接着创建了一个纵向布局；</li><li>在纵向布局中创建了一个显示着“加 1”的按钮，点击按钮后会把一个数字添加到<code>numberList</code>列表末尾，这个数字的值是在<code>numberList</code>列表的最后一个数字的基础上加 1 ；</li><li>在按钮下面遍历<code>numberList</code>列表，并把内容显示出来；</li></ol><p>程序运行的理想效果是：一开始会显示一个按钮以及三行数字，每当我点击一次按钮，就会多显示一行数字。</p><p>但是程序实际运行起来并不是这样，这同样是因为以往我们所使用的这些集合是没办法和 Compose 合作的，它们并不具备被订阅的功能，自然也就无法触发重组，所以如果要创建一个可被订阅的列表，应该要使用<code>mutableStateListOf()</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> numberList = mutableStateListOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment">// 其余代码不变</span><br></code></pre></td></tr></table></figure><p>对于这个改动主要有几点要注意：</p><ul><li>一般情况下我们只会修改集合的内部，集合本身是不需要被重新赋值的，所以改为使用<code>val</code>来修饰变量而不是<code>var</code>；</li><li>可变状态集合类并没有实现委托，所以无法使用<code>by</code>关键字了，改为使用等号<code>=</code>；</li><li><code>mutableStateListOf()</code>内部不需要再调用<code>mutableListOf()</code>来创建一个可变列表了，直接把初始内容写进去即可；</li></ul><p>这样一来，当<code>numberList</code>列表中的内容发生改变后就会正常触发重组了。</p><p>另外，除了使用<code>mutableStateListOf()</code>来创建可以被订阅的列表外，还可以使用<code>mutableStateMapOf()</code>来创建可以被订阅的 Map 。</p><h2 id="CompositionLocal"><a href="#CompositionLocal" class="headerlink" title="CompositionLocal"></a>CompositionLocal</h2><p>CompositionLocal 中的【Composition】指的是 Compose 中的那些布局和组合，【Local】指的是局部的意思，所以 CompositionLocal 就可以理解为是在 Composable 中使用的特殊的局部变量。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>CompositionLocal 的使用场景目前大致有两个：</p><ol><li>提供上下文。在 Android Studio 中，当我们键入【Local】时，IDE 会为我们提供补全建议，在列表中我们可以看到很多由 Compose 官方定义好的 CompositionLocal 实例，例如<code>LocalContext</code>就是用来提供应用上下文的。</li><li>主题。以具有 Material Design 风格的<code>Button()</code>为例（不是<code>material3</code>包中的<code>Button()</code>），在它的函数签名中有一个叫<code>colors</code>的参数，这个参数默认拿的就是<code>LocalColors</code>提供的颜色。</li></ol><p>CompositionLocal 和函数参数也有一定的区别，举一个可能不太恰当的例子：比如有一个定制裤子的函数，它接收一个参数，参数是你的身高，函数需要通过你的身高来定制裤子，而此时你的身高可以通过 CompositionLocal 来获取。也就是说，函数参数更像是函数作者规定好的东西，使用函数时一定要遵守，至于参数怎么用，由函数作者来决定。而 CompositionLocal 就像是提供好的一个属性，提供者在提供时就已经和使用者达成了共识，大家都知道这个 CompositionLocal 是干嘛用的（比如<code>LocalContext</code>），接下来就是在有需要的地方去使用就好了。</p><h3 id="自定义-CompositionLocal"><a href="#自定义-CompositionLocal" class="headerlink" title="自定义 CompositionLocal"></a>自定义 CompositionLocal</h3><p>除了使用官方提供的 CompositionLocal ，我们也可以创建自己的 CompositionLocal ：</p><p>首先需要声明一个 CompositionLocal 实例并提供默认值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> LocalName = compositionLocalOf &#123; <span class="hljs-string">&quot;Aiden&quot;</span> &#125;<br></code></pre></td></tr></table></figure><p>随后在需要使用的地方直接调用即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">User</span><span class="hljs-params">()</span></span> &#123;<br>    Text(LocalName.current)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要覆盖默认值，就这么做：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">setContent &#123;<br>CompositionLocalProvider(LocalName provides  <span class="hljs-string">&quot;Marcus&quot;</span>) &#123;<br>User()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当没有像上面这样使用<code>CompositionLocalProvider()</code>来提供值时，系统就会使用声明 CompositionLocal 实例时提供的默认值。</p><p><code>CompositionLocalProvider()</code>可以进行嵌套使用，每一层嵌套都只会受到那一层提供的值的影响：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">setContent &#123;<br>CompositionLocalProvider(LocalName provides <span class="hljs-string">&quot;Aiden&quot;</span>) &#123;<br>User()  <span class="hljs-comment">// 这里显示的是 Aiden</span><br>CompositionLocalProvider(LocalName provides <span class="hljs-string">&quot;Marcus&quot;</span>) &#123;<br>User()  <span class="hljs-comment">// 这里显示的是 Marcus</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CompositionLocalProvider()</code>可以一次性<code>provides()</code>多个值，每个值以逗号<code>,</code>隔开：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> LocalName = compositionLocalOf &#123; <span class="hljs-string">&quot;Aiden&quot;</span> &#125;<br><span class="hljs-keyword">val</span> LocalAge = compositionLocalOf &#123; <span class="hljs-number">24</span> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">setContent &#123;<br>CompositionLocalProvider(LocalName provides <span class="hljs-string">&quot;Aiden&quot;</span>, LocalAge provides <span class="hljs-number">24</span>) &#123;<br>User()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>compositionLocalOf()</code>创建的 CompositionLocal 实例会被订阅，当提供用来覆盖默认值的值发生变化时，就会精准地触发重组，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> name <span class="hljs-keyword">by</span> mutableStateOf(<span class="hljs-string">&quot;Aiden&quot;</span>)<br>setContent &#123;<br>    <span class="hljs-comment">//                                           ↓ 当 name 发生变化时会精准地触发`User()`的重组</span><br>CompositionLocalProvider(LocalName provides name) &#123;<br>User()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而如果是使用<code>staticCompositionLocalOf()</code>创建的 CompositionLocal 实例则不会被订阅，但是仍然会触发重组，只不过没那么精准，重组涉及的范围会变大。</p><p>也就是说，当实例会经常发生变化时，我们应该使用<code>compositionLocalOf()</code>来创建这个实例，尽管订阅实例的变化会消耗一定的性能，但是其带来的精准范围重组可以帮我们避免进行更多的计算，例如<code>LocalContentColor</code>就是用<code>compositionLocalOf()</code>创建的。而当一个实例压根不会变化时，我们应该使用<code>staticCompositionLocalOf()</code>来创建它，这样一来，重组时虽然会波及到较大的范围，但是发生重组的可能性并不大。<code>LocalContext</code>就是用<code>staticCompositionLocalOf()</code>创建的，因为上下文基本不会发生变化。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Compose 学习笔记 ① - 基础概念</title>
    <link href="/post/Compose-Study-Guide-01/"/>
    <url>/post/Compose-Study-Guide-01/</url>
    
    <content type="html"><![CDATA[<p>不知不觉 Compose Multiplatform 的版本已经来到了 1.5.10 了，最近打算在业余时间把 Compose 的知识点重新过一遍，至于跨平台的话等后续再找时间玩一下。</p><span id="more"></span><h2 id="声明式-UI"><a href="#声明式-UI" class="headerlink" title="声明式 UI"></a>声明式 UI</h2><p>Compose 的写法属于「声明式」，声明式编程是一种编程范式，而编程范式是一种编程的风格或方法论，除了「声明式」以外，还有「命令式」、「函数式」等等。</p><p>对于同一个界面需求，比如创建一个文本控件，然后修改其显示的内容，传统 View 系统的做法是先在布局文件中创建一个文本控件，然后再在代码中去获取到这个控件的实例，最后通过代码手动去修改它的属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/myTextView&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;传统 XML 写法&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>其中<code>android:text</code>中的内容是固定死的，如果我后续要在代码中修改文本内容的话，我要这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> textView = findViewById&lt;TextView&gt;(R.id.myTextView)<br>textView.text = <span class="hljs-string">&quot;设置新的文本&quot;</span><br></code></pre></td></tr></table></figure><p>像传统 View 系统这样的写法就是命令式编程，命令式编程通常包含了程序状态的明确改变，以及通过语句按顺序执行的控制流。具体来说就是我们会给到计算机一系列指令，告诉它该如何执行任务。</p><p>那么到这里其实就大概可以猜到，「声明式 UI」的特点之一，或者说是 Compose 的核心写法就是不需要手动去更新界面，这就是声明式与命令式的区别体现。接下来是一个用 Compose 实现同样需求的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> greeting = <span class="hljs-string">&quot;Hello Compose!&quot;</span><br>Text(text = greeting)  <span class="hljs-comment">// 将上面创建的 text 变量作为参数传递进 Text() 中</span><br></code></pre></td></tr></table></figure><p>这里的<code>Text()</code>看起来就像是一个函数一样，用官方的话来说，它是一个 Composable（中文译为「可组合项」），<code>Text()</code>其实也就是 Compose 中的文本组件，它接收多个参数，其中有一个类型为<code>String</code>的<code>text</code>参数将作为显示的内容，在这里我将上面创建的变量<code>greeting</code>作为参数传递，所以文本最终会显示「Hello Compose!」。之后如果在程序中的某个地方需要修改这个文本显示的内容，那么只需要修改变量<code>greeting</code>的值即可！也就是说，在这个例子中，Compose 的声明式体现在两个地方：</p><ol><li>自动利用给到的<code>text</code>参数初始化文本显示内容；</li><li>当给到的参数发生变化时，将自动更新界面；</li></ol><p>再简单一点说，是不是声明式 UI 与使不使用 XML 没关系，主要还是要看需不需要手动更新界面。</p><h2 id="布局迁移"><a href="#布局迁移" class="headerlink" title="布局迁移"></a>布局迁移</h2><p>View 系统在进行界面布局时会用到各种 Layout ，这些 Layout 并不能直接在 Compose 中使用，但是都会有一些它们的替代品来实现相同的效果：</p><ul><li>FrameLayout → Box()</li><li>LinearLayout → Column() &#x2F; Row()</li><li>RelativeLayout → Box() + Modifier</li><li>ConstraintLayout → 一部分功能由 Box() 实现</li><li>RecyclerView → LazyColumn() &#x2F; LazyRow()</li><li>ScrollView → Modifier.verticalScroll() &#x2F; Modifier.horizontalScroll()</li><li>ViewPager → 位于 accompanist 库中的 Pager()</li></ul><h2 id="Modifier"><a href="#Modifier" class="headerlink" title="Modifier"></a>Modifier</h2><p>在 View 系统中，对控件的属性设置需要在 XML 文件中进行，但是在 Compose 中没有 XML 文件，取而代之的是 Modifier 和控件函数本身自带的参数。例如想要让一个文本控件显示的内容是「Try Modifier」，同时将其内边距设置为 5 个 dp 就这可以这么做：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Text(text = <span class="hljs-string">&quot;Try Modifier&quot;</span>, modifier = Modifier.padding(<span class="hljs-number">5.</span>dp))<br></code></pre></td></tr></table></figure><p>可以看到，<code>text</code>参数负责接收需要显示的文本，而内边距属性则是由一个 Modifier 实例带进了<code>modifier</code>参数中。但是这里就会产生一个问题：「我怎么知道设置文本的时候是用到<code>text</code>参数，然后设置内边距的时候是用到 Modifier 呢？」其实很好分辨，首先 Modifier 更多是用来对一些通用属性进行设置的，例如内边距、背景颜色、点击监听等等，这些属性基本上每个控件都会有。而部分控件特有的属性，则是会单独作为一个函数参数而存在的，例如上方的文本控件中的<code>text</code>参数，因为显示文本是文本相关的控件才有的。</p><p>此外 Modifier 还有一个特性尤其需要注意，即「顺序敏感，依次执行，调用叠加」。在使用 Modifier 时，可以通过链式调用一次性为控件设置多个属性，但是这些设置属性的函数会按照编写的顺序依次执行，同时对于某些函数来说，多次调用的效果是叠加而不是覆盖。最能体现这个特性的一个案例就是内边距和外边距，在 Modifier 中，通过<code>padding()</code>来设置内边距，但是并不能通过<code>margin()</code>来设置外边距，因为 Modifier 中并没有<code>margin()</code>。同样以上面的文本控件来做一个简单的示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Text(text = <span class="hljs-string">&quot;Try Modifier&quot;</span>,<br>    modifier = Modifier<br>        .background(Color.Black)<br>        .padding(<span class="hljs-number">5.</span>dp)<br>        .background(Color.Red)<br>        .padding(<span class="hljs-number">5.</span>dp)<br>)<br></code></pre></td></tr></table></figure><p>程序运行，效果如下：</p><p><img src="/images/note/Modifier-%E5%86%85%E3%80%81%E5%A4%96%E8%BE%B9%E8%B7%9D%E6%B5%8B%E8%AF%95.png" alt="Modifier 设置内、外边距效果"></p><p>从效果上来看，大致可以判断出最外层这一圈黑色的好像就是文本的外边距，里面的红色背景的边界距离文本也有一定距离，这个距离就是内边距。</p><h2 id="分组和依赖引入"><a href="#分组和依赖引入" class="headerlink" title="分组和依赖引入"></a>分组和依赖引入</h2><p>从官方文档中得知 Compose 由<code>androidx</code>中的 7 个 Maven 组 ID 构成，每个组都包含一套特定用途的功能，这 7 个组以及其说明如下：</p><table><thead><tr><th>组</th><th>说明</th></tr></thead><tbody><tr><td>compose.animation</td><td>在 Jetpack Compose 应用中构建动画，丰富用户体验。</td></tr><tr><td>compose.compiler</td><td>借助 Kotlin 编译器插件，转换 @Composable functions（可组合函数）并启用优化功能。</td></tr><tr><td>compose.foundation</td><td>使用现成可用的构建块编写 Jetpack Compose 应用，还可扩展 Foundation 以构建您自己的设计系统元素。</td></tr><tr><td>compose.material</td><td>使用现成可用的 Material Design 组件构建 Jetpack Compose UI。这是更高层级的 Compose 入口点，旨在提供与 <a href="http://www.material.io/">www.material.io</a> 上描述的组件一致的组件。</td></tr><tr><td>compose.material3</td><td>使用 Material Design 3（新一代 Material Design）组件构建 Jetpack Compose UI。Material 3 中包括了更新后的主题和组件，以及动态配色等 Material You 个性化功能，旨在与新的 Android 12 视觉风格和系统界面相得益彰。</td></tr><tr><td>compose.runtime</td><td>Compose 编程模型和状态管理的基本构建块，以及 Compose 编译器插件的目标核心运行时。</td></tr><tr><td>compose.ui</td><td>与设备互动所需的 Compose UI 的基本组件，包括布局、绘图和输入。</td></tr></tbody></table><p>View 系统并没有像 Compose 这样明确分组，一定程度上导致 View 系统发展到后期越来越难扩展。这样看来 Compose 的分组带来的好处是显而易见的：首先是开发者可以根据自己的需求选择性地添加依赖项，而不是一次性引入所有的库；再者就是官方自己也方便版本管理和更新。</p><p>那么在开发过程中应该如何选择性地引入依赖项呢，这就要先对这些组进行一个补充介绍：</p><ol><li><code>compiler</code>：编译器插件，在 gradle 的<code>dependencies</code>中并不需要明确引入，因为在<code>dependencies</code>的上方就已经标注了：<code>kotlinCompilerExtensionVersion = &quot;1.4.3&quot;</code>。</li><li><code>runtime</code>：Compose 底层的模型，包含数据结构和状态转换机制等等，例如<code>mutableStateOf()</code>、<code>remember()</code>等等。</li><li><code>ui</code>：提供和 UI 相关的最基础的功能，包括绘制、测量、布局、触摸反馈等。</li><li><code>animation</code>：动画相关。</li><li><code>foundation</code>：提供相对完整的 UI 体系，例如<code>Column()</code>和<code>Row()</code>、<code>Image()</code>等。</li><li><code>material</code>&#x2F;<code>material3</code>：包含了大量 Material Design 风格的组件，例如<code>Button()</code>、<code>OutlinedButton()</code>、<code>TextButton()</code>等。值得一提的是：「按钮」这个东西并不是 Material Design 发明的，只是官方设计的具备了 Material Design 风格的按钮刚好叫作「Button」而已。</li></ol><p>在上面的列表中，越靠前的组越接近底层，往后的组会依赖前面的组，例如 4 依赖 3 ，3 依赖 2 ，也就是说，在使用过程中，只需引入其中一个组，这个组之前的组都会被引入。例如，我想使用官方提供的具有 Material Design 风格的控件，所以我引入了<code>material</code>&#x2F;<code>material3</code>，又因为<code>material</code>&#x2F;<code>material3</code>在最上层，所以它依赖的组（<code>foundation</code>、<code>animation</code>等）也都会被引入。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我还活着呢</title>
    <link href="/post/I-am-not-dead-yet/"/>
    <url>/post/I-am-not-dead-yet/</url>
    
    <content type="html"><![CDATA[<p>虽然活得挺郁闷。</p><span id="more"></span><p>距离上一篇 post 直接就过去了半年是真他妈牛逼，来看看这半年我都经历了什么……首先是上篇 post 写完没几天就被辞退了，刚好卡在试用期快结束的时候，理由是公司业绩不太好，为了降低成本，暂时不需要这么多人。于是我们技术部门先是干掉一个前端实习生，然后一个后端说要去别的地方发展也就随着走了，紧接着就是我，整个部门最后只剩下主管一个人。我进公司的时候，公司在 Boss 直聘上还挂着好几个岗位，我进公司以后，后续才进来了前面说的那个后端工程师和前端实习生，然后美术部门那边也招了两个，我是不太清楚业绩和环境发生了什么变化，能让我们在短短三个月时间就经历从招人到开人。</p><p>不过有些事情也没必要过于纠结，真正需要考虑的是再就业问题。那几天就在公寓里投简历，甚至有一天出现了把 Boss 直聘当天的投递次数全部用完的情况。投了刚好一星期，去面了一个在附近做机器人的公司，结果是没有结果。好在当时租房的时候只短租了 3 个月，找不到工作可以暂时回亲戚家住着，紧接着我亲戚就提供了另外一条路，那便是销售，果然码农的结局都是销售和摆摊炒粉吗。</p><hr><p>首先，销售的产品是塑料，具体来说就是工程（改性）塑料的粒料，粒料就是一小粒一小粒那样的塑料原料，所谓「改性」就是塑料原料的基础上添加新的特性，例如使其更加坚硬，或者是使其具备防火性能等等。</p><p>我的上任，很大一部分原因是顶替前同事的位置，因为前同事要跑路了，如果他不走，这个岗位其实也不缺人，至于他为什么要跑路，我后面再说。于是我就带着不情不愿、不讨厌也不喜欢的心态上岗了。然而就是因为这样的态度，再加上工作上各种各样的糟心事，我在上岗一个月后就出现了情绪波动，尽管在亲戚家人以及领导的鼓励下稍微调整回了状态，但是好景不长又会再一次跌入谷底……这种反复出现的情绪低落和毫无干劲就像大姨妈一样折磨着我，甚至到了每天早上起床睁开眼睛后想到的第一件事就是辞职的程度。最终再也坚持不住，在干了 5 个多月后离开了。</p><p>接下来来说说这个工作吧：</p><ol><li>公司规定上午八点上班下午五点半下班，你必须准时上班但是不一定能准时下班，我经常晚上在没吃饭的情况下八点钟才回到住的地方，吃个饭洗个澡就已经九点多接近十点了，看了下手机又该睡觉了。然后一周上六天，全年如此，甚至就连法定节假日都有折扣，今年中秋国庆假期我们 4 号就上班了。现在想来感觉挺讽刺的，之前在珠海上班有双休，后来去了中山的台资电子厂，不仅双休，领导还带头按时下班，他甚至真的会跟你说叫你别加班。再后来来到广州天河，虽然没双休但至少有大小周。这一整个过程真就是体现了越换工作假期越少，自作孽。</li><li>虽然是销售，但是仍然要掌握一些专业知识，比如有一些优秀的销售是从产品或者开发转过去的，就是因为他们本身对产品足够了解，并且有一定的专业知识，所以销售做得非常成功。但是我卖的这个东西和我的专业八杆子打不着，我是真的不感兴趣，如果你让我去卖手机或者卖新能源汽车的话，我或许还会有点兴趣。所以我就是要在这样既对专业知识不了解，同时又和客户有年龄差距导致没太多共同话题的情况下去和客户聊，真的很难聊下去。</li><li>工作中有太多擦屁股的内容，公司的规章制度导致要和本就不好沟通的客户谈很多产品以外的事情，比如对账、收款。客户不好沟通就算了，这个公司里面的部分同事也是不知道该说是态度有问题还是怎样，有时候请他们协助办件事半天没回应的，真的这么难配合吗？</li><li>领导是个更年期女强人，很多时候总是唠唠叨叨真的很烦人，我知道她出发点是为我好，但是很多很简单的道理总是要重复很多遍，好像把我当成那种从山里面出来的野人一样，真的很难和她共事。所以其实我更喜欢我们总部的老板，总部老板给我的印象是做事的思维非常敏捷，思路非常清晰，专业知识很到位，对于一个问题他能很快给到你处理方式并且告诉你为什么这么做，非常爽朗，一句话能讲清楚绝对不会反复唠叨……当然，我与总部老板的相处时间不长，这只是他给我的“印象”罢了。</li></ol><p>实际上工作做什么都还是其次的，跟什么人相处和合作真的很大程度上决定你能走多远。前面提到，我的领导是个五六十岁的女强人，她是我们这个区域的经理，我每天都要和她打交道，她除了我前面提到的会把我当成从山里出来的野人以外，她还非常双标，这是我后面在和她儿子交接工作的时候发现的，没错，「和她儿子交接工作」，你看，这话题是不是越说越有意思了，具体双标情况如下：</p><ol><li>有那么一天，经理叫我去楼下的肯德基买点下午茶点心，我在自提回到办公室打开包装后，经理和我发现袋里漏装了一个蛋挞（具体是蛋挞还是鸡翅之类的我给忘了），然后经理就开始长篇大论地给我讲道理了，说什么「做什么事都要细心」、「把工作当成自己的工作」、「不能依赖别人」……巴拉巴拉说了一大堆。首先，我认可你说的「道理」是对的，但是我觉得你没必要就此给我啰里啰唆半个多小时，有必要吗？你真觉得我是从山里出来的野人还是怎么着？然后她双标在什么地方呢？在后续和她儿子交接工作的某一天下午，她又因为某些原因要吃下午茶，这次同样也是肯德基，但是这次是我和他儿子两个人到店去取餐，取完餐回到办公室打开一看——巧了！又漏装了，这次漏装的还是一个汉堡。然后她竟然就只是对着她儿子说了一句话，说之前我也漏装过，然后就结束了……我他妈？？？你不打算对你儿子讲讲之前你给我讲的那些道理了吗？你现在就这？就这样双标？你知道为什么她不敢教训她儿子吗？因为我怕她儿子等下会把她屌到飞起来。交接工作的某天下午，我们在外出差，她儿子在用电话向她汇报工作情况，说是我们计划再去拜访一家客户后就启程返回，汇报完了还多说了一句生病不舒服，然后经理就挂了她儿子的电话，原因是她觉得她昨晚叫他吃药，但是他没吃，今天要工作了，就拿身体不舒服来说事……然后她儿子就开始大发雷霆，在去客户公司的一路上都在跟我臭骂她老妈，说是这样的态度让他很难接受，他虽然是不舒服，但是他也没说不去，他觉得他妈挂他电话让他很来火，一路上都在讲都在骂……最后经理还发微信问我她儿子还生不生气，真是让我开了眼界。</li><li>和她儿子交接工作的某一天上午要去见客户，她竟然跟我说，如果她儿子开车累了，就让我帮开一会儿，别让他太累。我他妈？？？我寻思你儿子去见客户的这条逼路，不是他妈的我每天自己一个人开来回的吗？你怎么没有考虑过我累不累？怎么到你儿子了你就考虑他累不累？双标不要太明显吧姐姐？你儿子就是儿子，人家儿子就不是儿子是吧？真是让我开了眼界。</li><li>对于我这个岗位，有一个专属的工作微信，经理就告诉我要时不时发发朋友圈，如果不知道发什么，那就把总部老板的朋友圈发的内容复制粘贴过来发一下。首先，我是认可她说的，毕竟销售就是要无时无刻刷存在感，我在职的几个月也发了好几条，有风景照，也有我们的产品照配上我们的广告语。但是自从她儿子接手我的工作后，我就一直在关注这个工作微信的朋友圈，从 2023 年 10 月 18 日我离开后一直到 2024 年 2 月份，这个微信都没有更新过朋友圈。我他妈？？？就连总部老总都经常发朋友圈，怎么你儿子的销售技巧是有多高超，连朋友圈都不用发？到我的时候就老叫我发，到你儿子了你就不管了是吧？你就这样双标？怎么了，客户晚上睡觉做梦的时候，你的儿子是可以直接进入他们的梦里面宣传我们的产品吗？所以就不用发朋友圈了是吧？真是让我开了眼界。</li><li>有那么几次，我工作做的不是很到位的时候，经理甚至连我所使用的电子设备都要拿出来说。她说我既然有那么好的手机（iPhone 14 Pro Max）和电脑（MacBook Air 2020 M1），就应该把他们好好用在工作上……我他妈？？？我寻思工作的事你就说工作就行了，为什么要范围蔓延到我的电子设备上呢？我之前是敲代码的，再加上我自己又喜欢电子产品，所以有几个比较好的设备有什么奇怪的？这你都能喷？你怎么不去你看看你那败家子用的是什么设备啊？我反正是有幸进过她儿子房间，桌面摆的是 MacBook Pro 外接一台 LG 显示器，然后还有 Xbox Series X 、Switch 、Keychron 键盘，他手上也拿着 14PM ，甚至还有一台 Xs ，然后他开的是小鹏 P7i ，我他妈连车的首付还没凑齐呢。所以你怎么不说说你儿子，让他把这些东西都用到工作上呢？噢我忘了，你是双标狗，那没事了。而且说到底，只要工作上用得上，谁会不用来工作啊？难道你买一台手机放在家里当传家宝吗？你说这些话我也真是让我开了眼界。</li></ol><p>说到她儿子，其实也是个人才，应该比我大两岁，但是整个人给我的感觉就像 18 岁时的我一样，工作还没开始干就开始大放厥词，牛皮吹上天。当时他知道我要走了，他妈又临时招不到人或者是不想招了，某天下午就请我喝了杯咖啡然后跟我大谈人生理想，大谈人要有远见，要有格局之类乱七八糟的东西。哥们儿，我要是独生子，我家要是跟你家一样有钱，我要是也能去澳洲留学随便花个百来万人民币的话，我也可以像你一样在别人面前谈格局，你懂吗？说了半天始终扯不到实干上，你就比我大两岁，你还真把自己当成那种四五十岁早已见过世间百态、身经百战，视职场如战场的企业家一样啊？我告诉你，咱们都是同龄人，每一代人都有每一代人的毛病，我身上有的问题，你也跑不掉。更何况你家还有点小钱，你还是独生子，你这种条件你以为你能成长到哪去？吹牛谁不会啊？你要真想让你自己看起来成熟一点，你就把你那路怒症改改吧。是的，这傻子还有路怒症，就是开车的时候在车上骂别人，而且很频繁。我寻思这样做有什么意义呢？你牛逼你就直接下车去跟他当面对峙啊，你在车上骂他，他又听不见，反而搞得车上的人心烦意乱，并且显得你很幼稚你知道吗？最后在说一下他之前在跟我「喝咖啡论英雄」时一个非常经典的言论，他说：如果这份工作（也就是我干的这个销售业务员的岗位），他要是想干，是可以干的很好的。我他妈当时差点没把嘴里的咖啡喷出来。不是，哥们儿，我要是想干，我也能干啊，问题就是我不想干啊！别急，他后面还有一句话呢：他说他还要把他同学叫过来一起干，一起把这个事业做大，并且还要利用好他前一份工作的客户名单，好好拓展客户。看到了吗？这就叫格局，这就叫境界，我只能说太牛逼了，为什么牛逼呢，因为他说了那么多，他在 2023 年 10 月 18 日接手我的工作后，到 2024 年的 2 月份就跑路不干了。我真他妈笑嘻了都，真是让我开了眼界。所以我为什么说虽然他比我大两岁，但是整个人给我的感觉就像 18 岁时的我一样，还很幼稚。因为现在的我，无论要做什么，我绝对不会先说，而是先去做。举个最简单的例子，我如果要开始跑步锻炼，我不会才刚跑了一天就开始发朋友圈，然后第二天人就在床上了，不跑了，这不显得自己跟个白痴一样？又很他妈幼稚？</p><p>说回他妈和这份工作，在我上岗之前，我就已经和准备要跑路的段同事了解到，段同事当时上岗，也是因为他的前一个姓符的同事要跑路了。也就是说，在我之前，已经有一个姓符的跑路了，有一个姓段的跑路了，姓段的这个干了就三个月，姓符那个我估计时间也不长。然后当我在 2023 年 10 月 18 日跑路后，经理的儿子上来也没干多久，到 2024 年的 2 月份也跑路了，紧接着又来了个姓何的，干了两个月也跑路了。我为什么在离开后还能了解到这些人事变动，那是因为我的微信里还留着之前的工作微信，又因为工作微信的名字是 公司名称+业务员名字 的格式，所以只要业务员名字变了，你就知道这个岗位又换人了。就连我在职时，我们的客户都经常问到我说为什么我们的人事变动这么频繁，现在我想我大概知道这个答案了，你的工作累得狗一样，然后还摊上这么个领导，每个月还领那么点窝囊费，谁能干得了啊？最后就是这个工作微信的名字，现在已经变成 公司名称+XX办事处 的格式了，我猜测要么就是没招到新人，要么就是由于人事变动过于频繁，经理就让他们把名字格式改掉，别老让客户觉得我们在换人，丢人！不过如果你要是真的换人了，你微信名字换不换也都掩盖不住这个事实啊……无所谓了，反正我笑话是看够了。</p><p>最后再说说我自己吧，其实我也知道一份工作不可能百分之百让人满意，哪怕是当小姐都要应对各种各样的客人，在工作中遇到问题，无非就是以一个什么样的心态来面对而已。对于这份工作，大部分时候给我的感觉就像是坐牢，提不起兴趣。哪怕我是回来当码农，虽然在工作中也会遇到很难实现的需求或者是很难解决的 BUG ，但是钻研技术本身或者是学习知识本身就会让我乐在其中。所以兴趣还是很重要的，如果对一件事情感兴趣，那么再多的投入也值得，非常简单的道理。</p><p>当然这几个月的销售工作我也不是毫无收获，除了对这个行业有了解以外，我也在待人处事上有了一点长进，所以也还是要感谢我领导这几个月来的教导。再不济地说，这几个月上班的工资不仅能让我活下去，还可以让我买一些愿望单上的东西。那么这个岗位就没有一点好处吗？倒也不是，只是我懒得写了，毕竟在掂量一番过后我还是选择了离开，就说明它的好处目前还远不及我在那个位置上的痛苦。</p><hr><p>好了，把目光放到当下吧，现在最重要的还是接下来该怎么做以及以后的规划。首先如果可以的话还是想回到开发的工作上，哪怕刚开始只拿最低薪资，让我别饿死就行，从初级工程师干起，后续再通过学习和实践慢慢提升，不过想想觉得不太可能，且不谈现在环境有多差，社招基本上都是要求一上来就能干活的，而我严重缺乏工作经验，再加上这半年来我真的就没有碰过代码。更何况如果公司要培养人，想必也是会去校招。所以这一系列原因让我觉得想靠自己再次回到纯软件开发的行业是不可能的了，现在摆在眼前的或许还有另一个选项，那就是通过亲戚朋友介绍去干另一份可能和计算机没啥关系的工作，但是这个还是由我再好好想想。我并不是有工作还要挑三拣四，而是我还有更长远的目标，为了这个目标我还是需要投入一定的时间来学习。</p><p>总之，这半年来的回顾大概就是这样了，有时候写这些东西都不知道是写给别人看还是自己看，说是总结有时候也不是很到位，写在这里的东西算是一种寄托，但是有很多细节依旧藏在心里。现在已经是 11 月份了，今年一整年的历程和去年真的很像，今年和去年一样都是过完年大概 2 月底这样从家里出来工作，然后同样是九月份十月份这样失去了工作然后无所事事最后回家等过年……但是今年到目前为止不一样的地方就在于我有了一个长期的目标，接下来无论发生什么，我都要为这个目标付诸行动……加油吧！</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>又一个劳动节假期结束了</title>
    <link href="/post/Another-Labor-Day-holiday-is-over/"/>
    <url>/post/Another-Labor-Day-holiday-is-over/</url>
    
    <content type="html"><![CDATA[<p>又是一个劳动节假期的尾声，又是一篇充满晦气和牢骚的随笔。</p><span id="more"></span><p>去年劳动节在珠海的宿舍里写总结的样子还历历在目，现在虽然也在写，只不过已经不在珠海了，只感叹时间流逝之快，事态变化之多。去年写的比较层次分明，今年就没那么多规划了，想到什么说什么吧。</p><p>首先就还是那个传统，哪里也没去，嘴巴上说是「不想出去人挤人」，实则不知道去哪里，也没人陪着去，可笑又可悲。</p><p>没出去玩，那在公寓干了什么呢。首先是把清明节开始玩的《看门狗：军团》的全部主线和部分支线都玩通了，其次就是看了部电影，看了漫威宇宙的《黑豹》，只能说真的不能怪年轻人爱看漫威，毕竟人家的东西真的就是视觉、听觉和心理上的多重享受。</p><p>今年玩的游戏和看的电影相比去年来说都少了一部，游戏少一部是因为确实不知道玩什么了，看着 Steam 和 Epic 库里总计三百多款游戏陷入沉思，感觉自己也迎来了电子阳痿。不过萎了也不是没理由的，一是这些游戏确实激发不起玩的兴趣，其次就是目前生活上的种种压力和不满让我真的不能再像在大学的时候那样每天无忧无虑地玩游戏了；电影少一部是因为把看电影的时间拿去追别的剧了，极狐啊，影之实力强者啊，斗破苍穹啊。所以原本在看完《黑豹》以后想再看一部《奇异博士》的，但是算了，追别的剧也行。</p><hr><p>假期第一天我还是想明白了一些道理，有些事情不适合自己就是真的不适合，强行让自己去做或者去融入就是在浪费时间，没错，我说的就是社交。活了这么多年，我还是会间歇性忘记自己的存在感和价值有多低，还是会忘记自己就是一个不适合社交的人，哪怕是下载一百个社交 app 都救不了的那种。因为说到底人类的本性就是会去争先恐后地抢夺优质资源，优秀的男性也算是一种优质资源，那么如果自己不够优秀，就不要妄想自己会受到欢迎和关注了，甚至也没有人在乎你的看法和感受。与其试图建立不切实际的关系，不如努力抓住时间提升自己。</p><hr><p>再一次感叹自己的执行效率还是太低了，或者说太不自律了。虽然我没有明确的假期计划，但是很多事情还是会在心里稍微谋划一下的。例如本来想着假期要学习哪些知识，结果到头来也没怎么学。有时候看看自己这个屌样，也就能想明白现在沦落到这样的下场也不奇怪了。</p><p>但是又转念一想，除了通用技能以外，就算我现在很认真地花了很多时间学了专业知识又怎么样，因为有可能我努力的方向是错的，就比如学了 Android 开发相关的知识，结果工作上用不到，甚至有可能不做这个工作了……那这些努力不也就白费了吗？不过说到底重点就还是那个不自律，不学专业知识，也没见得学了多少通用技能，可笑又可悲。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>看门狗：军团 - Review</title>
    <link href="/post/Review-Watch-Dogs-Legion/"/>
    <url>/post/Review-Watch-Dogs-Legion/</url>
    
    <content type="html"><![CDATA[<p>只需要差不多 35 个小时，就可以把看门狗军团的主章节和「血脉相承」DLC 的主线任务以及必要的支线任务体验完。</p><span id="more"></span><p>这款由多伦多工作室开发的甚至都不敢命名为「3」让其成为正统续作的看门狗系列作品，给我的感觉确实比较一般，至少剧情很一般。我自己玩的时候，也只需要前 10 个小时，就可以把所有新鲜的东西都体验完了，剩下的就是育碧开放世界公式里的常规操作，说实话，这些消磨时间的重复行为让我在玩的时候会有点反胃的感觉。</p><h2 id="主章节"><a href="#主章节" class="headerlink" title="主章节"></a>主章节</h2><p>这一作主打的「无主角」玩法也没有想象中或者是宣传中的那么亮眼，实际表现就好像 2077 发售前后的对比一样。一轮体验下来，这个「无主角」真的可以说是可有可无的存在，因为育碧只不过是把本来应该是一个人所掌握的技能分散到好几个人身上去了，然后你为了使用这些技能，你不得已需要通过「招募」去让这些角色加入组织，然后切换到这个角色，才能使用这个角色的技能。但是当你在操作这个角色的时候，显而易见的，你又不能使用其它角色的技能了……然后所谓的「招募」其实也就是让你去帮 NPC 做一个内容类似于游戏里支线的任务，然后完成任务后，NPC 为了报答你就会加入 DedSec ，说到底又是一个消磨时间的操作。</p><p>至于为什么要加入这样的玩法，我觉得是因为通过前两部作品，让玩家认识到了 DedSec 是一个怎样的组织，以及平时会干什么。但是组织是怎么扩充人手的，却从来没有相关介绍和玩法，所以策划可能会觉得「噢，把其他人招募进 DedSec 或许是个不错的 idea 」，然后「招募」系统就应运而生了，然后顺势而然地就诞生了接下来的「无主角」玩法。只能说这就是图个新鲜，算是个不能说加分但至少不扣分的玩法。说到底技术上的限制根本不可能让一款游戏拥有无数个结局，也许过程不一样，但结局都是一样的，最多最多像尼尔那样给你搞好几个不同分支的结局已经很了不起了。而且就是因为「无主角」的加入，导致这游戏的角色刻画真的可以说是前所未有的差劲！这游戏根本没有一个可以让你印象深刻的角色，艾登？克拉拉？马库斯？扳手？没有！和前两作相比，我真的记不住这一作中任何人的名字，而且我相信就算记住了，过了一两年后我也会忘记。</p><hr><p><img src="/../../images/ACGN/WatchDogsLegion.jpg" alt="下雨时的伦敦桥"></p><p>游戏设立在了近未来的伦敦，出现了更多种类的无人机，以及街上的所有车辆都可以完全自动驾驶，游戏中还多次利用了 AR 来推进任务，这些设定都很符合我们对未来的想象。而且伦敦怎么说也是个知名的大城市，拥有伦敦桥这样和旧金山金门大桥类似的知名景点，这样的城市用来作为新游戏的背景再适合不过了。但无论怎么样都无法改变其它地方很拉跨的事实，就像水桶效应一样，背景设定也许是最高的那一块木板，但是并不能保证能装满一桶水。</p><hr><p>游戏的建模也是，重复的脸模真的很多，所有的女性脸模可能用十个手指头都数得过来。所以如果想要构造不同的人物形象，就得靠穿搭和服装。但是游戏里的服饰设计又没什么很大的差异化，搞得我连买衣服的欲望都没有，买衣服用的货币存了一堆<del>（能不能兑成人民币啊）</del>。</p><hr><p>游戏里的车载音乐也非常糟糕，我真的无法想象都 2020 年了还有车载音乐这么拉跨的都市开放世界游戏。一代和二代，甚至是十年前的 GTA 5 ，随便拉一个出来都能挑出几首我喜欢的歌曲，军团真的是他妈的一首都没有啊！你一上车，它会给你放那些好像有点古典感觉的纯音乐，好像还有 FM ，以及流行音乐，但是无论放什么，声音都很小，基本听不清在唱什么。然后也许是因为制作人自己也知道车载音乐拉跨，所以才制作了地铁系统，用来快速在各个地方移动，省去了你跑图的功夫。但是说实话，适当地跑图也是游戏体验的一部分。甚至有没有一种玩法，就是我已经把任务都做完了，但是就是舍不得离开伦敦，然后时不时想回来开车听音乐兜兜风？但是你这车载音乐真的让我想吐。</p><p>既然说到车载音乐，就顺便提一下车辆的驾驶体验。同样的，不能说加分，只能说是不扣分。车辆在伦敦街道上的行驶感觉非常平滑，没有什么高低差很大的地方以至于让车辆起飞。漂移也很好掌握，只需要稍加练习就可以不用在过弯的时候刻意减速了。路上的护栏和路灯感觉很「轻」，都可以被随意撞掉，对驾驶不会有太大的影响。</p><hr><p>前面提到不同的角色有不同的技能，实际上不同的角色可以使用的武器种类也是不一样的。在本作中，制作组似乎更加重视「不杀人通关」了，再加上我记得他们曾经提到过伦敦不像在美国这么容易能搞到枪。所以游戏中大部分角色使用的都是电击枪这样的非致命武器，只有特定职业或者身份的角色才能使用致命武器。其实非致命也没什么，但是你效率太低就不行了啊，打不倒人反而让对方触发了警报，那岂不是自找苦吃？而且这一作是没有狙击枪这一类武器的，一代就有。</p><h2 id="血脉相承"><a href="#血脉相承" class="headerlink" title="血脉相承"></a>血脉相承</h2><p>这是在游戏本体发售 8 个月左右才推出的 DLC ，我很愿意相信这是制作组因为本体的表现不佳然后赶工出来的补救措施。这种补救措施给我的感觉就好像是 2077 的后续补丁一样，也可以类比成《幽灵行动：断点》后面让 AI 重新回归一样……因为游戏本体的销量和风评真的太差了。简而言之，这个 DLC 就是育碧打的感情牌，让一代的老大哥艾登和二代中大家都很喜欢的扳手来救场。这让我想起一句话，当什么东西在走感情路线的时候，就代表它所剩的价值不多了。</p><p>说回 DLC 本身，剧情这里就不多评价了，育碧早都忘记怎么讲故事了，一代剧情的感人程度和艾登的形象刻画是无法复刻的。这一作中的艾登已经年过半百了，但制作组还是请回了原来的声优，以及为艾登保留了最经典的服饰，私法制裁者的感觉、Fox 的感觉，一下子就回来了——一部分。</p><p><img src="/../../images/ACGN/WatchDogsLegion-Aiden.jpg" alt="艾登"></p><p>DLC 的故事发生在主章节之前，游戏地图仍然是主章节的地图，也就是伦敦，只不过少了「招募」系统。而且随着主线的推进，玩家操作的角色会从艾登变为扳手，到最后完成所有主线后，就可以自由在艾登和扳手之间切换。又因为可操作角色缩减为了两人，所以需要考虑的东西也就少了，两人之间的技能差异化就可以做得足够大。所以其实 DLC 只有 5 个小时的游玩时间，但是整体体验真的会比主章节好。</p><p>虽然没了「招募」系统，但是并不代表育碧不会恶心你——没错，部分技能如果想要解锁，还是需要通过做支线任务。而且有几个支线任务是强制绑定在主线中的，我真的绷不住了，这就是我所说的想吐的感觉。</p><p>说到这里，不知道你会不会觉得一切都很熟悉，是的，如果育碧能把 DLC 的长度拉得跟主章节一样长，然后在剧情处理上再加点深度，加点反转，把矛盾扩大，最后再升华一下，这部作品完全可以命名为「看门狗 3」然后发布，完全没必要弄什么「招募」系统和什么「无主角」玩法。包括艾登为什么会从芝加哥来到伦敦，剧情开头都已经解释了，甚至就连这个 DLC 的名字都有所体现，什么叫「血脉相承」啊？只有亲人间才会有血脉相承啊，才会有这样的感情啊，为什么杰克森一开始对待艾登的态度那么冷漠？甚至都不愿意叫一声舅舅？亲人之间为什么会发生这样的矛盾？这才是大家想看的东西，而不是什么傻逼招募和无主角！我真的绷不住了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单来说，我可能会重玩一代和二代，但是我绝对不会重玩军团。一代是一个悲剧，二代是一个喜剧，军团是一个闹剧。一代让我感受到了艾登的人格魅力还有那种孤独的感觉，二代让我领悟到了团队和友情。军团给我带来了什么？我不想评价。</p><p>育碧，说真的，趁着艾登的声优还能继续配音，实在不行咱们把一代重置一下，在剧情上增加一条克拉拉没死的线行吗？你出了我必买单，别整天整这些花里胡哨的了。</p><p><img src="/../../images/ACGN/WatchDogsLegion-Wrench.jpg" alt="扳手"></p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>学习 Android 自定义 View - 第 1 节</title>
    <link href="/post/Android-Study-Guide-Custom-Views-Part-1/"/>
    <url>/post/Android-Study-Guide-Custom-Views-Part-1/</url>
    
    <content type="html"><![CDATA[<p>写写停停，总共花了 4 天时间，效率有点低了。这篇笔记包括了简单的图形绘制，以及如何进行定位。</p><span id="more"></span><h2 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h2><ul><li><code>onDraw()</code>：这是<code>View</code>类中的一个重要函数，用于绘制 View 的内容。在自定义 View 开发中，通常需要重写这个函数来实现自定义的绘制逻辑。<code>onDraw()</code>接收一个<code>Canvas</code>对象作为参数，它代表了当前 View 的绘图区域。</li><li><code>onMeasure()</code>：这是一个用于测量 View 的尺寸的函数，当自定义 View 有特殊的测量需求时，就需要重写这个方法来指定 View 的尺寸。</li><li><code>onLayout()</code>：该函数用于确定 View 中子 View 的位置，通常只有自定义 ViewGroup（如自定义 LinearLayout、RelativeLayout 等）时需要重写它。对于不包含子 View 的自定义 View（例如自定义 TextView），通常不需要重写这个方法。</li><li><code>Canvas</code>（画布）：该类是 Android 系统提供的一个用于绘图的类，它是一个 2D 绘图表面，提供了一系列绘制方法，它的实例通常作为参数传递给<code>onDraw()</code>。Canvas 不仅支持绘制基本图形，还支持矩阵变换（平移、缩放、旋转、倾斜）以及裁剪等操作。</li><li><code>Paint</code>（画笔）：Canvas 仅负责提供绘图方法，而具体的绘制属性（如颜色、线宽、样式等）是由<code>Paint</code>类定义的。当使用 Canvas 绘制时，需要传递一个<code>Paint</code>对象作为参数，以确定绘制的样式和属性。</li><li>坐标系：相比上学时学习的平面直角坐标系（笛卡尔坐标系），Android 坐标系存在以下几点不同：<ul><li>原点位置（0,0）位于屏幕或 View 的左上角；</li><li>x 轴的正方向仍然向右，但是 y 轴的正方向变成了向下；</li><li>笛卡尔坐标系中第四象限的位置变成了第一象限，并且以顺时针方向增加角度，也就是以顺时针的方向定义了第二、三、四象限的位置；</li><li>Android 坐标系中的使用像素（px）作为坐标和尺寸的度量单位。</li></ul></li></ul><p>接下来是一个简单用例，<code>TestView</code>类是一个自定义 View ，它继承了<code>View</code>类并实现了<code>View</code>类的其中一个构造函数，随后在<code>onDraw()</code>进行了绘制：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 自定义 View</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestView</span>(context: Context?, attrs: AttributeSet?) : View(context, attrs) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> paint = Paint(Paint.ANTI_ALIAS_FLAG)  <span class="hljs-comment">// Paint.ANTI_ALIAS_FLAG：开启抗锯齿</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDraw(canvas)<br>        <span class="hljs-comment">// 从 x=100 y=100 到 x=200 y=200 绘制一条直线</span><br>        canvas.drawLine(<span class="hljs-number">100f</span>, <span class="hljs-number">100f</span>, <span class="hljs-number">200f</span>, <span class="hljs-number">200f</span>, paint)<br>        <span class="hljs-comment">// 在屏幕中心绘制一个半径为 200 的圆</span><br>        canvas.drawCircle(<br>            width / <span class="hljs-number">2f</span>,<br>            height / <span class="hljs-number">2f</span>,<br>            TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="hljs-number">50f</span>, resources.displayMetrics),<br>            paint<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中需要解释的就是<code>TypedValue.applyDimension()</code>这个方法，这是一个主要用于将其它尺寸单位转换为像素单位的方法，例如将 dp（密度无关像素）、sp（缩放无关像素）转换为 px 。该方法接收 3 个参数：</p><ul><li><code>int unit</code>：要转换的尺寸单位，如<code>TypedValue.COMPLEX_UNIT_DIP</code>（表示 dp 单位）或<code>TypedValue.COMPLEX_UNIT_SP</code>（表示 sp 单位）等。</li><li><code>float value</code>：要转换的值。</li><li><code>DisplayMetrics metrics</code>：当前设备的显示度量信息，通常可以通过<code>getResources().getDisplayMetrics()</code>方法获得。</li></ul><p>如果需要在程序启动后显示这个 View 的话，可以修改<code>activity_main.xml</code>中的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">com.xuu6770.androidlab.TestView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到，要使用自定义 View 就只需要在布局文件中进行引入即可，这个操作和使用内置的 View 类似。</p><h2 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h2><p><code>Path</code>（路径）表示一组描述图形轮廓的点和线段的集合，通过组合各种线段、曲线和形状，可以创建复杂的图形。<code>Path</code>类通常与<code>Canvas</code>和<code>Paint</code>类一起使用。</p><p>接下来看一个 Path 的用例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestView</span>(context: Context?, attrs: AttributeSet?) : View(context, attrs) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> paint = Paint(Paint.ANTI_ALIAS_FLAG)  <span class="hljs-comment">// Paint.ANTI_ALIAS_FLAG：开启抗锯齿</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> path = Path()  <span class="hljs-comment">// 创建一个空的 Path 对象</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDraw(canvas)<br>        canvas.drawPath(path, paint)<br>    &#125;<br><br>    <span class="hljs-comment">// 重写该方法，该方法会在 View 的大小改变时调用</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSizeChanged</span><span class="hljs-params">(w: <span class="hljs-type">Int</span>, h: <span class="hljs-type">Int</span>, oldw: <span class="hljs-type">Int</span>, oldh: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onSizeChanged(w, h, oldw, oldh)<br>        path.reset()<br>        path.addCircle(<br>            width / <span class="hljs-number">2f</span>,<br>            height / <span class="hljs-number">2f</span>,<br>            TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="hljs-number">50f</span>, resources.displayMetrics),<br>            Path.Direction.CW<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码运行的效果同样是在屏幕中间绘制了一个圆，只不过区别于前一个例子，绘制圆的参数是定义在 Path 中的，而这个过程又是编写在了<code>onSizeChanged()</code>中，而不是在<code>onDraw()</code>中，这是因为<code>onDraw()</code>会被频繁调用，而<code>onSizeChanged()</code>只会在 View 的大小改变时调用，而绘制时需要提供的 x 坐标和 y 坐标参数也与 View 的大小（宽和高）有关。</p><p>需要注意的是<code>addCircle()</code>中的第四个参数<code>Path.Direction.CW</code>，这个参数用于指定绘制的方向，<code>CW</code>表示顺时针，逆时针则用<code>CCW</code>表示。例如在图形重叠时，绘制的方向一定程度上决定了图形重叠的部分该如何填充。来看这个用例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 省略重复代码</span><br><br><span class="hljs-comment">// 将半径单独定义出来，方便复用</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> radius =<br>    TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="hljs-number">50f</span>, resources.displayMetrics)<br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSizeChanged</span><span class="hljs-params">(w: <span class="hljs-type">Int</span>, h: <span class="hljs-type">Int</span>, oldw: <span class="hljs-type">Int</span>, oldh: <span class="hljs-type">Int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onSizeChanged(w, h, oldw, oldh)<br>    path.reset()<br>    path.addCircle(<br>        width / <span class="hljs-number">2f</span>,<br>        height / <span class="hljs-number">2f</span>,<br>        radius,<br>        Path.Direction.CCW<br>    )<br>    <span class="hljs-comment">// 以圆的下半部分为起点绘制了一个矩形</span><br>    path.addRect(<br>        width / <span class="hljs-number">2f</span> - radius,<br>        height / <span class="hljs-number">2f</span>,<br>        width / <span class="hljs-number">2f</span> + radius,<br>        height / <span class="hljs-number">2f</span> + <span class="hljs-number">2</span> * radius,<br>        Path.Direction.CW<br>    )<br>&#125;<br><br><span class="hljs-comment">// 省略重复代码</span><br></code></pre></td></tr></table></figure><p>上面的代码在原来的基础上多绘制了一个矩形，这个矩形与圆的下半部分重叠，如果两个图形的绘制方向的参数一致的话，那么默认情况下重叠部分也会被填充，而一旦不一样，就不会填充。之所以说是默认情况，是因为是否填充还与<code>Path</code>对象的<code>fillType</code>属性相关，该属性有 4 个可选值：</p><ul><li><code>Path.FillType.WINDING</code>（非零环绕数规则）：默认值。个人理解，简单来说，就是在一个封闭区域内任意取一个点，以这个点水平向右做一条射线，射线与其它图形相交时，若该图形的绘制方向为顺时针，则计数器加 1 ，否则减 1 ，最终如果计数器的值不为 0 ，则表示该封闭区域在路径内部，需要被填充。</li><li><code>Path.FillType.INVERSE_WINDING</code>（反向非零环绕数规则）：与<code>Path.FillType.WINDING</code>相反，顺时针减 1 ，逆时针加 1 。</li><li><code>Path.FillType.EVEN_ODD</code>（奇偶规则）：个人理解，该规则同样是在一个封闭区域内任意取一个点，以这个点水平向右做一条射线，计数器在每次射线与图形相交时加 1 ，最终如果交点个数为偶数，则表示该封闭区域在路径外部，否则在内部，需要被填充。</li><li><code>Path.FillType.INVERSE_EVEN_ODD</code>（反向奇偶规则）：与<code>Path.FillType.EVEN_ODD</code>相反，如果交点个数为偶数，则该点在路径内部，否则在外部。</li></ul><p>当<code>fillType</code>属性取默认值时，图像的绘制方向将参与到是否要填充的决定当中，而当属性取奇偶规则时，则不关心绘制方向。</p><h2 id="绘制仪表盘"><a href="#绘制仪表盘" class="headerlink" title="绘制仪表盘"></a>绘制仪表盘</h2><p>接下来通过绘制一个类似于汽车的仪表盘的图形来练练手。</p><h3 id="仪表盘轮廓"><a href="#仪表盘轮廓" class="headerlink" title="仪表盘轮廓"></a>仪表盘轮廓</h3><p>先绘制一个圆弧：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestView</span>(context: Context?, attrs: AttributeSet?) : View(context, attrs) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> paint = Paint(Paint.ANTI_ALIAS_FLAG).apply &#123;<br>        style = Paint.Style.STROKE<br>        strokeWidth = <span class="hljs-number">3f</span>.px<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> openAngle = <span class="hljs-number">120f</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDraw(canvas)<br>        canvas.drawArc(<br>            width / <span class="hljs-number">2f</span> - <span class="hljs-number">150f</span>.px,<br>            height / <span class="hljs-number">2f</span> - <span class="hljs-number">150f</span>.px,<br>            width / <span class="hljs-number">2f</span> + <span class="hljs-number">150f</span>.px,<br>            height / <span class="hljs-number">2f</span> + <span class="hljs-number">150f</span>.px,<br>            <span class="hljs-number">90</span> + openAngle / <span class="hljs-number">2</span>,<br>            <span class="hljs-number">360</span> - openAngle,<br>            <span class="hljs-literal">false</span>,<br>            paint<br>        )<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为 Float 类型的数据定义一个扩展属性，将这个值的 dp 单位转换为 px 并返回</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">val</span> <span class="hljs-built_in">Float</span>.px<br>    <span class="hljs-keyword">get</span>() = TypedValue.applyDimension(<br>        TypedValue.COMPLEX_UNIT_DIP,<br>        <span class="hljs-keyword">this</span>,<br>        Resources.getSystem().displayMetrics<br>    )<br></code></pre></td></tr></table></figure><p>在上面的代码中，首先在对 Paint 对象初始化完成以后，设置了它的<code>style</code>属性，该属性接收一个<code>Paint.Style</code>枚举类，该类有 3 个可选值：</p><ul><li><code>Paint.Style.FILL</code>：绘制几何形状时，填充其内部区域，而不绘制轮廓线条。</li><li><code>Paint.Style.STROKE</code>：绘制几何形状轮廓时，只绘制轮廓线条，而不填充内部区域。</li><li><code>Paint.Style.FILL_AND_STROKE</code>：同时填充内部区域并绘制轮廓线条。</li></ul><p>在代码中传入了第二个参数，又因为不填充，所以需要设置<code>strokeWidth</code>这个属性（代表轮廓线条的宽度），否则看不到图形。这里的<code>3f.px</code>使用了 Kotlin 的扩展属性，并把前面将 dp 单位转 px 单位的逻辑抽了出来。最后就是使用<code>drawArc()</code>绘制一个弧线，该函数有多个重载，但传递的都是必要的参数。比如必须要有一个 RectF 对象用来限定绘制区域，在上面的代码中是通过传递矩形的四个顶点的坐标来“创建”一个 RectF 对象的。接下来的第五、六个参数则代表了圆弧的起始角度和旋转角度，这里的计算涉及到最开始提到的坐标系，<code>90 + openAngle / 2</code>的值为 150° ，是个钝角，最终定位在第二象限（左下角）。旋转（顺时针）了<code>360 - openAngle</code>也就是 240° 最终停留在第一象限（右下角）。最后传入的<code>false</code>和<code>paint</code>，前者代表了是否绘制弧线的两端点和中心点之间的连线，后者就是绘制用的 Paint 对象。</p><h3 id="刻度"><a href="#刻度" class="headerlink" title="刻度"></a>刻度</h3><p>在原来的基础上进行改动：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestView</span>(context: Context?, attrs: AttributeSet?) : View(context, attrs) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> openAngle = <span class="hljs-number">120f</span>  <span class="hljs-comment">// 仪表盘底部的开口角度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> scaleWidth = <span class="hljs-number">3f</span>.px  <span class="hljs-comment">// 刻度的宽度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> scaleLength = <span class="hljs-number">15f</span>.px  <span class="hljs-comment">// 刻度的高度</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> path = Path()  <span class="hljs-comment">// 改用 Path 来绘制圆弧</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> pathDashEffect: PathDashPathEffect  <span class="hljs-comment">// 延迟初始化一个路径特效</span><br><br>    <span class="hljs-comment">// 使用 Path 来绘制刻度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> scale = Path().apply &#123;<br>        addRect(<span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>, scaleWidth, scaleLength, Path.Direction.CW)<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> paint = Paint(Paint.ANTI_ALIAS_FLAG).apply &#123;<br>        style = Paint.Style.STROKE<br>        strokeWidth = <span class="hljs-number">3f</span>.px<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDraw(canvas)<br>        <span class="hljs-comment">// 画弧</span><br>        canvas.drawPath(path, paint)<br><br>        <span class="hljs-comment">// 应用特效</span><br>        paint.pathEffect = pathDashEffect<br><br>        <span class="hljs-comment">// 使用特效画出刻度</span><br>        canvas.drawPath(path, paint)<br><br>        <span class="hljs-comment">// 取消特效</span><br>        paint.pathEffect = <span class="hljs-literal">null</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSizeChanged</span><span class="hljs-params">(w: <span class="hljs-type">Int</span>, h: <span class="hljs-type">Int</span>, oldw: <span class="hljs-type">Int</span>, oldh: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onSizeChanged(w, h, oldw, oldh)<br>        path.reset()<br>        path.addArc(<br>            width / <span class="hljs-number">2f</span> - <span class="hljs-number">150f</span>.px,<br>            height / <span class="hljs-number">2f</span> - <span class="hljs-number">150f</span>.px,<br>            width / <span class="hljs-number">2f</span> + <span class="hljs-number">150f</span>.px,<br>            height / <span class="hljs-number">2f</span> + <span class="hljs-number">150f</span>.px,<br>            <span class="hljs-number">90</span> + openAngle / <span class="hljs-number">2</span>,<br>            <span class="hljs-number">360</span> - openAngle<br>        )<br>        <span class="hljs-keyword">val</span> pathMeasure = PathMeasure(path, <span class="hljs-literal">false</span>)<br>        pathDashEffect =<br>            PathDashPathEffect(<br>                scale,<br>                (pathMeasure.length - scaleWidth) / <span class="hljs-number">20f</span>,  <span class="hljs-comment">// 假设要画 21 个刻度</span><br>                <span class="hljs-number">0f</span>,<br>                PathDashPathEffect.Style.ROTATE<br>            )<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 省略 val Float.px</span><br></code></pre></td></tr></table></figure><p>主要有以下几点改动：</p><ul><li>原来是采用<code>Canvas.drawArc()</code>来绘制圆弧，现在采用 Path 来绘制，这是因为只有这样，才能使用 PathMeasure 来对其进行测量。因为绘制圆弧涉及到 View 的宽度和高度，所以还是将绘制的具体操作放在了<code>onSizeChanged()</code>中。</li><li>接下来定义了一个<code>PathDashPathEffect</code>对象，<code>PathDashPathEffect</code>是<code>PathEffect</code>的一个子类，用于在路径上重复绘制一个子路径，通过这样的操作来达到某种“效果”或者是“特效”。</li><li>接下来同样是创建了一个 Path 对象，并向其中添加了矩形，用来表示刻度。</li><li>接下来在<code>onDraw()</code>中将<code>drawArc()</code>改为<code>drawPath()</code>来绘制弧，随后调用了 Paint 对象的<code>pathEffect</code>属性来为其设置一个路径特效，然后在拥有了特效的情况下再画一个弧（画出来的是一圈的刻度），最后将<code>pathEffect</code>属性的值置为<code>null</code>。Paint 对象的<code>pathEffect</code>属性用于指定绘制路径时的效果，设置属性时需要传递一个<code>PathEffect</code>参数，常用的 PathEffect 类型包括：<ul><li><code>DashPathEffect</code>：用于创建虚线效果。构造函数接收两个参数：一个表示虚线段长度的数组和一个表示虚线段起始位置的偏移量。数组中的值应该成对出现，例如第一个值表示实线部分的长度，第二个值表示间隙部分的长度，以此类推。</li><li><code>CornerPathEffect</code>：用于将路径中的锐角变成圆角。构造函数接收一个参数，表示圆角的半径。</li><li><code>DiscretePathEffect</code>：用于将路径分割成多个小段，并对每个小段进行随机偏移。构造函数接收两个参数：一个表示每段的平均长度，一个表示偏移量的最大值。可以用于创建类似于细鱼网的效果。</li><li><code>PathDashPathEffect</code>：用于在路径上重复绘制一个子路径。这个类接受一个 Path 对象作为子路径，以及一个表示子路径之间间距的值。</li><li><code>ComposePathEffect</code>：用于组合两个 PathEffect ，使它们在同一个路径上按顺序作用。构造函数接收两个 PathEffect 对象作为参数。</li><li><code>SumPathEffect</code>：用于同时应用两个 PathEffect 到同一个路径上。这个类接受两个 PathEffect 对象作为参数。</li></ul></li></ul><p>接下来是最关键的<code>onSizeChanged()</code>的重写，首先是<code>PathMeasure</code>：</p><ul><li><code>PathMeasure</code>是一个用于测量路径的类，其主要功能是对 Path 对象的长度、分割点、切线等几何信息的计算和获取。主要的函数有以下几个:<ul><li><code>PathMeasure(Path path, boolean forceClosed)</code>：构造函数，其中<code>path</code>为要测量的 Path 对象，<code>forceClosed</code>代表是否要强制将路径进行闭合。</li><li><code>getLength()</code>：返回关联路径的总长度。</li><li><code>getPosTan(float distance, float[] pos, float[] tan)</code>：获取路径上指定距离的点的位置和切线。第一个参数为路径上的距离，第二个参数为长度为 2 的数组，用于存储路径上指定距离的点的 x 和 y 坐标。如果不需要这个值，可以传入<code>null</code>。第三个参数也是长度为 2 的数组，用于存储路径上指定距离的点的切线的 x 和 y 分量。如果不需要这个值，可以传入<code>null</code>，该函数本身则返回一个布尔值。</li></ul></li><li>然后是对前面定义的 PathDashPathEffect 对象进行初始化，构造函数接收 4 个参数：<ul><li><code>Path shape</code>：这是一个子路径，表示要沿着路径重复绘制的形状，这个形状可以是线段、圆形、矩形等。</li><li><code>float advance</code>：由于是重复绘制，所以这个值代表了重复绘制之间的间距。如果这个值比子路径的长度大，那么在重复绘制的时候，图形之间会有间隙；如果这个值比子路径的长度小，那么图形就会发生重叠。</li><li><code>float phase</code>：这是子路径的起始位置偏移量。通过改变这个值，可以控制子路径在路径上的起始位置。如果这个值为 0，则第一个子路径将从路径的起点开始绘制。增加这个值将使子路径沿着路径移动。</li><li><code>PathDashPathEffect.Style style</code>：这是用于控制子路径与原路径相交时的表现方式的枚举值，包含三个可选值：<ul><li><code>Style.TRANSLATE</code>：子路径会平移，使其与原路径相交。</li><li><code>Style.ROTATE</code>：子路径会旋转，使其与原路径的切线对齐。</li><li><code>Style.MORPH</code>：子路径会变形，使其与原路径相交，并沿着原路径的曲率变化。</li></ul></li></ul></li></ul><p>参照以上函数的说明和参数的意义，代码将变得好理解，唯一还需要解释的就是 PathDashPathEffect 构造函数中的第二个参数<code>(pathMeasure.length - scaleWidth) / 20f</code>。这个参数首先通过<code>pathMeasure.length</code>拿到被测量的 Path 对象的长度，然后减去一个刻度的宽度，再分成 20 份，每一份的长度就是每个刻度之间的间距，这里要注意，每一份的长度实际上包括了刻度本身的宽度在里面，这也是为什么上面说“值比子路径的长度大，那么在重复绘制的时候，图形之间会有间隙；如果这个值比子路径的长度小，那么图形就会发生重叠”。这 20 份长度，每一份的头都会连着前一份的尾，这样一来，第 21 个刻度所在的位置，就是第 20 份刻度的尾巴，这就保证了圆弧的最尾巴的位置会始终有一个刻度，这样绘制出来的仪表盘就更像现实中的仪表盘。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>加上绘制指针后的完整代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestView</span>(context: Context?, attrs: AttributeSet?) : View(context, attrs) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> openAngle = <span class="hljs-number">120f</span>  <span class="hljs-comment">// 仪表盘底部的开口角度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> scaleWidth = <span class="hljs-number">3f</span>.px  <span class="hljs-comment">// 刻度的宽度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> scaleLength = <span class="hljs-number">15f</span>.px  <span class="hljs-comment">// 刻度的高度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> needleLength = <span class="hljs-number">120f</span>.px  <span class="hljs-comment">// 仪表盘指针长度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> pointTo = <span class="hljs-number">10</span>  <span class="hljs-comment">// 指针指向的刻度（不包括起始刻度）</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> path = Path()  <span class="hljs-comment">// 改用 Path 来绘制圆弧</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> pathDashEffect: PathDashPathEffect  <span class="hljs-comment">// 延迟初始化一个路径特效</span><br><br>    <span class="hljs-comment">// 使用 Path 来绘制刻度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> scale = Path().apply &#123;<br>        addRect(<span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>, scaleWidth, scaleLength, Path.Direction.CW)<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> paint = Paint(Paint.ANTI_ALIAS_FLAG).apply &#123;<br>        style = Paint.Style.STROKE<br>        strokeWidth = <span class="hljs-number">3f</span>.px<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDraw(canvas)<br>        <span class="hljs-comment">// 画弧</span><br>        canvas.drawPath(path, paint)<br><br>        <span class="hljs-comment">// 应用特效</span><br>        paint.pathEffect = pathDashEffect<br><br>        <span class="hljs-comment">// 使用特效画出刻度</span><br>        canvas.drawPath(path, paint)<br><br>        <span class="hljs-comment">// 取消特效</span><br>        paint.pathEffect = <span class="hljs-literal">null</span><br><br>        <span class="hljs-comment">// 画指针</span><br>        canvas.drawLine(<br>            width / <span class="hljs-number">2f</span>,<br>            height / <span class="hljs-number">2f</span>,<br>            (width / <span class="hljs-number">2f</span> + needleLength * cos(Math.toRadians((<span class="hljs-number">90</span> + openAngle / <span class="hljs-number">2f</span> + (<span class="hljs-number">360</span> - openAngle) / <span class="hljs-number">20f</span> * pointTo).toDouble()))).toFloat(),<br>            (height / <span class="hljs-number">2f</span> + needleLength * sin(Math.toRadians((<span class="hljs-number">90</span> + openAngle / <span class="hljs-number">2f</span> + (<span class="hljs-number">360</span> - openAngle) / <span class="hljs-number">20f</span> * pointTo).toDouble()))).toFloat(),<br>            paint<br>        )<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSizeChanged</span><span class="hljs-params">(w: <span class="hljs-type">Int</span>, h: <span class="hljs-type">Int</span>, oldw: <span class="hljs-type">Int</span>, oldh: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onSizeChanged(w, h, oldw, oldh)<br>        path.reset()<br>        path.addArc(<br>            width / <span class="hljs-number">2f</span> - <span class="hljs-number">150f</span>.px,<br>            height / <span class="hljs-number">2f</span> - <span class="hljs-number">150f</span>.px,<br>            width / <span class="hljs-number">2f</span> + <span class="hljs-number">150f</span>.px,<br>            height / <span class="hljs-number">2f</span> + <span class="hljs-number">150f</span>.px,<br>            <span class="hljs-number">90</span> + openAngle / <span class="hljs-number">2</span>,<br>            <span class="hljs-number">360</span> - openAngle<br>        )<br>        <span class="hljs-keyword">val</span> pathMeasure = PathMeasure(path, <span class="hljs-literal">false</span>)<br>        pathDashEffect =<br>            PathDashPathEffect(<br>                scale,<br>                (pathMeasure.length - scaleWidth) / <span class="hljs-number">20f</span>,<br>                <span class="hljs-number">0f</span>,<br>                PathDashPathEffect.Style.ROTATE<br>            )<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为 Float 类型的数据定义一个扩展属性，将这个值的 dp 单位转换为 px 并返回</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">val</span> <span class="hljs-built_in">Float</span>.px<br>    <span class="hljs-keyword">get</span>() = TypedValue.applyDimension(<br>        TypedValue.COMPLEX_UNIT_DIP, <span class="hljs-keyword">this</span>, Resources.getSystem().displayMetrics<br>    )<br></code></pre></td></tr></table></figure><p>首先添加了两个变量<code>needleLength</code>和<code>pointTo</code>，重点还是来看在<code>onDraw()</code>中的改动。在<code>onDraw()</code>使用<code>Canvas.drawLine()</code>来绘制直线，该函数的前两个参数就是起始点的横纵坐标，后两个参数是终点的横纵坐标。起点的横纵坐标其实就是仪表盘的中心也就是 View 的中心，而终点的横纵坐标的计算则涉及到三角函数。</p><p>参与三角函数运算的参数有三个，分别是一个角度和两条边，其中一条边就是斜边（指针长度），只要把角度算出来，就可以通过这两个已知量算出第三个值，也就是算出对边（纵坐标的值）或者临边（横坐标的值）。</p><p>角度的计算也不算难，由于仪表盘始于第二象限，所以第一象限 90° 是固定死的了，然后加上仪表盘开口角度的一半等于仪表盘起始位置的角度。然后再将仪表盘转过的角度除以 20 得到一个刻度的度数，最后再乘以需要指向的刻度，将得到的角度加上仪表盘起始位置的角度等于最终的角度。</p><p>有了角度和斜边长度，就可以通过 Kotlin 中的<code>cos()</code>来计算临边的长度，通过<code>sin()</code>来计算对边的长度。需要注意的是这两个函数接收的参数的单位是“弧度制”，而前面一系列的计算得到的值的单位是角度制，所以还需要通过调用<code>toRadians()</code>来将其转换为弧度制。</p><h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><p>绘制少量简单图形时可以直接用 Canvas 的各种 draw 函数，当需要绘制复杂图形的时候可以考虑使用 Path ，因为有 Path 才能使用 PathMeasure 进行测量，并且 Path 在一处被定义了以后，可以通过<code>Canvas.drawPath()</code>重复调用来达到代码复用的目的。</p><p>三角函数在计算坐标时似乎很常用，在已知起点坐标的情况下，通过角度和三角函数，便可以得到终点的横纵坐标。</p><h2 id="绘制饼图"><a href="#绘制饼图" class="headerlink" title="绘制饼图"></a>绘制饼图</h2><p>绘制一个简单的饼图没有仪表盘那么复杂：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PieView</span>(context: Context, attrs: AttributeSet?) : View(context, attrs) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> radius = <span class="hljs-number">150f</span>.px<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> paint = Paint(Paint.ANTI_ALIAS_FLAG)<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> angles = floatArrayOf(<span class="hljs-number">30f</span>, <span class="hljs-number">60f</span>, <span class="hljs-number">120f</span>, <span class="hljs-number">150f</span>)  <span class="hljs-comment">// 定义一组角度</span><br><br>    <span class="hljs-comment">// 定义一组颜色</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> colors = listOf(<br>        Color.parseColor(<span class="hljs-string">&quot;#FF3333&quot;</span>),<br>        Color.parseColor(<span class="hljs-string">&quot;#E5FFCC&quot;</span>),<br>        Color.parseColor(<span class="hljs-string">&quot;#9999FF&quot;</span>),<br>        Color.parseColor(<span class="hljs-string">&quot;#99004C&quot;</span>)<br>    )<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDraw(canvas)<br>        <span class="hljs-keyword">var</span> startAngle = <span class="hljs-number">0f</span>  <span class="hljs-comment">// 定义起始角度</span><br>        <span class="hljs-keyword">for</span> ((index, angle) <span class="hljs-keyword">in</span> angles.withIndex()) &#123;<br>            paint.color = colors[index]<br>            canvas.drawArc(<br>                width / <span class="hljs-number">2f</span> - radius,<br>                height / <span class="hljs-number">2f</span> - radius,<br>                width / <span class="hljs-number">2f</span> + radius,<br>                height / <span class="hljs-number">2f</span> + radius,<br>                startAngle,<br>                angle,<br>                <span class="hljs-literal">true</span>,<br>                paint<br>            )<br>            startAngle += angle  <span class="hljs-comment">// 更新起始角度</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释：</p><ul><li>这里把<code>150f.px</code>单独作为一个变量提取出来，方便复用和修改。同时复用了前面的<code>Float.px</code>这个扩展属性，只是上面的代码没写。</li><li>增加了两个新变量，分别是一组角度和一组颜色，对应饼图中的每块区域。</li><li>在<code>onDraw()</code>使用<code>Canvas.drawArc()</code>来绘制饼图，因为饼图本质上是由多个圆弧组成的一个完整的圆，其本身并不是一个圆，所以不应该使用<code>drawCircle()</code>。</li><li>因为需要画 4 块扇形，所以这里使用了循环语句来进行重复绘制操作。关于 Kotlin 中循环语句的语法，这里不多阐述。</li><li>使用<code>Canvas.drawArc()</code>来绘制每一块“饼”，其中第五和第六个参数代表弧的起始角度和结束角度，第七个参数<code>useCenter</code>是一个布尔类型的参数，用于指定绘制的弧形是否包含圆心。当这个值为<code>true</code>时，绘制的弧形会包含圆心，也就是从圆心开始绘制弧形。这时候，绘制的图形是一个扇形。否则绘制的弧形不会包含圆心，也就是从圆的边缘开始绘制弧形。这时候，绘制的图形是一个弧线。</li></ul><h3 id="位置偏移"><a href="#位置偏移" class="headerlink" title="位置偏移"></a>位置偏移</h3><p>在某些炫酷的图表库当中，当选中饼图当中的某块扇形区域时，该区域会向后偏移并高亮，这里记录以一下如何实现简单的图形偏移：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> offset = <span class="hljs-number">30f</span>.px  <span class="hljs-comment">// 图形偏移量</span><br>    <br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onDraw(canvas)<br>    <span class="hljs-keyword">var</span> startAngle = <span class="hljs-number">0f</span><br>    <span class="hljs-keyword">for</span> ((index, angle) <span class="hljs-keyword">in</span> angles.withIndex()) &#123;<br>        paint.color = colors[index]<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">1</span>) &#123;<br>            canvas.save()<br>            canvas.translate(<br>                (offset * cos(Math.toRadians((startAngle + angle / <span class="hljs-number">2f</span>).toDouble()))).toFloat(),<br>                (offset * sin(Math.toRadians((startAngle + angle / <span class="hljs-number">2f</span>).toDouble()))).toFloat()<br>            )<br>        &#125;<br>        canvas.drawArc(<br>            width / <span class="hljs-number">2f</span> - radius,<br>            height / <span class="hljs-number">2f</span> - radius,<br>            width / <span class="hljs-number">2f</span> + radius,<br>            height / <span class="hljs-number">2f</span> + radius,<br>            startAngle,<br>            angle,<br>            <span class="hljs-literal">true</span>,<br>            paint<br>        )<br>        startAngle += angle<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">1</span>) &#123;<br>            canvas.restore()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码仅对第二个扇形（下标为 1 ）进行了偏移，绘制图形前保存了 Canvas 的状态并设置了偏移量，绘制完成后恢复了 Canvas 的状态。计算偏移后的坐标时同样用到了三角函数，偏移的方向为扇形张开角度的一半。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2023 年 4 月 2 日</title>
    <link href="/post/2023-04-02/"/>
    <url>/post/2023-04-02/</url>
    
    <content type="html"><![CDATA[<p>今天连续玩了五个半小时，把 Subverse 最近的两个主线更新推完了。</p><span id="more"></span><p>先来看一下主线的更新时间：</p><ul><li>SOVA 的主线故事（Version 0.5.0 STORY UPDATE (7&#x2F;25&#x2F;22)）</li><li>FORTUNE 的主线故事（Version 0.6.0 STORY UPDATE (12&#x2F;19&#x2F;22)），距上次更新过去了五个月</li><li>HUNTRESS 的主线故事（Version 0.7.0 STORY UPDATE (3&#x2F;27&#x2F;23)），距上次更新过去了三个月</li></ul><p>刚好周末，就打算把 FORTUNE 和 HUNTRESS 更新的内容体验一下，总的来说这两次内容更新令人满意。</p><h2 id="FORTUNE"><a href="#FORTUNE" class="headerlink" title="FORTUNE"></a>FORTUNE</h2><p>之所以 FORTUNE 的更新一直拖着没玩，是因为其实我不太喜欢这个 Waifu ，如果用下体来解释，就是因为她不够戳我的性癖，因为我还是更喜欢像 LILY 和 KILLI 那样的御姐！但是当我今天在主线中开始接触她后我突然发觉她也还是个不错的女孩儿。如果用大脑来解释，那就是她的角色性格和能力吸引了我：年纪轻轻，就拥有高超的黑客技巧，为了大家能够按自己的方式生活而奋起反抗 Imperium 。主线剧情中也提到了她的出身，以及是谁把她养大的，就是这样与众不同的经历，才造就了今天的她，就是因为这样的她，才会深受大家喜爱。之前在 Twitter 上看到大家都在催更 FORTUNE 主线的时候我还不是很理解，但是现在我只想说：「马头社你做得好啊！」</p><h2 id="HUNTRESS"><a href="#HUNTRESS" class="headerlink" title="HUNTRESS"></a>HUNTRESS</h2><p>另外一个新 Waifu 就是 HUNTRESS ，作为频繁来找我们麻烦的赏金猎人，HUNTRESS 到底能不能被我们攻略，剧情到底要怎么反转，我还挺期待的。虽然这样的游戏不需要太过于在意剧情的合理性（就像少年热血漫画一样），但是马头社还是交出了不错的答卷。具体来说就是利用了「种族文化」的设定，再具体一点来说就是 HUNTRESS 和我们进行了两次决斗，两次都输了，并且我们两次都选择 spared her life ，这样的 mercy 对她们的种族来说是需要以身相许的哈哈哈哈哈。可以说真的是很烂的套路，但是也不会说很离谱，我觉得大家都很喜欢，至少我很喜欢，这样的结局和设定真的很合适哈哈哈哈。</p><h2 id="新的潘多拉场景"><a href="#新的潘多拉场景" class="headerlink" title="新的潘多拉场景"></a>新的潘多拉场景</h2><p>看完剧情以后，我确实喜欢上这两位 Waifus 了，而这两次更新带来的色色内容也还是一如既往的高观赏性和高实用性（确实实用，在昨晚冲了一次的情况下，今天还能靠这个在一天之内又冲了两次）。不过值得一提的是在这两位的招募 scene 之前有一小段过场动画，这段过场动画不仅在对话和开始本番之间做了一个很好的过渡，而且也能让玩家更好地代入进去。我记得之前的角色好像是没有这样的动画的……总之这个过渡真的很加分，彷佛 FORTUNE 就是我亲手抱上床的，然后 HUNTRESS 真的是在和我互动一样。</p><p>此外通过剧情，我感觉到 FORTUNE 和 HUNTRESS 这两位 Waifus 比起前面的 Waifus 来说会更「守规矩」，通俗来说就是不会乱搞，FORTUNE 的出身和她的成长环境以及她的理想让我感觉她顶多就是手冲多一些。而 HUNTRESS 的话她自己也说了，再找到自己的 equal 前是不会 mate 的。只能说这样的设定让纯爱战士狂喜，这种纯爱也多少治愈了一点这几天的坏心情吧。</p><h2 id="展现真正的技术"><a href="#展现真正的技术" class="headerlink" title="展现真正的技术"></a>展现真正的技术</h2><p>说实话战棋玩法的规则我不是很懂，太空战斗也是真的对手残党很不友好（尤其是今天玩的时候，我明显感觉到整体难度提升了好多），所以刚开始玩这游戏的时候经常血压飙升。但是说到底这是个单机游戏，怎么说咱们也是个学软件的，不应该被单机游戏搞得如此狼狈，技术不够，科技来凑！修改器启动，无限生命无限能量——一个需要技巧的游戏瞬间变成了割草游戏。不过虽然通关变得轻松了，但是想要获得只有通过提升角色的 devotion 才能获得的用来解锁潘多拉场景的点数，还是需要频繁地刷关卡，有什么办法能把这个点数的值修改一下呢？Cheat Engine 启动！</p><p>说起来前段时间看到的用 Cheat Engine 修改百度网盘下载速度的案例也是够抽象的了。还有就是用 Cheat Engine 来修改《卧龙：苍天陨落》女性角色捏脸时的胸部大小参数，尽管这个参数的值有上限，但是就算在 Cheat Engine 里设置了超过上限的值，在游戏中还是会生效，那个胸真的变得超大哈哈哈哈。</p><h2 id="后续呢"><a href="#后续呢" class="headerlink" title="后续呢"></a>后续呢</h2><p>到现在为止，仍然未被攻略的女角色至少有 3 个，一个是之前的上司吧，另外两个都是帝国那边的角色，其中一个是老阿姨 KASIDORA （老太婆了我感觉其实），还有一个是也是非常戳我性癖的 CELESTINA（182 cm 的身高我真的爱了家人们谁懂啊）。不过刚才特地到官网看了一下，还有一个女角色是一直记录在案并且也决定了声优但是一直未在游戏中露面的 FOWCHAN ，不知道下一次的更新会不会登场。</p><p>总而言之，真的很享受这两次更新的内容（甚至都有点想去 Twitter 上给他们发个评论表扬一下了），同时也很期待下次的更新。只不过我对剧情的理解还是模模糊糊的，主要还是因为全英文吧，生词多俚语多，甚至有时候出现了某个我认识的单词的变体（变形容词、变否定形式）搞得一瞬间我没看懂，然后一查词一看词根才发现：「噢，原来是它啊」，此外还有很多句式和用法也搞不懂，甚至可能玩了梗我也不知道……总之英语的学习还是不能停止啊。</p><p><img src="/../../images/ACGN/allMyWaifus.jpg" alt="All my waifus"></p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>了解 Fragment</title>
    <link href="/post/Android-Study-Guide-Fragment/"/>
    <url>/post/Android-Study-Guide-Fragment/</url>
    
    <content type="html"><![CDATA[<p>开发者文档中 Fragment 的内容还挺多的，加上现在其实也不急着学这个，所以这里就记录最基本的部分好了。</p><span id="more"></span><h2 id="使用-Fragment"><a href="#使用-Fragment" class="headerlink" title="使用 Fragment"></a>使用 Fragment</h2><p>Fragment 表示应用界面中可重复使用的一部分，是一种可以嵌入在 Activity 当中的 UI 片段，具有自己的生命周期，并且可以处理自己的输入事件。<strong>Fragment 不能独立存在</strong>，而是必须由 Activity 或另一个 Fragment 托管。Fragment 的视图层次结构会成为宿主的视图层次结构的一部分，或附加到宿主的视图层次结构中。</p><p>一般情况下，Fragment 需要被内嵌到<code>FragmentActivity</code>类或者是它的子类当中。例如，可以在<code>MainActivity</code>的布局中嵌入 Fragment ，是因为<code>MainActivity</code>继承自<code>AppCompatActivity</code>，而<code>AppCompatActivity</code>又继承自<code>FragmentActivity</code>类。</p><p>添加 Fragment 一般有两种方式：</p><ul><li>在布局文件中使用<code>&lt;fragment&gt;</code>标签，然后在标签内填入需要嵌入的 Fragment 的完整类名（包括包名）。</li><li>使用 Fragment 容器，例如<code>&lt;FragmentContainerView&gt;</code>：先在布局文件中使用<code>&lt;FragmentContainerView&gt;</code>标签，然后在 Activity 中通过代码的方式将 Fragment 添加进去。</li></ul><p><code>&lt;FragmentContainerView&gt;</code>被强烈推荐使用，因为其包含了对 Fragment 的优化，这些优化是其它布局例如<code>FrameLayout</code>所没有的。甚至还可以用<code>&lt;FragmentContainerView&gt;</code>代替<code>&lt;fragment&gt;</code>。</p><h3 id="直接嵌入"><a href="#直接嵌入" class="headerlink" title="直接嵌入"></a>直接嵌入</h3><p>首先来看个简单的例子：如何将两个 Fragment 嵌入一个 Activity 中，并且这两个 Fragment 各占据一半屏幕。</p><p>左半部分的 Fragment 的 XML 部分，使用线性布局，背景设置为了红色，包含了一个文本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#FF4500&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.LeftFragment&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Left Fragment&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>右半部分的 Fragment 的 XML 部分，使用线性布局，背景设置为了蓝色，包含了一个按钮：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#4876FF&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.RightFragment&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/rightFragBt&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;BUTTON&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Activity 的 XML 部分，需要注意的内容写在了注释中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;horizontal&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    * 使用 fragment 标签引入 Fragment ，对于要引入的 Fragment ，需要用 name 属性准确指定类名，包括包名</span><br><span class="hljs-comment">    * layout_width=&quot;0dp&quot; 需要和 layout_weight=&quot;1&quot; 搭配使用</span><br><span class="hljs-comment">    * 使用 layout_weight=&quot;1&quot; 属性的控件需要被包含在 LinearLayout 中</span><br><span class="hljs-comment">    * 必须要给 Fragment 添加 id ，否则运行报错</span><br><span class="hljs-comment">    * 可以使用 class 属性代替 android:name</span><br><span class="hljs-comment">    --&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">fragment</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/leftFrag&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.risingsun.androidlab.LeftFragment&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">fragment</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/rightFrag&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.risingsun.androidlab.RightFragment&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着需要重写两个 Fragment 类中的<code>onCreateView()</code>，通过<code>inflate()</code>将布局返回：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    inflater: <span class="hljs-type">LayoutInflater</span>, container: <span class="hljs-type">ViewGroup</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">    savedInstanceState: <span class="hljs-type">Bundle</span>?</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: View? &#123;<br>    <span class="hljs-comment">// Inflate the layout for this fragment</span><br>    <span class="hljs-keyword">return</span> inflater.inflate(R.layout.fragment_right, container, <span class="hljs-literal">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>剩下的什么都不用修改，运行程序就能看到效果，还不错。</p><p>如果想要以最简单的方式创建一个 Fragment ，只需要将该 Fragment 的布局文件作为参数传入继承的<code>Fragment</code>类的构造函数中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlankFragment</span> : <span class="hljs-type">Fragment</span>(R.layout.fragment_blank)<br></code></pre></td></tr></table></figure><p>这样甚至都不用去重写<code>onCreateView()</code>。</p><h3 id="动态添加"><a href="#动态添加" class="headerlink" title="动态添加"></a>动态添加</h3><p>在上面例子的基础上，在 Activity 的 XML 部分，将引入的左半部分的 Fragment 的代码删除，然后添加一个 FrameLayout 作为容器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;horizontal&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">androidx.fragment.app.FragmentContainerView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/leftLayout&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">fragment</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/rightFrag&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.risingsun.androidlab.RightFragment&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着修改 Activity 中的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br><br>        <span class="hljs-keyword">var</span> temp = <span class="hljs-literal">true</span>  <span class="hljs-comment">// 标记位</span><br>        findViewById&lt;Button&gt;(R.id.rightFragBt).setOnClickListener &#123;<br>            <span class="hljs-keyword">if</span> (temp) loadFragment(LeftFragment())<br>            <span class="hljs-keyword">else</span> loadFragment(RightFragment())<br>            temp = !temp<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadFragment</span><span class="hljs-params">(fragment: <span class="hljs-type">Fragment</span>)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> fragmentManager = supportFragmentManager<br>        fragmentManager.beginTransaction().apply &#123;<br>            replace(R.id.leftLayout, fragment)<br>            commit()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，首先为右半部分的 Fragment 中的按钮添加了点击事件，具体操作是根据标记位来加载不一样的 Fragment 。然后定义了一个<code>loadFragment()</code>函数，用来执行加载 Fragment 的操作，具体逻辑为：首先通过<code>getSupportFragmentManager()</code>获取一个<code>FragmentManager</code>类对象，然后通过这个类的<code>beginTransaction()</code>获取一个<code>FragmentTransaction</code>类对象，然后再调用这个类的<code>replace()</code>来执行替换操作，在上述例子中，就是将 id 为<code>leftLayout</code>的容器中的内容替换成了方法接收到的 Fragment 对象，最后执行<code>commit()</code>提交更改。</p><p>程序执行，具体效果就是第一次点击按钮，左半部分加载了之前定义的红色的 Fragment ，再按一次按钮就变成和右边相同的蓝色的 Fragment ，再按一次按钮又会变回红色的 Fragment ，如此反复。</p><h4 id="添加到返回栈"><a href="#添加到返回栈" class="headerlink" title="添加到返回栈"></a>添加到返回栈</h4><p><code>replace()</code>每次调用，容器的内容就会被新的 Fragment 替换，当执行返回操作以后，app 就会直接退出。如果想让 Fragment 都被添加到一个栈中去管理的话，就可以在<code>commit()</code>前执行<code>addToBackStack(null)</code>，该方法接收一个字符串参数，用于表明这个返回栈的状态，此处可以传入<code>null</code>。</p><p>添加了<code>addToBackStack(null)</code>之后，程序再次运行，点击右半边 Fragment 中的按钮 3 次，也就是加载了 3 次 Fragment 之后，就需要执行 3 次返回操作才能将这些 Fragment 出栈，执行第 4 次返回操作的时候，就可以退出 app 了。</p><p>实际上，官方更加推荐使用 Jetpack 中的 Navigation 库来管理应用的导航，这样不仅更加规范和统一，而且也不再需要和<code>FragmentManager</code>直接交互。</p><h3 id="根据屏幕加载布局"><a href="#根据屏幕加载布局" class="headerlink" title="根据屏幕加载布局"></a>根据屏幕加载布局</h3><p>借助限定符（qualifier）可以让程序在运行时根据设备的分辨率或屏幕大小来决定加载哪个布局。</p><p>首先在 Activity 的布局文件中添加一个 Fragment ，然后在资源文件夹中添加一个名为<code>layout-large</code>的文件夹，在该文件夹内同样添加一个名为<code>activity_main.xml</code>的布局文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;horizontal&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">androidx.fragment.app.FragmentContainerView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/leftFrag&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.risingsun.androidlab.BlankFragment&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">androidx.fragment.app.FragmentContainerView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/rightFrag&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.risingsun.androidlab.BlankFragment&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;3&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此时如果时以手机的形式运行应用，会得到只有一个 Fragment 的界面，而如果以平板运行，则会得到左右共两个 Fragment 的界面。</p><p>另外，有时候为了可以更加灵活地为不同设备加载布局（不管它们是不是被系统认定为 large），这时就可以使用最小宽度限定符（smallest-width qualifier）。最小宽度限定符允许对屏幕的宽度指定一个最小值（以 dp 为单位），然后以这个最小值为临界点，屏幕宽度大于这个值的设备就加载这个布局，屏幕宽度小于这个值的设备就加载另一个布局。</p><p>例如在资源目录下新建<code>layout-sw600dp</code>文件夹，然后在这个文件夹下新建<code>activity_main.xml</code>布局，这就意味着，当程序运行在屏幕宽度大于等于 600dp 的设备上时，会加载 layout-sw600dp&#x2F;activity_main 布局，当程序运行在屏幕宽度小于 600dp 的设备上时，则仍然加载默认的 layout&#x2F;activity_main 布局。</p><h3 id="DialogFragment"><a href="#DialogFragment" class="headerlink" title="DialogFragment"></a>DialogFragment</h3><p>用于展示一个浮动的对话框，fragments 将自动处理<code>Dialog</code>类的创建和清理工作。</p><ul><li><a href="https://developer.android.com/reference/androidx/fragment/app/DialogFragment">DialogFragment | Android Developers</a></li><li><a href="https://developer.android.com/guide/fragments/dialogs">Displaying dialogs with DialogFragment | Android Developers</a></li></ul><h3 id="PreferenceFragmentCompat"><a href="#PreferenceFragmentCompat" class="headerlink" title="PreferenceFragmentCompat"></a>PreferenceFragmentCompat</h3><p>将<code>Preference</code>类对象的层次结构以 List 的形式展示出来，还可以利用<code>PreferenceFragmentCompat</code>构建一个 app 的设置界面。</p><ul><li><a href="https://developer.android.com/reference/androidx/preference/Preference">Preference | Android Developers</a></li><li><a href="https://developer.android.com/develop/ui/views/components/settings">Settings | Android Developers</a></li></ul><h2 id="与-Activity-交互"><a href="#与-Activity-交互" class="headerlink" title="与 Activity 交互"></a>与 Activity 交互</h2><p>Fragment 在界面上虽然是嵌入在 Activity 中的，但是在逻辑上，Fragment 和 Activity 属于两个不同的类。<code>FragmentManager</code>提供了一个叫<code>findFragmentById</code>的函数，用来在 Activity 中去引用那些在布局上位于 Activity 之内的 Fragment 的实例。例如现在在 Activity 的布局中通过 fragment 标签引入了<code>LeftFragment</code>，并且这个标签的 id 叫<code>leftFrag</code>，并且假设<code>LeftFragment</code>类中存在一个函数叫<code>foo()</code>，那么就可以：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> fragment = supportFragmentManager.findFragmentById(R.id.leftFrag) <span class="hljs-keyword">as</span> LeftFragment<br>fragment.foo()<br></code></pre></td></tr></table></figure><p>在 Fragment 中调用 Activity 也比较简单，直接调用<code>getActivity()</code>就可以拿到和 Fragment 相关联的 Activity 实例，只不过这个实例有可能为<code>null</code>。当需要上下文的时候也可以调用<code>getActivity()</code>，因为 Activity 本身就是一个<code>Context</code>对象。</p><p>另外，在通过<code>getActivity()</code>拿到 Activity 的实例以后，还可以通过这个 Activity 的实例去调用另一个 Fragment ，如此就做到了 Fragment 之间的交互。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Fragment 的生命周期大致可分为 4 个阶段：</p><ul><li>运行状态：当相关联的 Activity 进入该状态时，Fragment 也会进入该状态。</li><li>暂停状态：当相关联的 Activity 因为另一个未占满屏幕的 Activity 被添加到栈顶而进入暂停状态时，Fragment 也会进入该状态。</li><li>停止状态：当相关联的 Activity 进入该状态时，Fragment 也会进入该状态。或者当 Fragment 完全不可见并且处于返回栈中时，Fragment 也是停止状态的。</li><li>销毁状态：当相关联的 Activity 进入该状态时，Fragment 也会进入该状态。或者当调用<code>FragmentTransaction</code>类的<code>remove()</code>或者<code>replace()</code>方法将 Fragment 从 Activity 中移除时，Fragment 也会进入该状态。</li></ul><p>Fragment 拥有除了<code>onRestart()</code>以外 Activity 所拥有的 6 个生命周期回调函数，并且还额外拥有 Activity 没有的 5 个回调函数，分别是：</p><ul><li><code>onAttach()</code>：当 Fragment 和 Activity 建立关联时调用。</li><li><code>onCreateView()</code>：Fragment 创建视图（加载布局）时调用。</li><li><code>onActivityCreated()</code>：与 Fragment 相关联的 Activity 创建完毕时调用。</li><li><code>onDestroyView()</code>：当与 Fragment 关联的视图被移除时调用。</li><li><code>onDetach()</code>：当 Fragment 和 Activity 解除关联时调用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin 学习笔记 - 基础</title>
    <link href="/post/Kotlin-Study-Guide-Basic/"/>
    <url>/post/Kotlin-Study-Guide-Basic/</url>
    
    <content type="html"><![CDATA[<p>这篇笔记是对 Kotlin 的基础语法和一些基本特性进行记录。</p><span id="more"></span><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在 Java 中存在 8 个基本数据类型以及相对应的包装类。</p><ul><li>int(整型) -&gt; Integer</li><li>short(短整) -&gt; Short</li><li>long(长整) -&gt; Long</li><li>float(单精度浮点) -&gt; Float</li><li>double(双精度浮点) -&gt; Double</li><li>char(字符) -&gt; Character</li><li>byte(字节) -&gt; Byte</li><li>boolean(布尔) -&gt; Boolean</li></ul><p>例如<code>int</code>一般用于修饰变量，而<code>Integer</code>则是作为一个类存在的，拥有自己的成员变量和成员函数。Java 这么做是为了降低开销，提升性能，而在 Kotlin 中，则不存在基本数据类型，例如整型直接对应的就是<code>Int</code>这个类。</p><p>在 Kotlin 中存在诸如<code>toByte()</code>、<code>toFloat()</code>、<code>toString()</code>等类型转换函数用于更好地转换类型。</p><p>Kotlin 中的字符串也有很多实用的功能，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 利用字符串模板在字符串中直接加入变量</span><br><span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;Aiden&quot;</span><br>println(<span class="hljs-string">&quot;name is <span class="hljs-variable">$name</span>, and length of the name is <span class="hljs-subst">$&#123;name.length&#125;</span>.&quot;</span>)<br><br><span class="hljs-comment">// 以所见即所得的形式定义一个字符串</span><br><span class="hljs-keyword">val</span> s = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    haha</span><br><span class="hljs-string">    h e he</span><br><span class="hljs-string">&quot;&quot;&quot;</span>.trimIndent()<br>println(s)<br></code></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>name is Aiden, and length of the name is 5.<br>haha<br>h e he</p></blockquote><h3 id="空安全"><a href="#空安全" class="headerlink" title="空安全"></a>空安全</h3><p>假设在 Java 中定义了一个<code>Person</code>类，然后去实例化它的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>这么写是没错的，变量<code>person</code>就是<code>Person</code>类型的，只不过它的值为<code>null</code>而已。照着这个思路，在 Kotlin 中会很自然地写出：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> p: Person = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>这时候编译器会报错：<code>null</code>不可以被赋值给一个值不能为<code>null</code>的类型。也就是说，变量<code>person</code>确实是<code>Person</code>类的实例，只不过它不能被赋值为<code>null</code>，如果想要把它赋值为<code>null</code>，需要把它的类型改成<code>Person?</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> p: Person? = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>而当调用一个可为空类型的对象的时候，编译器会报错并提供 3 种更加安全的方案：</p><ul><li>添加空检查：使用 if 语句判断对象是否为<code>null</code>，在不为<code>null</code>的分支中执行代码。</li><li>使用安全调用：例如<code>person?.walk()</code>，这样一来当<code>person</code>为<code>null</code>时它将不会调用<code>walk()</code>。</li><li>使用非空断言：例如<code>person!!.walk()</code>，此举将告知编译器<code>person</code>不会为空，如果为空，后果自负。</li></ul><p>Kotlin 的这些特性使得所有对象在默认情况下都不能为<code>null</code>，以及在一定程度上避免了出现空指针异常的情况。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数的命名和变量一样都是小驼峰式命名法，也就是以小写字母开头。</p><h3 id="单一表达式函数"><a href="#单一表达式函数" class="headerlink" title="单一表达式函数"></a>单一表达式函数</h3><p>针对只有一条 return 语句的函数，可以直接用<code>=</code>连接函数名，后面跟上返回的内容，这样就省去了花括号和返回类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> = <span class="hljs-string">&quot;Hello, <span class="hljs-variable">$name</span>&quot;</span><br></code></pre></td></tr></table></figure><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>Kotlin 函数中的参数支持设置默认值，这使得函数在调用时会更灵活：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(name: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;Aiden&quot;</span>)</span></span> = <span class="hljs-string">&quot;Hello, <span class="hljs-variable">$name</span>&quot;</span><br></code></pre></td></tr></table></figure><p>此时如果调用<code>sayHello()</code>不传入参数的话，那么<code>name</code>的值将会是<code>Aiden</code>。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>Kotlin 中的 if 语句不仅可以作为 Statement 使用，还可以作为 Expression 使用。例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> age = <span class="hljs-number">18</span><br><span class="hljs-keyword">val</span> isAdult = <span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">18</span>) <span class="hljs-literal">true</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">// 直接对 isAdult 进行赋值</span><br></code></pre></td></tr></table></figure><h3 id="when"><a href="#when" class="headerlink" title="when"></a>when</h3><p>简而言之就是 Java 中的 switch 语句，只不过同样可以当 Expression 使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> score = <span class="hljs-number">80</span><br><span class="hljs-keyword">val</span> level = <span class="hljs-keyword">when</span> (score) &#123;<br>    <span class="hljs-number">80</span> -&gt; <span class="hljs-string">&quot;High&quot;</span><br>    <span class="hljs-number">60</span> -&gt; <span class="hljs-string">&quot;Medium&quot;</span><br>    <span class="hljs-keyword">else</span> -&gt; <span class="hljs-string">&quot;Low&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不过与 switch 不一样的是 when 强制要求添加<code>else</code>分支。</p><h3 id="while-for"><a href="#while-for" class="headerlink" title="while &amp; for"></a>while &amp; for</h3><p>Kotlin 中的 while 语句和 Java 的没什么区别，就是循环，但是 for 语句更多的起到一个遍历的用途。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 遍历数字区间</span><br><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.5</span>)  <span class="hljs-comment">// 左闭右闭区间 [1, 5]</span><br>    println(i)<br><br><span class="hljs-comment">// 倒序遍历数字区间</span><br><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">5</span> downTo <span class="hljs-number">1</span>)  <span class="hljs-comment">// 不能使用 5..1</span><br>    println(i)<br><br><span class="hljs-comment">// 遍历列表</span><br><span class="hljs-keyword">val</span> stringList = listOf(<span class="hljs-string">&quot;Aiden&quot;</span>, <span class="hljs-string">&quot;Marcus&quot;</span>, <span class="hljs-string">&quot;WatchDogs&quot;</span>)<br><span class="hljs-keyword">for</span> (str <span class="hljs-keyword">in</span> stringList)<br>    println(str)<br></code></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="普通类"><a href="#普通类" class="headerlink" title="普通类"></a>普通类</h3><p>假设要定义一个「人」类，拥有姓名和年龄这两个属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>)<br></code></pre></td></tr></table></figure><p>这一行代码中包含了很多信息：</p><ul><li>类名后面的括号实际上是主构造函数，在实例化对象的时候会把传进来的参数（上述例子中是<code>name</code>和<code>age</code>）赋值给类中的属性。</li><li>括号内定义的是类的属性，同时编译器还会为这些属性生成 getter 和 setter 函数。只不过用<code>val</code>修饰的变量就只会有 getter 不会有 setter ，因为<code>val</code>修饰的属性是不可修改的，而<code>var</code>修饰的则两者都有。</li></ul><h3 id="自定义-getter-setter"><a href="#自定义-getter-setter" class="headerlink" title="自定义 getter setter"></a>自定义 getter setter</h3><p>无论是 Java 还是 Kotlin 的属性都会有 getter 和 setter 函数，但是 Kotlin 的属性还拥有自定义 getter 和 setter 这个特性。假设现在要为上面的<code>Person</code>类增加一个叫做<code>isAdult</code>的属性，获取这个属性的时候返回一个布尔值，如果是<code>true</code>就代表这个对象已经成年了，可以这么做：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Person(<span class="hljs-string">&quot;Aiden&quot;</span>, <span class="hljs-number">23</span>).also &#123;<br>        <span class="hljs-keyword">if</span> (it.isAdult) println(<span class="hljs-string">&quot;成年了&quot;</span>)<br>        <span class="hljs-keyword">else</span> println(<span class="hljs-string">&quot;未成年&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-keyword">val</span> isAdult<br>        <span class="hljs-keyword">get</span>() = age &gt;= <span class="hljs-number">18</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>成年了</p></blockquote><p>可以看到：</p><ul><li>成年与否实际上应该算是一个人的属性而不是函数，只有像走路、吃饭这样的事情才应该写成函数，这是很符合直觉的。</li><li><code>get()</code>直接用<code>=</code>连接这种写法同样是用到了之前说到的单一表达式函数特性，但是如果 getter 的逻辑一行写不完，那也可以用花括号而不是直接用等号。</li><li>从语法的角度来看，确实增加了一个新的属性<code>isAdult</code>。但是从实现层面来看，编译器在 JVM 层面仍然将其优化成了一个函数，所以这个「属性」并不会占用内存。</li></ul><p>被<code>var</code>修饰的属性就会有 setter ，只不过如果希望在实例化对象的时候额外做点事情，那么就可以使用自定义 setter ：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">val</span> name: String) &#123;<br>    <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">set</span>(value) &#123;<br>            println(<span class="hljs-string">&quot;do something.&quot;</span>)<br>            field = value<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到：</p><ul><li><code>age</code>仍然是被<code>var</code>修饰，代表它有 setter 函数。</li><li>想要为<code>age</code>增加自定义 setter ，需要将其从主构造函数中分离出来，并且为其初始化。</li><li>例如<code>person.age = 23</code>这条语句，<code>23</code>会在自定义 setter 中作为参数被传递，也就是<code>set(value)</code>中的<code>value</code>，而函数体内的<code>field</code>代表的是<code>age</code>本身的值，这里是<code>0</code>，因为初始化为<code>0</code>。</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>Kotlin 在类继承方面仍然有很多新特性：</p><ul><li>Java 继承使用<code>extends</code>关键字，Kotlin 使用冒号<code>:</code>，继承类使用冒号，实现接口也使用冒号，类和多个接口之间用逗号<code>,</code>分离。</li><li>Java 重写函数用<code>@Override</code>注解，Kotlin 使用<code>override</code>关键字修饰重写的函数。</li><li>Kotlin 的类默认是不能被继承的，只有被<code>open</code>关键字修饰的类才能被继承，同样只有被<code>open</code>关键字修饰的函数才能被重写。</li></ul><h3 id="类嵌套"><a href="#类嵌套" class="headerlink" title="类嵌套"></a>类嵌套</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;Aiden&quot;</span><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-comment">//        val str = name  // 报错</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将<code>B</code>类嵌套在<code>A</code>类内部，内部类不能访问外部类的属性，这种情况对应了 Java 中的静态内部类。如果想要内部类可以持有外部类的引用，则需要给内部类加上<code>inner</code>关键字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;Aiden&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span></span> &#123;&#125;<br><br>    <span class="hljs-keyword">inner</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>        <span class="hljs-keyword">val</span> str = name<br>        <span class="hljs-keyword">val</span> method = walk()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Kotlin 将类嵌套默认实现成静态内部类，这样在默认情况下就不会出现内存泄漏的情况。</p><h3 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h3><p>数据类（data class）主要是用于存放数据的类，是 Java 没有的概念。</p><ul><li>数据类的主构造函数中至少要有一个参数。</li><li>编译器会为数据类生成几个函数：N 个 componentN()，其中 N 代表主构造函数中参数的个数、<code>copy()</code>、<code>toString()</code>、<code>hashCode()</code>、<code>equals()</code></li></ul><h3 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h3><p>密封类（sealed class）类似于枚举，不过更强大。也是 Java 中没有的概念。</p><p>枚举中的一个值和它自己永远是的结构相等且引用相等，如果需要枚举的值拥有不一样的引用，就可以使用密封类。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li>接口中可以声明属性，只不过属性不能有初始值。被<code>val</code>修饰的属性可以自定义 getter ，被<code>var</code>修饰的属性既不能自定义 getter 也不能自定义 setter 。</li><li>函数也可以有默认实现。</li></ul><h2 id="编译器干了什么"><a href="#编译器干了什么" class="headerlink" title="编译器干了什么"></a>编译器干了什么</h2><h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><p>前面提到，相较 Java 来说，Kotlin 在语法层面是只有包装类的，也就是例如 Java 中的 long 到了 Kotlin 后就只有 Long 。但是原始类型的存在也是有理由的，因为它的性能损耗会更低，那么 Kotlin 是怎么优化性能的？</p><p>首先在 Kotlin 写出声明 Long 类型变量的一些情况：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 可变和不可变的 Long</span><br><span class="hljs-keyword">val</span> a = <span class="hljs-number">1L</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">2L</span><br><br><span class="hljs-comment">// 可变和不可变的、可为空但是并不是空的 Long</span><br><span class="hljs-keyword">val</span> c: <span class="hljs-built_in">Long</span>? = <span class="hljs-number">3L</span><br><span class="hljs-keyword">var</span> d: <span class="hljs-built_in">Long</span>? = <span class="hljs-number">4L</span><br><br><span class="hljs-comment">// 可变且可为空的 Long ，先赋为 null 再赋值为 5L</span><br><span class="hljs-keyword">var</span> f: <span class="hljs-built_in">Long</span>? = <span class="hljs-literal">null</span><br>f = <span class="hljs-number">5L</span><br><br><span class="hljs-comment">// 可变且可为空的 Long ，先赋为 6L 再赋值为 null</span><br><span class="hljs-keyword">var</span> g: <span class="hljs-built_in">Long</span>? = <span class="hljs-number">6L</span><br>g = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>将其反编译为 Java ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2L</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">3L</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">4L</span>;<br><span class="hljs-type">Long</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>f = <span class="hljs-number">5L</span>;<br><span class="hljs-type">Long</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-number">6L</span>;<br>g = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>可以看到，尽管在 Kotlin 中只使用了 Long ，但是到了 Java 就变成既有 long 又有 Long 了，这背后的工作也是由 Kotlin 编译器完成的。一句话总结就是，有可能为<code>null</code>的数据，编译器会自动将其声明为包装类型。</p><h3 id="接口语法"><a href="#接口语法" class="headerlink" title="接口语法"></a>接口语法</h3><p>Kotlin 中的接口可以有属性，函数可以有默认实现，这是什么原理呢。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClickListener</span> &#123;<br>    <span class="hljs-keyword">val</span> enable: <span class="hljs-built_in">Boolean</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">click</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;被点击了&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyButton</span> : <span class="hljs-type">ClickListener</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> enable: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>先从接口的定义看起，有一个布尔类型的属性和一个函数，反编译至 Java ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClickListener</span> &#123;<br>   <span class="hljs-type">boolean</span> <span class="hljs-title function_">getEnable</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">click</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultImpls</span> &#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">click</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> ClickListener $<span class="hljs-built_in">this</span>)</span> &#123;<br>         <span class="hljs-type">String</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;被点击了&quot;</span>;<br>         System.out.println(var1);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到：属性本质上是一个 get 函数，<code>click()</code>的默认实现被放到了一个静态内部类当中的一个同名静态函数当中。再来看<code>MyButton</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyButton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClickListener</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> enable;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">getEnable</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.enable;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEnable</span><span class="hljs-params">(<span class="hljs-type">boolean</span> var1)</span> &#123;<br>      <span class="hljs-built_in">this</span>.enable = var1;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">click</span><span class="hljs-params">()</span> &#123;<br>      ClickListener.DefaultImpls.click(<span class="hljs-built_in">this</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>MyButton</code>类实现<code>ClickListener</code>接口后，重写了<code>getEnable()</code>，这是必须重写的，但是因为我在 Kotlin 的<code>MyButton</code>类中将<code>enable</code>以<code>var</code>来声明，导致编译器在 Java 里又帮我添加了一个<code>setEnable()</code>，同时它还声明了<code>private boolean enable;</code>（<code>enable</code>没有初始化为<code>false</code>是因为 boolean 默认为<code>false</code>），这样一来，一个具备 getter 和 setter 的属性就声明完成了……也就是说，我在 Kotlin 接口中声明的属性，被反编译至 Java 后，先是在 Java 的接口定义处变成了函数，然后在接口实现处又变回了属性。而<code>click()</code>也经历了重写，只不过因为它有默认实现，所以这个重写就是简单的调用这个实现就行了。</p><h3 id="更多例子"><a href="#更多例子" class="headerlink" title="更多例子"></a>更多例子</h3><ul><li>类型推导，定义变量时省略的变量类型，最终会被编译器补充回来。</li><li>字符串模板，编译器最终会将它们转换成 Java 中拼接的形式。</li><li>when 表达式，编译器最终会将它们转换成类似 switch case 的语句。</li><li>类默认 public ，定义类时省略的 public 最终会被编译器补充回来。</li><li>嵌套类默认 static ，嵌套类默认会被添加<code>static</code>关键字，将其变成静态内部类，防止不必要的内存泄漏。</li><li>数据类，定义数据类只用一行代码，编译器在后期补充了很多相关函数。</li></ul><h2 id="object-关键字"><a href="#object-关键字" class="headerlink" title="object 关键字"></a>object 关键字</h2><p>Kotlin 中的<code>object</code>关键字有着三种迥然不同的语义，分别可以定义：</p><ul><li>匿名内部类</li><li>单例模式</li><li>伴生对象</li></ul><p>之所以会出现这样的情况，是因为设计者认为，这三种语义本质上都是在定义一个类的同时还创建了对象。</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类通常只使用一次（因为它是匿名的），并且会继承一个父类或者实现一个接口。</p><p>在 Java 中不使用匿名内部类是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaLab</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Human</span> <span class="hljs-variable">human</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Human</span>();<br>        human.walk();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">walk</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 手动继承抽象类并实现抽象函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">walk</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Human walk.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>变量命名的意义可能不大，不过重点在于<code>Human</code>类重写了<code>walk()</code>，并且只用了一次，那大可使用匿名内部类的方式来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaLab</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 写法是添加花括号，括号内部就是匿名类的实现，并且该类会继承 Animal</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">walk</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">// 匿名内部类继承 Animal 后实现抽象函数</span><br>            &#125;<br>        &#125;;<br>        animal.walk();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">walk</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法同样可以用于接口上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaLab</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 可以这么写</span><br>        <span class="hljs-type">Foo</span> <span class="hljs-variable">foo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Bar</span><span class="hljs-params">()</span> &#123;<br>                <br>            &#125;<br>        &#125;;<br>        foo.Bar();<br>        <br>        <span class="hljs-comment">// 也可以简化这么写</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Bar</span><span class="hljs-params">()</span> &#123;<br>                <br>            &#125;<br>        &#125;.Bar();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">Bar</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>甚至可以使用 Lambda 语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Foo</span> <span class="hljs-variable">foo</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br><br>    &#125;;<br>    foo.Bar();<br><br>    ((Foo) () -&gt; &#123;<br><br>    &#125;).Bar();<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来看一些一般用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 继承`Thread`类来开启线程</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.run();<br>    &#125;<br>&#125;;<br>thread.start();<br><br><span class="hljs-comment">// 实现`Runnable`接口来开启线程</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>    <span class="hljs-comment">// 编写 run() 中的逻辑</span><br>&#125;;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>myThread.start();<br><br><span class="hljs-comment">// 在 Android 中为按钮控件添加点击事件</span><br><span class="hljs-type">Button</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>();  <span class="hljs-comment">// 此处报错，需要提供上下文，不过不是重点</span><br>button.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View view)</span> &#123;<br>        <span class="hljs-comment">// 按钮点击逻辑</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>Kotlin 则通过<code>object</code>关键字来创建匿名内部类，并且同样需要重写那些未实现的函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 在 Android 中为按钮控件添加点击事件</span><br><span class="hljs-keyword">val</span> bt = Button(<span class="hljs-keyword">this</span>)<br>bt.setOnClickListener(<span class="hljs-keyword">object</span> : View.OnClickListener &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(p0: <span class="hljs-type">View</span>?)</span></span> &#123;<br>        TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>只不过跟 Java 不一样的是，Kotlin 可以同时继承一个类和实现多个接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 实现了 Foo 和 Foo2 两个接口以及一个抽象类 Foo3</span><br>    <span class="hljs-keyword">val</span> temp = <span class="hljs-keyword">object</span> : Foo, Foo2, Foo3() &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br>            TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar2</span><span class="hljs-params">()</span></span> &#123;<br>            TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar3</span><span class="hljs-params">()</span></span> &#123;<br>            TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo2</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar2</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo3</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar3</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><p>Kotlin 中最简单的定义单例类的方式就是通过<code>object</code>关键字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Singleton.foo()<br>&#125;<br><br><span class="hljs-comment">// 不需要 class 修饰</span><br><span class="hljs-keyword">object</span> Singleton &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来将 Kotlin 字节码反编译至 Java 看看 Kotlin 是如何使用<code>object</code>关键字实现单例类的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KotlinLabKt</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>      Singleton.INSTANCE.foo();<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] var0)</span> &#123;<br>      main();<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>   <br>   <span class="hljs-comment">// 创建一个该类的成员变量</span><br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>   &#125;<br><br>   <span class="hljs-comment">// 私有化构造函数</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>   &#125;<br><br>   <span class="hljs-keyword">static</span> &#123;<br>      <span class="hljs-type">Singleton</span> <span class="hljs-variable">var0</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>      INSTANCE = var0;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，尽管编写过程很简单，但是编译器还是在背后把该做的都做了，包括私有化构造函数、创建一个该类的成员变量，并用<code>static</code>修饰。不过仍然有需要注意的地方：程序中并没有出现我们熟悉的<code>getInstance()</code>之类的用于获取实例的函数，也没有双重检查用于保证线程安全，并且<code>INSTANCE</code>变量，也就是我们用于返回的实例变量，还被<code>final</code>修饰了——这一切其实都是因为<code>static&#123;&#125;</code>代码块。在<code>static&#123;&#125;</code>代码块中的代码，将由虚拟机保证只会被执行一次，也就是保证了线程安全，就不需要双重检查了，同时又保证了<code>INSTANCE</code>变量只会被赋值一次，所以就用<code>final</code>修饰了。同时也可以看到，调用方式为<code>单例类名.实例对象名.函数名</code>。</p><p>这样的单例类真的很简洁明了，看得很舒服，但是也存在两个很明显的不足：</p><ul><li>不支持懒加载（懒汉和饿汉）。</li><li>不支持传参构造单例（例如无法传递上下文）。</li></ul><h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>() &#123;<br>    <span class="hljs-keyword">object</span> DataManager &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadData</span><span class="hljs-params">()</span></span>: Data &#123;<br>            <span class="hljs-comment">// 执行网络请求</span><br>            <span class="hljs-keyword">return</span> Data()<br>        &#125;<br>        <br>        <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">by</span> lazy &#123;<br>            loadData()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 by lazy 把属性包裹起来，只要<code>data</code>没有被使用过，就不会触发<code>loadData()</code>。这其实是一种简洁与性能的折中方案。一个对象所占用的内存资源毕竟不大，但是从服务器去请求数据所消耗的资源就会大很多，能保证这个部分是懒加载就算不错了。</p><h4 id="Double-Check"><a href="#Double-Check" class="headerlink" title="Double Check"></a>Double Check</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>() &#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-comment">// 使用 @Volatile 注解保证同步性</span><br>        <span class="hljs-meta">@Volatile</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> instance: Singleton? = <span class="hljs-literal">null</span><br>        <span class="hljs-comment">// 第一次使用 elvis 操作符进行判空</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>: Singleton = instance ?: synchronized(<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// 第二次判空</span><br>            instance ?: Singleton().also &#123; instance = it &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个写法其实也来自 Google ：<a href="https://github.com/android/architecture-components-samples/blob/master/BasicRxJavaSampleKotlin/app/src/main/java/com/example/android/observability/persistence/UsersDatabase.kt">architecture-components-samples&#x2F;UsersDatabase.kt at master · android&#x2F;architecture-components-samples · GitHub</a>，本质上和 Java 的双重检查没什么区别。</p><h4 id="抽象类模板"><a href="#抽象类模板" class="headerlink" title="抽象类模板"></a>抽象类模板</h4><p>Double Check 是很好的方案，既解决了懒加载又满足了传参，可是它还不够完美，因为针对不同的类，每次都要把逻辑从头写一遍，每次都要写一遍 Double Check 就很麻烦，那么如何复用这部分操作呢。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 使用</span><br>    <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = Data.getInstance(<span class="hljs-string">&quot;&quot;</span>)<br>    <span class="hljs-keyword">data</span>.foo()<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseSingleton</span>&lt;<span class="hljs-type">in P, out T</span>&gt; &#123;<br>    <span class="hljs-meta">@Volatile</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> instance: T? = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">(param: <span class="hljs-type">P</span>)</span></span>: T<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInstance</span><span class="hljs-params">(param: <span class="hljs-type">P</span>)</span></span>: T = instance ?: synchronized(<span class="hljs-keyword">this</span>) &#123;<br>        instance ?: create(param).also &#123; instance = it &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>() &#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> : BaseSingleton&lt;String, Data&gt;() &#123;<br>        <span class="hljs-comment">// 实例化对象的逻辑将放在 create() 中</span><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">(param: <span class="hljs-type">String</span>)</span></span>: Data &#123;<br>            <span class="hljs-comment">// 可以进行一些额外处理</span><br>            <span class="hljs-keyword">return</span> Data()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用泛型并通过继承一个抽象类并实现其抽象函数，可以把重复的工作放在抽象类当中，然后把如何实例化的逻辑抽取出来，针对不同的类编写不一样的逻辑。例如上面的例子中，<code>Data</code>类中的伴生对象（伴生对象也是一个类）在继承<code>BaseSingleton&lt;in P, out T&gt;</code>以后就只需要重写<code>create()</code>，保证其最终返回一个<code>Data</code>对象就行了。至于 Volatile 和双重检查的逻辑，已经在抽象类中实现了。</p><h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>Kotlin 中没有<code>static</code>关键字，想要定义静态变量和静态函数，需要使用到伴生对象也就是<code>companion object</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Foo.name = <span class="hljs-string">&quot;Aiden&quot;</span><br>    Foo.bar()<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br>            println(<span class="hljs-string">&quot;my name is <span class="hljs-variable">$name</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就很有静态的感觉。那么<code>object&#123;&#125;</code>和<code>companion object&#123;&#125;</code>都可以在类的内部声明，那它们之间有什么区别呢。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ObjectTest.InnerSingleton.foo()<br>    ObjectTest.InnerSingleton.name = <span class="hljs-string">&quot;Aiden&quot;</span><br>    println(ObjectTest.InnerSingleton.name)<br><br>    CompanionObjectTest.bar()<br>    println(CompanionObjectTest.name)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectTest</span> &#123;<br>    <span class="hljs-keyword">object</span> InnerSingleton &#123;<br>        <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompanionObjectTest</span> &#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;Aiden&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译至 Java ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KotlinLabKt</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>      ObjectTest.InnerSingleton.INSTANCE.foo();<br>      CompanionObjectTest.Companion.bar();<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] var0)</span> &#123;<br>      main();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，<code>object&#123;&#125;</code>由于被嵌入到一个类中，所以在调用的时候会比<code>companion object&#123;&#125;</code>多一层，如果想要去掉这一层（.INSTANCE），可以在<code>fun foo() &#123;&#125;</code>上边加上<code>@JvmStatic</code>注解，再次反编译就会发现少了这一层，不过感觉也没什么卵用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectTest</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerSingleton</span> &#123;<br>      <span class="hljs-meta">@NotNull</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Aiden&quot;</span>;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> age;<br>      <span class="hljs-meta">@NotNull</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> InnerSingleton INSTANCE;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-keyword">return</span> age;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> var1)</span> &#123;<br>         age = var1;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>      &#125;<br><br>      <span class="hljs-keyword">private</span> <span class="hljs-title function_">InnerSingleton</span><span class="hljs-params">()</span> &#123;<br>      &#125;<br><br>      <span class="hljs-keyword">static</span> &#123;<br>         <span class="hljs-type">InnerSingleton</span> <span class="hljs-variable">var0</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerSingleton</span>();<br>         INSTANCE = var0;<br>         age = <span class="hljs-number">23</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，<code>object&#123;&#125;</code>就是把单例类嵌入到类中（在<code>static&#123;&#125;</code>代码块中执行一些变量初始化操作），然后通过实例对象来调用变量和 getter 和 setter 以及其它函数。只不过相比直接使用<code>object</code>定义单例类，嵌入到类中的单例类还会被<code>static</code>修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CompanionObjectTest</span> &#123;<br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Aiden&quot;</span>;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">23</span>;<br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Companion</span> <span class="hljs-variable">Companion</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Companion</span>((DefaultConstructorMarker)<span class="hljs-literal">null</span>);<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Companion</span> &#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-keyword">return</span> CompanionObjectTest.age;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> var1)</span> &#123;<br>         CompanionObjectTest.age = var1;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span> &#123;<br>      &#125;<br><br>      <span class="hljs-keyword">private</span> <span class="hljs-title function_">Companion</span><span class="hljs-params">()</span> &#123;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-title function_">Companion</span><span class="hljs-params">(DefaultConstructorMarker $constructor_marker)</span> &#123;<br>         <span class="hljs-built_in">this</span>();<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>companion object&#123;&#125;</code>就有点不一样了，它首先把所有的变量放在类的最外层并且用<code>static</code>修饰，然后新建了一个叫<code>Companion</code>的静态内部类，其中包含了所有的函数（包括最外层的那些变量的 getter 和 setter）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看了<code>object&#123;&#125;</code>和<code>companion object&#123;&#125;</code>反编译代码的对比，感觉也没什么特别的，不如来总结一下单例类的用法：</p><ul><li>如果单例占用内存很小，并且对内存不敏感，不需要传参，直接使用<code>object</code>定义即可。</li><li>如果单例占用内存很小，不需要传参，但它内部的属性会触发消耗资源的网络请求和数据库查询，则可以使用<code>object</code>搭配懒加载。</li><li>如果工程很简单，只有一两个单例场景，同时有懒加载需求，并且需要传参，则可以直接手写 Double Check 。</li><li>如果工程规模大，对内存敏感，单例场景比较多，那就很有必要使用抽象类模板了。</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h3><p>扩展函数是个函数，函数可以被类实例对象调用，所以扩展很明显指的就是扩展这个类了。但是函数明明可以直接写在类里，想要什么功能就写什么函数，为什么还要扩展？所以很明显，扩展的往往是那些不能被修改的类。来看个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;1000秒是多少分多少秒呢？是<span class="hljs-subst">$&#123;<span class="hljs-number">1000.</span>toMinSec()&#125;</span>&quot;</span>)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">toMinSec</span><span class="hljs-params">()</span></span>: String &#123;<br>    <span class="hljs-keyword">val</span> min = <span class="hljs-keyword">this</span> / <span class="hljs-number">60</span>  <span class="hljs-comment">// this 代表调用这个函数的 Int 对象</span><br>    <span class="hljs-keyword">val</span> sec = <span class="hljs-keyword">this</span> % <span class="hljs-number">60</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-variable">$min</span>:<span class="hljs-variable">$sec</span>&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>toMinSec()</code>的具体逻辑是什么并不重要。重点在于<code>Int</code>类是 Kotlin 官方的类，是不能被修改的，但是<code>toMinSec()</code>作为扩展函数，它扩展了<code>Int</code>类，这样一来，<code>Int</code>类对象就可以直接调用这个函数。扩展函数的好处就在于方便且符合直觉：这个功能就是和这个类相关的，那么这个类的对象就应该可以直接调用函数。</p><p>编写扩展函数的关键在于函数的声明处，在上面的例子中，<code>Int.toMinSec()</code>代表的是将名为<code>toMinSec()</code>的函数作为<code>Int</code>类的扩展函数，在后续的使用中，如上面的<code>1000</code>，作为<code>Int</code>对象，就可以直接调用这个函数。还有一点就是函数当中的<code>this</code>关键字，这个关键字在函数内代表的是调用这个函数的对象，在上面的例子中就是<code>1000</code>。</p><p>接下来利用反编译看一下扩展函数神奇在哪里（为了简化，这里就把函数内的逻辑改成一行打印）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    toMinSec(<span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">toMinSec</span><span class="hljs-params">(<span class="hljs-type">int</span> $<span class="hljs-built_in">this</span>$toMinSec)</span> &#123;<br>    System.out.println($<span class="hljs-built_in">this</span>$toMinSec);<br>&#125;<br></code></pre></td></tr></table></figure><p>不难看出，Kotlin 编写的扩展函数，最终会变成静态函数的调用，并没有修改任何类的源码。</p><h3 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h3><p>扩展属性也是类似：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;Aiden&quot;</span>.foo)<br>&#125;<br><br><span class="hljs-keyword">val</span> String.foo<br>    <span class="hljs-keyword">get</span>() = <span class="hljs-string">&quot;bar&quot;</span><br></code></pre></td></tr></table></figure><p>可以看到，区别只是将<code>fun</code>改成<code>val</code>&#x2F;<code>var</code>而已，然后把函数体改成 get 函数，函数内同样可以通过<code>this</code>关键字引用这个 String 对象。针对这个例子反编译至 Java 会发现扩展属性的实现同样是一个静态函数，函数名为<code>getFoo</code>。</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>扩展并非无所不能，因为其本质终究是一个静态函数，这就导致了至少 3 个限制：</p><ul><li>无法被重写。这很好理解，假设为 A 类编写了一个扩展函数（这个扩展函数位于顶层），这个 A 类是用<code>open</code>修饰的，然后 B 类继承了 A 类，但是就算这样还是无法重写这个扩展函数，因为这个扩展函数根本就不是 A 类的成员。如果非要重写，那可以把这个扩展函数写在 A 类的里面，但是这样又没意义了，如果可以修改类的代码，那还要扩展函数做什么。</li><li>扩展属性无法存储状态。对于扩展属性，可以编写 get 函数，但是编写 set 函数的时候并不能调用<code>field</code>进行赋值。</li><li>访问的作用域仅限于两处。一是扩展声明所在的作用域的变量（例如在顶层），扩展可以访问，哪怕这个变量是私有的。二是被扩展类的公开成员，例如扩展了 String 类，那么就可以调用 String 类的<code>length</code>属性，至于 String 类的私有成员，扩展则无法访问。</li></ul><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数就是将函数用作参数或返回值的函数。在 Android 开发中，为控件添加点击监听是一个很好的例子，如果用 Java 为一个按钮添加点击监听，一般这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Button</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>();  <span class="hljs-comment">// 报错，缺少上下文，不重要</span><br>button.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View view)</span> &#123;<br>        <span class="hljs-comment">// 点击事件</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>同样的功能，用 Kotlin 来写，写法会简单很多，同时可读性也增加了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Button(<span class="hljs-keyword">this</span>).setOnClickListener &#123;<br>    <span class="hljs-comment">// 点击事件</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>函数类型是高阶函数中一个比较重要的概念，变量有类型，函数也能有类型吗？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(bar: <span class="hljs-type">Int</span>)</span></span>: String = <span class="hljs-string">&quot;6&quot;</span><br></code></pre></td></tr></table></figure><p>以上边的<code>foo()</code>为例，它的函数类型就是<code>(Int) -&gt; String</code>，意思是这个函数接收一个整型的参数然后返回一个字符串类型的值。其它的类型比方说还有<code>() -&gt; Unit</code>、<code>Int.() -&gt; Unit</code>等等。可以看到，函数类型由以下信息组成：</p><ul><li>函数接收的参数的数量和类型。</li><li>函数是否是扩展函数（或者说是否带有接收者）。</li><li>函数的返回值类型。</li></ul><p>此外还可以通过函数引用的函数来确认函数类型，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> method: (<span class="hljs-built_in">Int</span>) -&gt; String = ::foo  <span class="hljs-comment">// 双冒号表示函数引用</span><br></code></pre></td></tr></table></figure><p>编译器没有报错，说明我们通过了编译器的检查，肯定了<code>foo()</code>的类型就是<code>(Int) -&gt; String</code>。</p><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>Lambda 可以理解为函数的简写，在上方的<code>setOnClickListener</code>的写法之前，其实还存在 8 种过渡写法，可以了解一下：</p><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>最原始的状态，本质是用<code>object</code>关键字定义了一个匿名内部类去实现<code>OnClickListener</code>这个接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">button.setOnClickListener(<span class="hljs-keyword">object</span> : View.OnClickListener &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(p0: <span class="hljs-type">View</span>?)</span></span> &#123;<br>        <span class="hljs-comment">// 点击逻辑</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p><code>object</code>关键字可以省略，重写的函数也可以省略函数体，直接把逻辑写在花括号里：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">button.setOnClickListener(View.OnClickListener &#123; view: View? -&gt;<br>    <span class="hljs-comment">// 点击逻辑</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p><code>View.OnClickListener</code>可以省略不写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">button.setOnClickListener(&#123; view: View? -&gt;<br>    <span class="hljs-comment">// 点击逻辑</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p>编译器可以推导类型，所以<code>View?</code>可以省略不写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">button.setOnClickListener(&#123; view -&gt;<br>    <span class="hljs-comment">// 点击逻辑</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h4><p>当表达式中只存在一个参数的时候，这个参数可以用<code>it</code>来代表：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">button.setOnClickListener(&#123; it -&gt;<br>    <span class="hljs-comment">// 点击逻辑</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h4><p><code>it</code>可以省略不写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">button.setOnClickListener(&#123;<br>    <span class="hljs-comment">// 点击逻辑</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h4><p>当 Lambda 作为函数的最后一个参数时，花括号可以被挪到括号外面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">button.setOnClickListener() &#123;<br>    <span class="hljs-comment">// 点击逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第八步"><a href="#第八步" class="headerlink" title="第八步"></a>第八步</h4><p>当只有一个 Lambda 作为函数参数时，括号都可以省略不写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">button.setOnClickListener &#123;<br>    <span class="hljs-comment">// 点击逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h3><p>要想使用 Lambda 表达式，一般需要满足 SAM 。SAM 是 Single Abstract Method 的缩写，意思就是只有一个抽象函数的类或者接口。只要是符合 SAM 要求的接口，编译器就能进行 SAM 转换，在编写过程中就可以直接使用 Lambda 表达式。</p><p>但是从 Java 8 开始，SAM 就有了明确的名称，叫做函数式接口（Functional interface），并且想要实现函数式接口，就要满足两个条件，缺一不可：</p><ul><li>只能是接口，抽象类不行了。</li><li>接口只有一个抽象函数（接口中的函数默认是抽象的），默认实现的函数可以有多个。</li></ul><p>并且从 Kotlin 1.4 开始，想要在 Kotlin 中实现函数式接口，必须要用<code>fun interface</code>来声明，普通的接口已经不行了，抽象类也不行。</p><p>了解规则后，接下来用代码解释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaLab</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(IFoo foo)</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IFoo</span> &#123;<br>    <span class="hljs-comment">// 单抽象函数</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 多个默认实现</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar2</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>    <span class="hljs-comment">// 多个默认实现</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar3</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    test &#123;<br><br>    &#125;<br><br>    test2(<span class="hljs-keyword">object</span> : Foo2 &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar2</span><span class="hljs-params">()</span></span> &#123;<br>            TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>        &#125;<br>    &#125;)<br><br>    JavaLab.Test &#123;<br><br>    &#125;<br><br>    test3(<span class="hljs-string">&quot;Aiden&quot;</span>) &#123;<br>        print(<span class="hljs-string">&quot;My name is &quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 函数式接口（Functional interface）</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-keyword">interface</span> Foo &#123;</span><br>    <span class="hljs-comment">// 单抽象函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span><br><br>    <span class="hljs-comment">// 默认实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">rab</span><span class="hljs-params">()</span></span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 普通函数，接收一个实现了 Foo 接口的对象</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(foo: <span class="hljs-type">Foo</span>)</span></span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">// 普通接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo2</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar2</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-comment">// 普通函数，接收一个实现了 Foo2 接口的对象</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test2</span><span class="hljs-params">(foo2: <span class="hljs-type">Foo2</span>)</span></span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">// 高阶函数，接收了一个函数类型的参数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test3</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, hello: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    hello.invoke()<br>    print(name)<br>&#125;<br></code></pre></td></tr></table></figure><p>一个一个说明：</p><ul><li>Java 中的静态函数<code>Test()</code>在 Kotlin 中被直接引用，函数接收一个实现了<code>IFoo</code>接口的对象。<code>IFoo</code>接口尽管有多个默认实现函数（被<code>default</code>修饰），但只有一个抽象函数，并且因为<code>IFoo</code>是接口，所以是满足 SAM 的，所以在 Kotlin 中调用<code>Test()</code>时可以直接使用 Lambda 表达式。</li><li>Kotlin 中的<code>Foo</code>接口被<code>fun interface</code>修饰，所以<code>Foo</code>接口已经被定性为函数式接口，在该接口中可以有多个默认实现的函数，但是如果没有抽象函数或者有多个抽象函数，编译器将会报错。因为<code>test()</code>接收一个实现了<code>Foo</code>接口的对象，所以在调用<code>test()</code>时可以直接使用 Lambda 表达式。</li><li><code>Foo2</code>接口是普通的接口，并不满足 SAM ，所以<code>test2()</code>就算接收了它也不能使用 Lambda 表达式。</li><li>抽象类也不满足 SAM ，也不能使用 Lambda 表达式，在代码里就不演示了。</li><li>使用 Lambda 表达式不一定要满足 SAM ，<code>test3()</code>是高阶函数，并且把函数类型的参数放在了参数列表最后面，所以在调用<code>test3()</code>的时候也可以使用 Lambda 表达式。</li></ul><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>函数式编程（Functional Programming），是一个跟「面向对象」类似的概念，它也是软件工程中的一种编程范式，它是声明式编程（Declarative Programming）的一种，而与它相反的叫做命令式编程（Imperative Programming）。这些概念之间的关系大概是这样：</p><p><img src="/images/note/Programming-Paradigm.png" alt="编程范式"></p><p>像 C 和 Java ，它们分别属于面向过程、面向对象的语言，同时又都属于命令式的范畴。使用命令式语言进行编程，一般就是根据思路，告诉计算机每一步该做什么，比如现在要从一个集合中找出所有的偶数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findEvenNumber</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;<span class="hljs-type">Int</span>&gt; = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>): List&lt;<span class="hljs-built_in">Int</span>&gt; &#123;<br>    <span class="hljs-keyword">val</span> evenList = mutableListOf&lt;<span class="hljs-built_in">Int</span>&gt;()  <span class="hljs-comment">// 新建一个集合用来存放结果</span><br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> list) &#123;  <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)  <span class="hljs-comment">// 判断是否能被 2 整除</span><br>            evenList.add(i)  <span class="hljs-comment">// 如果能就把这个数加入到结果中</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> evenList  <span class="hljs-comment">// 返回这个集合</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果是声明式代码就需要这么写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// `filter()`是 Kotlin 集合类中的一个高阶函数，作用是将集合中符合 Lambda 表达式中要求的元素返回</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findEvenNumber</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;<span class="hljs-type">Int</span>&gt; = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>) = list.filter &#123; it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#125;<br></code></pre></td></tr></table></figure><p>通过对比还是会感觉到风格上有不一样，那么到底如何理解 Kotlin 中的函数式编程，简单来说，有这么两点：</p><ul><li>函数在 Kotlin 中至关重要。<ul><li>函数可以独立于类之外，成为顶层函数；</li><li>函数可以作为参数和返回值，也就是高阶函数和 Lambda ；</li><li>函数可以像变量一样被引用；</li></ul></li><li>纯函数。<ul><li>函数不应该有副作用（不应该对函数作用域以外的数据进行修改）。</li><li>具有幂等性（调用一次和调用 N 次，效果是等价的）。</li><li>具有引用透明的特性。</li><li>它具有无状态的特性。</li></ul></li></ul><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>Kotlin 的委托和扩展差不多，都有两个应用场景，一个是委托类，另一个是委托属性，<strong>前者委托的是接口函数，后者委托的是属性的 getter 和 settter</strong> 。</p><h3 id="委托类"><a href="#委托类" class="headerlink" title="委托类"></a>委托类</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    UniversalAction(Dog()).move()<br>    UniversalAction(Person()).move()<br>&#125;<br><br><span class="hljs-comment">// 定义一个关于动作的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Action</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">move</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-comment">// 定义了一个狗类并实现了 Action 接口重写了 move()</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-type">Action</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">move</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;狗是爬的&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义了一个人类并实现了 Action 接口重写了 move()</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> : <span class="hljs-type">Action</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">move</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;人是走的&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 通过 by 关键字进行委托</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UniversalAction</span>(action: Action) : Action <span class="hljs-keyword">by</span> action<br></code></pre></td></tr></table></figure><p>输出结果是：</p><blockquote><p>狗是爬的<br>人是走的</p></blockquote><p>重点在于<code>UniversalAction</code>这个类，该类也实现了<code>Action</code>接口，只不过并没有重写<code>move()</code>，而是通过<code>by</code>关键字把<code>move()</code>的实现委托给了构造函数的参数，到时候直接用参数的<code>move()</code>就行了。这样一来<code>UniversalAction</code>就相当于一个壳，它并不关心<code>move()</code>具体怎么实现，只要传入不同的参数，就会有不同的行为</p><h3 id="委托属性"><a href="#委托属性" class="headerlink" title="委托属性"></a>委托属性</h3><h4 id="直接委托"><a href="#直接委托" class="headerlink" title="直接委托"></a>直接委托</h4><p>从 Kotlin 1.4 开始可以直接在语法层面将一个属性委托给另一个属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Foo().run &#123;<br>        println(<span class="hljs-string">&quot;count = <span class="hljs-variable">$count</span> | total = <span class="hljs-variable">$total</span>&quot;</span>)<br>        count = <span class="hljs-number">1</span><br>        println(<span class="hljs-string">&quot;count = <span class="hljs-variable">$count</span> | total = <span class="hljs-variable">$total</span>&quot;</span>)<br>        total = <span class="hljs-number">2</span><br>        println(<span class="hljs-string">&quot;count = <span class="hljs-variable">$count</span> | total = <span class="hljs-variable">$total</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> total <span class="hljs-keyword">by</span> ::count<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况下<code>count</code>和<code>total</code>是完全一致的，因为<code>total</code>的 getter 和 setter 都委托给了<code>count</code>。其中<code>count</code>前面的两个冒号代表属性的引用。</p><h4 id="懒加载委托"><a href="#懒加载委托" class="headerlink" title="懒加载委托"></a>懒加载委托</h4><p>懒加载的应用非常广泛，对于一些需要消耗较多资源的操作，如果希望它只有在被访问的时候才去执行（从而避免不必要的资源开销），就可以使用懒加载。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(result)<br>    println(result)<br>&#125;<br><br><span class="hljs-keyword">val</span> result: String <span class="hljs-keyword">by</span> lazy &#123;<br>    request()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>: String &#123;<br>    println(<span class="hljs-string">&quot;这里执行一些耗时的请求操作&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;请求结果&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面模拟了一个网络请求，<code>result</code>通过<code>by lazy</code>进行委托，也就是只有在调用到<code>result</code>的时候才会去执行 Lambda 中的代码。主函数中第一次调用<code>result</code>触发了懒加载，执行了<code>request()</code>，返回了一个字符串，而当第二次调用<code>result</code>的时候，因为已经知道了<code>result</code>的值，所以就直接返回了字符串，而没有再去执行<code>request()</code>中的内容。</p><p>另外，<code>lazy()</code>是一个高阶函数，函数接收两个参数，一个是<code>LazyThreadSafetyMode</code>枚举，一个是函数类型的参数。如果不传这个枚举参数的话，实际上调用的是单参数版本的<code>lazy()</code>，而单参数的<code>lazy()</code>默认就是调用<code>SynchronizedLazyImpl()</code>这个线程同步的实现。</p><h4 id="观察者委托"><a href="#观察者委托" class="headerlink" title="观察者委托"></a>观察者委托</h4><p><a href="https://kotlinlang.org/docs/delegated-properties.html">&#x2F;&#x2F; TODO</a></p><h4 id="映射委托"><a href="#映射委托" class="headerlink" title="映射委托"></a>映射委托</h4><p><a href="https://kotlinlang.org/docs/delegated-properties.html">&#x2F;&#x2F; TODO</a></p><h3 id="自定义委托"><a href="#自定义委托" class="headerlink" title="自定义委托"></a>自定义委托</h3><p>自定义委托需要遵循一个格式，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomDelegate</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> string: String) &#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> string<br>    &#125;<br><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">String</span>)</span></span> &#123;<br>        string = value<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Owner</span> &#123;<br>    <span class="hljs-keyword">var</span> text: String <span class="hljs-keyword">by</span> CustomDelegate(<span class="hljs-string">&quot;Foobar&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>有 3 点需要注意：</p><ul><li>对于<code>var</code>修饰的属性来说，需要有<code>getValue()</code>和<code>setValue()</code>，同时这两个函数需要被<code>operator</code>关键字修饰。</li><li>变量<code>text</code>位于<code>Owner</code>类中，所以<code>getValue()</code>和<code>setValue()</code>中的第一个参数需要是<code>Owner</code>类或者是它的父类。</li><li>变量<code>text</code>是 String 类型，所以<code>getValue()</code>的返回值类型和<code>setValue()</code>的第三个参数都应该要是 String 类型或者是它的父类。</li></ul><p>如果觉得手动编写过于繁琐，还可以通过实现 Kotlin 官方提供的接口的形式来快速自定义委托，对于<code>val</code>声明的属性，就需要继承<code>ReadOnlyProperty</code>接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Base interface that can be used for implementing property delegates of read-only properties.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This is provided only for convenience; you don&#x27;t have to extend this interface</span><br><span class="hljs-comment"> * as long as your property delegate has methods with the same signatures.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> T the type of object which owns the delegated property.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> V the type of the property value.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-keyword">interface</span> ReadOnlyProperty<span class="hljs-type">&lt;in T, out V&gt;</span> &#123;</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the value of the property for the given object.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> thisRef the object for which the value is requested.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> property the metadata for the property.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the property value.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">T</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: V<br>&#125;<br></code></pre></td></tr></table></figure><p>注意一下，<code>ReadOnlyProperty()</code>使用<code>fun interface</code>进行声明，说明在 Kotlin 中，它就是一个符合 SAM 规则的函数式接口，事实上它也的确只有一个函数。</p><p>言归正传，对于<code>var</code>声明的属性来说，就需要继承<code>ReadWriteProperty</code>接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Base interface that can be used for implementing property delegates of read-write properties.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This is provided only for convenience; you don&#x27;t have to extend this interface</span><br><span class="hljs-comment"> * as long as your property delegate has methods with the same signatures.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> T the type of object which owns the delegated property.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> V the type of the property value.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReadWriteProperty</span>&lt;<span class="hljs-type">in T, V</span>&gt; : <span class="hljs-type">ReadOnlyProperty</span>&lt;<span class="hljs-type">T, V</span>&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the value of the property for the given object.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> thisRef the object for which the value is requested.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> property the metadata for the property.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the property value.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">T</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: V<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Sets the value of the property for the given object.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> thisRef the object for which the value is requested.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> property the metadata for the property.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value the value to set.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">T</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">V</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Owner().run &#123;<br>        println(text)<br>        text = <span class="hljs-string">&quot;666&quot;</span><br>        println(text)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Owner</span> &#123;<br>    <span class="hljs-keyword">var</span> text: String <span class="hljs-keyword">by</span> CustomDelegate(<span class="hljs-string">&quot;Foobar&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomDelegate</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> string: String) : ReadWriteProperty&lt;Owner, String&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> string<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">String</span>)</span></span> &#123;<br>        string = value<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果是：</p><blockquote><p>Foobar<br>666</p></blockquote><p>另外，如果想在属性委托之前再做一些额外的判断工作，还可以使用 provideDelegate 来实现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Owner().run &#123;<br>        println(textA)<br>        println(textB)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Owner</span> &#123;<br>    <span class="hljs-keyword">var</span> textA <span class="hljs-keyword">by</span> SmartDelegator()<br>    <span class="hljs-keyword">var</span> textB <span class="hljs-keyword">by</span> SmartDelegator()<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomDelegate</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> string: String) : ReadWriteProperty&lt;Owner, String&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> string<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">String</span>)</span></span> &#123;<br>        string = value<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartDelegator</span> &#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideDelegate</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        thisRef: <span class="hljs-type">Owner</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        property: <span class="hljs-type">KProperty</span>&lt;*&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: ReadWriteProperty&lt;Owner, String&gt; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (property.name.contains(<span class="hljs-string">&quot;A&quot;</span>)) CustomDelegate(<span class="hljs-string">&quot;part A&quot;</span>)<br>        <span class="hljs-keyword">else</span> CustomDelegate(<span class="hljs-string">&quot;part B&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如上面这个例子，把<code>Owner</code>的两个属性委托给了<code>SmartDelegator</code>类，而这个类中有一个<code>provideDelegate()</code>，该函数被<code>operator</code>关键字修饰，然后可以对委托进来的属性进行一些判断，最后返回不一样的实现了<code>ReadWriteProperty</code>接口的对象。</p><h3 id="案例-属性封装"><a href="#案例-属性封装" class="headerlink" title="案例 - 属性封装"></a>案例 - 属性封装</h3><p>在类中，对于那些希望只被访问但是不能被修改的属性，可以用<code>val</code>来修饰。但这也仅限于一般数据类型，对于集合来说，只要拿到了实例，就可以调用修改集合的函数。针对这种情况，可以使用委托将一个不可变集合委托给一个可变集合：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Foo().run &#123;<br>        println(bar.size)  <span class="hljs-comment">// 正常访问</span><br>        <span class="hljs-comment">//bar.add()  // 无法使用，因为是不可变的集合</span><br>        <span class="hljs-comment">//bar = listOf()  // 属性被 val 修饰，不可修改</span><br>        addInt(<span class="hljs-number">1</span>)<br>        addInt(<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> bar) println(i)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-keyword">val</span> bar: List&lt;<span class="hljs-built_in">Int</span>&gt; <span class="hljs-keyword">by</span> ::_bar  <span class="hljs-comment">// 不可变集合，用于给外界访问</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _bar = mutableListOf&lt;<span class="hljs-built_in">Int</span>&gt;()  <span class="hljs-comment">// 可变集合</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addInt</span><span class="hljs-params">(element: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        _bar.add(element)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，当需要访问集合时就调用<code>bar</code>，但是却不能直接调用集合的<code>add()</code>等函数。</p><h3 id="案例-数据绑定"><a href="#案例-数据绑定" class="headerlink" title="案例 - 数据绑定"></a>案例 - 数据绑定</h3><p>如果需要将控件上的某个属性与代码中的某个变量进行绑定，可以使用 DataBinding ，但是除了 DataBinding 以外，也可以使用自定义委托来实现，这种方式不一定完美，但也算是个有趣的思路。</p><p>这里以修改 TextView 上的文本为例，这是 XML 部分：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/textView&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Foobar&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>然后在 MainActivity 中定义一个顶层函数，同时也是 TextView 的扩展函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> TextView.<span class="hljs-title">provideDelegate</span><span class="hljs-params">(value: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span> =<br>    <span class="hljs-keyword">object</span> : ReadWriteProperty&lt;Any?, String?&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: String = text.toString()<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">String</span>?)</span></span> &#123;<br>            text = value<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>接着是使用部分：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> tv = findViewById&lt;TextView&gt;(R.id.textView)<br><span class="hljs-keyword">var</span> text: String? <span class="hljs-keyword">by</span> tv<br><br>Log.d(<span class="hljs-string">&quot;@@@&quot;</span>, text.toString())<br>text = <span class="hljs-string">&quot;666&quot;</span><br>Log.d(<span class="hljs-string">&quot;@@@&quot;</span>, tv.text.toString())<br></code></pre></td></tr></table></figure><p>将变量<code>text</code>的 getter 和 setter 托管给了 TextView ，在<code>TextView.provideDelegate()</code>中将其与 TextView 的<code>text</code>属性相关联。最终程序运行会先打印 TextView 在 XML 中定义的文本，修改了<code>text</code>变量后，再打印就会得到修改后的结果。</p><h3 id="案例-ViewModel-委托"><a href="#案例-ViewModel-委托" class="headerlink" title="案例 - ViewModel 委托"></a>案例 - ViewModel 委托</h3><p>ViewModel 在 Android 中经常用来存储界面数据，但是 ViewModel 的实例并不会被直接创建，而是使用委托的方式来获得。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 假设自定义的 ViewModel 类叫 MainViewModel</span><br><span class="hljs-keyword">val</span> viewModel: MainViewModel <span class="hljs-keyword">by</span> viewModels()<br></code></pre></td></tr></table></figure><p>稍微看一下<code>viewModels()</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> VM : ViewModel&gt;</span> ComponentActivity.<span class="hljs-title">viewModels</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">noinline</span> extrasProducer: (() -&gt; <span class="hljs-type">CreationExtras</span>)? = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">noinline</span> factoryProducer: (() -&gt; <span class="hljs-type">Factory</span>)? = <span class="hljs-literal">null</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: Lazy&lt;VM&gt; &#123;<br>    <span class="hljs-keyword">val</span> factoryPromise = factoryProducer ?: &#123;<br>        defaultViewModelProviderFactory<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ViewModelLazy(<br>        VM::<span class="hljs-keyword">class</span>,<br>        &#123; viewModelStore &#125;,<br>        factoryPromise,<br>        &#123; extrasProducer?.invoke() ?: <span class="hljs-keyword">this</span>.defaultViewModelCreationExtras &#125;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>点进<code>Lazy</code>接口中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Represents a value with lazy initialization.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * To create an instance of [Lazy] use the [lazy] function.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lazy</span>&lt;<span class="hljs-type">out T</span>&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Gets the lazily initialized value of the current Lazy instance.</span><br><span class="hljs-comment">     * Once the value was initialized it must not change during the rest of lifetime of this Lazy instance.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> value: T<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns `true` if a value for this Lazy instance has been already initialized, and `false` otherwise.</span><br><span class="hljs-comment">     * Once this function has returned `true` it stays `true` for the rest of lifetime of this Lazy instance.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isInitialized</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到：</p><ul><li><code>viewModels()</code>是<code>ComponentActivity</code>的扩展函数，所以可以直接在 Activity 中调用<code>viewModels()</code>。</li><li><code>viewModels()</code>返回<code>Lazy</code>接口，而<code>ViewModelLazy</code>是<code>Lazy</code>接口的一个实现类。</li><li><code>Lazy</code>接口中的<code>value</code>属性是用<code>val</code>修饰的，但是接口内并没有定义<code>getValue()</code>，之所以能实现委托，是因为它把<code>getValue()</code>作为扩展函数来定义了。</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在编程时会经常强调“代码复用”，而泛型的存在也算是提供了一种复用的方案。</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>假设要编写遥控器类，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 小米电视</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MiTVController</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">on</span><span class="hljs-params">()</span></span> &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">off</span><span class="hljs-params">()</span></span> &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 索尼电视</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SonyTVController</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">on</span><span class="hljs-params">()</span></span> &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">off</span><span class="hljs-params">()</span></span> &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// TCL 电视</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TclTVController</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">on</span><span class="hljs-params">()</span></span> &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">off</span><span class="hljs-params">()</span></span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是针对每一个电视机品牌都需要编写开机和关机的函数实在是过于麻烦，而借助泛型，就可以实现“万能遥控”：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 尖括号中的 MiTVController 为泛型实参</span><br>    TvController&lt;MiTV&gt;().on(MiTV())<br>&#125;<br><br><span class="hljs-comment">// T 为泛型形参</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TvController</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">on</span><span class="hljs-params">(tv: <span class="hljs-type">T</span>)</span></span> &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">off</span><span class="hljs-params">(tv: <span class="hljs-type">T</span>)</span></span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MiTV</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SonyTV</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TclTV</span><br></code></pre></td></tr></table></figure><p>泛型的形参<code>T</code>代表了可以传入任意类型，借助这个特性，无论是什么品牌的电视，都可以用这个遥控器来实现开关机。</p><p>泛型的形参也可以进行范围限制，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    TvController&lt;MiTV&gt;().on(MiTV())<br>&#125;<br><br><span class="hljs-comment">// 在形参中添加上界</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TvController</span>&lt;<span class="hljs-type">T : TV</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">on</span><span class="hljs-params">(tv: <span class="hljs-type">T</span>)</span></span> &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">off</span><span class="hljs-params">(tv: <span class="hljs-type">T</span>)</span></span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TV</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MiTV</span> : <span class="hljs-type">TV</span>()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SonyTV</span> : <span class="hljs-type">TV</span>()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TclTV</span> : <span class="hljs-type">TV</span>()<br></code></pre></td></tr></table></figure><p>以上代码修改了<code>TvController</code>的形参，这样一来，<code>TvController</code>就只能接收<code>TV</code>类的子类，这叫做泛型的上界。</p><p>除了类能使用泛型，Kotlin 中的函数也能使用泛型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    turnOnTV(MiTV())<br>&#125;<br><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TV</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MiTV</span> : <span class="hljs-type">TV</span>()<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : TV&gt;</span> <span class="hljs-title">turnOnTV</span><span class="hljs-params">(tv: <span class="hljs-type">T</span>)</span></span> &#123;<br>    println(<span class="hljs-string">&quot;打开电视&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型不变性"><a href="#泛型不变性" class="headerlink" title="泛型不变性"></a>泛型不变性</h3><p>假设一个类是另一个类的子类，那么这个类的集合和它父类的集合之间是什么关系呢：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    foo(mutableListOf(Animal()))  <span class="hljs-comment">// 报错，传入类型错误</span><br>    bar(mutableListOf(Cat()))<br>&#125;<br><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-type">Animal</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-type">Animal</span>()<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(list: <span class="hljs-type">MutableList</span>&lt;<span class="hljs-type">Cat</span>&gt;)</span></span> &#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">(list: <span class="hljs-type">MutableList</span>&lt;<span class="hljs-type">Animal</span>&gt;)</span></span> &#123;<br>    list.add(Dog())<br>    <span class="hljs-keyword">val</span> firstAnimal: Dog = list.first()  <span class="hljs-comment">// 报错，父类无法转成子类</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结论是没什么关系，它们之间也无法替代对方，这就是泛型的不变性。泛型的不变性保证了程序上不会出现一些逻辑性错误。</p><h3 id="协变（Covariant）"><a href="#协变（Covariant）" class="headerlink" title="协变（Covariant）"></a>协变（Covariant）</h3><p>众所周知，在代码中，是可以往需要父类对象的地方传入子类对象的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    test(Son())  <span class="hljs-comment">// 需要传入 Father 类，但是却传入了 Son 类，也没问题</span><br>&#125;<br><br><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span><br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-type">Father</span>()<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(father: <span class="hljs-type">Father</span>)</span></span> &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>那么在需要父类泛型的地方可以传入子类泛型吗？根据前面提到的泛型的不变性，两者间并不存在什么关系，所以这样做，编译器会报错：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    test(Foo&lt;Son&gt;())  <span class="hljs-comment">// 报错，需要传父类泛型，但是却传了子类泛型</span><br>&#125;<br><br><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span><br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-type">Father</span>()<br><br><span class="hljs-comment">// 泛型类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用泛型类的函数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(foo: <span class="hljs-type">Foo</span>&lt;<span class="hljs-type">Father</span>&gt;)</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可是在某些特殊场景下确实是要这么做，那应该怎么让编译器通过编译呢，这时候就可以使用到泛型的 <strong>协变</strong> ，协变可以在使用处或者是声明处使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 使用处协变</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(foo: <span class="hljs-type">Foo</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">Father</span>&gt;)</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 声明处协变</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&lt;<span class="hljs-type">out T</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，就可以在需要父类泛型的地方传入子类泛型了。Kotlin 中使用<code>out</code>来表示协变，对应 Java 中的<code>extends</code>。</p><h3 id="逆变（Contravariant）"><a href="#逆变（Contravariant）" class="headerlink" title="逆变（Contravariant）"></a>逆变（Contravariant）</h3><p>协变会让父类的泛型与子类的泛型之间产生类似于父类本身与子类本身之间的关系（也就是需要父类的地方可以传入子类），而逆变就是让这个关系反过来：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    test(Foo&lt;Father&gt;())  <span class="hljs-comment">// 报错，需要传子类泛型，但是却传了父类泛型</span><br>&#125;<br><br><span class="hljs-comment">// 省略中间这部分代码</span><br><br><span class="hljs-comment">// 使用泛型类的函数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(foo: <span class="hljs-type">Foo</span>&lt;<span class="hljs-type">Son</span>&gt;)</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>同样是在使用处或者是声明处，添加<code>in</code>关键字就可以解决编译问题：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 使用处协变</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(foo: <span class="hljs-type">Foo</span>&lt;<span class="hljs-type">in</span> <span class="hljs-type">Son</span>&gt;)</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 声明处协变</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&lt;<span class="hljs-type">in T</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Kotlin 中使用<code>in</code>来表示逆变，对应 Java 中的<code>super</code>。</p><p>那么该如何记忆协变对应<code>out</code>，逆变对应<code>in</code>呢，我觉得可以这样理解：in 的意思是在什么的里面，子类往往是父类的扩展（父类有的子类都有，子类有的父类不一定有），所以如果画图来表示的话，父类是被“包含”在子类里面的，所以当遇到<code>&lt;in T&gt;</code>时，我们就可以知道，这个地方可以传入 T 的父类。因为“T 的父类 in T”。</p><h3 id="星投影（Star-Projections）"><a href="#星投影（Star-Projections）" class="headerlink" title="星投影（Star-Projections）"></a>星投影（Star-Projections）</h3><p>Kotlin 可以使用星号<code>*</code>来作为泛型的实参：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    bar(Foo&lt;<span class="hljs-built_in">Int</span>&gt;())  <span class="hljs-comment">// 可以传入整型</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&lt;<span class="hljs-type">T</span>&gt;<br><br><span class="hljs-comment">// 使用星投影</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">(foo: <span class="hljs-type">Foo</span>&lt;*&gt;)</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Foo</code>类在声明形参时使用了<code>T</code>，代表了这是个泛型，并不关心传入什么类型进来。然而<code>bar()</code>在使用泛型的时候在实参中使用了<code>*</code>，也是代表它并不关心传入什么类型，把最终的决定权放在了调用<code>bar()</code>的地方，所以在<code>main()</code>中就直接传入了整型。也就是说，星投影是在我们不关心实参到底是什么的时候就可以使用。</p><p>要想稍加限制也可以，只要在形参处进行限制就行了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// bar(Foo&lt;String&gt;())  // 报错</span><br>    bar(Foo&lt;MyActivity&gt;())<br>&#125;<br><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&lt;<span class="hljs-type">T : Activity</span>&gt;  // 传进来的参数需要是 <span class="hljs-title">Activity</span> 类或者是它的子类<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyActivity</span> : <span class="hljs-type">Activity</span>() &#123;<br><br>&#125;<br><br><span class="hljs-comment">// 使用星投影</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">(foo: <span class="hljs-type">Foo</span>&lt;*&gt;)</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，虽然<code>bar()</code>选择摆烂，但是真正在调用<code>bar()</code>传参数的时候，还是会收到<code>Foo</code>类的约束。</p><h3 id="in-还是-out-？"><a href="#in-还是-out-？" class="headerlink" title="in 还是 out ？"></a>in 还是 out ？</h3><p>前面稍微提到了如何记忆和使用 in 与 out ，不过实际上也没有那么复杂，无论是 Java 还是 Kotlin 的泛型，都提到了另外两个词：生产者和消费者。前者对应 out ，而后者对应 in 。</p><p>用通俗的话来说，被 in 修饰的泛型，往往会以函数的参数的形式，被传入函数里面，这是一种写入行为。而被 out 修饰的泛型，往往会以返回值的形式，被函数返回，这是一种读取行为。总的来说，传入用 in ，传出用 out ，泛型作为参数的时候用 in ，泛型作为返回值的时候用 out 。接下来看一下 Kotlin 官方的用例吧：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;<span class="hljs-type">in T</span>&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(other: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Int</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;<span class="hljs-type">out T</span>&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">next</span><span class="hljs-params">()</span></span>: T<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注解与反射"><a href="#注解与反射" class="headerlink" title="注解与反射"></a>注解与反射</h2><p>泛型提高了代码的复用性，注解与反射则是提高了代码的灵活性。</p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>注解可以理解为对程序代码的一种补充，最常见的注解，例如 Java 中的<code>@Override</code>代表重写，以及<code>@Deprecated</code>代表了函数被弃用，以及 Jetpack Compose 中的<code>@Composable</code>代表了定义一个可组合项。</p><p>那么什么是“元注解”呢，在<code>@Deprecated</code>中可以看到，在<code>Deprecated</code>类的上面还有<code>@Target</code>和<code>@MustBeDocumented</code>，像这种本身既是注解，又可以修饰其它注解的就是元注解。</p><p>Kotlin 常见的元注解有四个：</p><ul><li><code>@Target</code>：指定了被修饰的注解可以用在什么地方，也就是目标。</li><li><code>@Retention</code>：指定了被修饰的注解是否编译后可见、是否运行时可见，也就是注解的保留位置，是保留在编译时还是运行时。</li><li><code>@Repeatable</code>：允许在同一个地方多次使用相同的被修饰的注解，使用场景比较少。</li><li><code>@MustBeDocumented</code>：指定被修饰的注解应该在生成的 API 文档中显示，这个注解一般用于 SDK 当中。</li></ul><p>其中<code>@Target</code>有很多可取值，代表了它可以用来修饰什么：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationTarget</span> &#123;<br>    <span class="hljs-comment">/** Class, interface or object, annotation class is also included */</span><br>    CLASS,<br>    <span class="hljs-comment">/** Annotation class only */</span><br>    ANNOTATION_CLASS,<br>    <span class="hljs-comment">/** Generic type parameter */</span><br>    TYPE_PARAMETER,<br>    <span class="hljs-comment">/** Property */</span><br>    PROPERTY,<br>    <span class="hljs-comment">/** Field, including property&#x27;s backing field */</span><br>    FIELD,<br>    <span class="hljs-comment">/** Local variable */</span><br>    LOCAL_VARIABLE,<br>    <span class="hljs-comment">/** Value parameter of a function or a constructor */</span><br>    VALUE_PARAMETER,<br>    <span class="hljs-comment">/** Constructor only (primary or secondary) */</span><br>    CONSTRUCTOR,<br>    <span class="hljs-comment">/** Function (constructors are not included) */</span><br>    FUNCTION,<br>    <span class="hljs-comment">/** Property getter only */</span><br>    PROPERTY_GETTER,<br>    <span class="hljs-comment">/** Property setter only */</span><br>    PROPERTY_SETTER,<br>    <span class="hljs-comment">/** Type usage */</span><br>    TYPE,<br>    <span class="hljs-comment">/** Any expression */</span><br>    EXPRESSION,<br>    <span class="hljs-comment">/** File */</span><br>    FILE,<br>    <span class="hljs-comment">/** Type alias */</span><br>    <span class="hljs-meta">@SinceKotlin(<span class="hljs-string">&quot;1.1&quot;</span>)</span><br>    TYPEALIAS<br>&#125;<br></code></pre></td></tr></table></figure><p>同样在<code>@Retention</code>中的取值也值得注意：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationRetention</span> &#123;<br>    <span class="hljs-comment">/** Annotation isn&#x27;t stored in binary output */</span><br>    <span class="hljs-comment">/** 注解只存在于源代码，编译后不可见 */</span><br>    SOURCE,<br>    <span class="hljs-comment">/** Annotation is stored in binary output, but invisible for reflection */</span><br>    <span class="hljs-comment">/** 注解编译后可见，运行时不可见 */</span><br>    BINARY,<br>    <span class="hljs-comment">/** Annotation is stored in binary output and visible for reflection (default retention) */</span><br>    <span class="hljs-comment">/** 注解编译后可见，运行时可见 */</span><br>    RUNTIME<br>&#125;<br></code></pre></td></tr></table></figure><p>那么该如何使用注解，以<code>@Deprecated</code>修饰函数为例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Deprecated(</span><br><span class="hljs-meta">    message = <span class="hljs-string">&quot;请使用 newFoo() 代替&quot;</span>,</span><br><span class="hljs-meta">    replaceWith = ReplaceWith(<span class="hljs-string">&quot;newFoo()&quot;</span>),</span><br><span class="hljs-meta">    level = DeprecationLevel.ERROR</span><br><span class="hljs-meta">)</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">oldFoo</span><span class="hljs-params">()</span></span> &#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">newFoo</span><span class="hljs-params">()</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里定义了两个函数，我们假装<code>oldFoo()</code>是过时的函数，需要用<code>newFoo()</code>来代替它，所以我们使用了<code>@Deprecated</code>来修饰<code>oldFoo()</code>，并补充了 3 个参数，包括关于废弃它的信息，以及应该用什么函数来代替，以及使用这个废弃的函数的严重程度。关于第 3 个参数，在这里定义的是<code>DeprecationLevel.ERROR</code>，这就代表使用这个函数会被编译器视为错误，从而无法通过编译。而当鼠标移到<code>oldFoo()</code>的调用处上面时，IDE 还会提供快速修复选项（如果有定义的话），在这里就是将<code>oldFoo()</code>替换成<code>newFoo()</code>。</p><p>Kotlin 的注解还有一个细节就是注解的精确使用目标，例如在使用依赖注入框架时，如果去标记一个被<code>var</code>修饰的属性，那么编译器会报错，因为被<code>var</code>修饰的属性包含了属性背后的字段、getter、setter 三个含义，如果不明确标记其中之一，编译器根本不知道该怎么做。例如使用 Dagger ，要标记 setter ，那么只需要在属性上方插入：<code>@set:Inject</code>即可。除了 set 以外，Kotlin 当中还有其它的使用目标：</p><ul><li>file：作用于文件</li><li>property：作用于属性</li><li>field：作用于字段</li><li>get：作用于属性 getter</li><li>set：作用于属性 setter</li><li>receiver：作用于扩展的接受者参数</li><li>param：作用于构造函数参数</li><li>setparam：作用于函数参数</li><li>delegate：作用于委托字段</li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>Kotlin 反射具备这三个特质：</p><ul><li>感知程序的状态，包含程序的运行状态和源代码结构。</li><li>修改程序的状态。例如修改某个变量，即使这个变量是被<code>private</code>或者<code>final</code>修饰的。</li><li>根据程序的状态调整自身的决策行为。例如 JSON 解析经常会用到<code>@SerializedName</code>这个注解，如果属性有<code>@SerializedName</code>修饰的话，解析时就会以指定的名称为准，如果没有，那就直接使用属性的名称来解析。</li></ul><p>来看一个感知程序状态的简单案例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> kotlin.reflect.full.functions<br><span class="hljs-keyword">import</span> kotlin.reflect.full.memberProperties<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    readMembers(Student(<span class="hljs-string">&quot;Aiden&quot;</span>, <span class="hljs-number">23</span>))<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span> &#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readMembers</span><span class="hljs-params">(obj: <span class="hljs-type">Any</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 打印属性</span><br>    obj::<span class="hljs-keyword">class</span>.memberProperties.forEach &#123;<br>        println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;obj::class.simpleName&#125;</span>.<span class="hljs-subst">$&#123;it.name&#125;</span> = <span class="hljs-subst">$&#123;it.getter.call(obj)&#125;</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 打印函数</span><br>    obj::<span class="hljs-keyword">class</span>.functions.forEach &#123;<br>        println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;it.name&#125;</span>()&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果是：</p><blockquote><p>Student.age &#x3D; 23<br>Student.name &#x3D; Aiden<br>study()<br>equals()<br>hashCode()<br>toString()</p></blockquote><ul><li><code>readMembers()</code>接收了一个<code>Any</code>类型的参数，也就是任何类都可以通过反射来获取成员属性和函数。</li><li><code>obj::class</code>叫类引用，是 Kotlin 反射的语法，通过该语法就可以拿到一个<code>KClass</code>接口，通过这个接口间接拿到实际的类的成员信息。</li><li>通过调用<code>memberProperties</code>就可以拿到类的属性的集合，在这里利用<code>forEach</code>遍历集合就拿到了<code>Student</code>类中的<code>name</code>属性和<code>age</code>属性。值得补充的是，<code>memberProperties</code>是<code>KClass</code>的扩展属性，定义于 Kotlin 的反射库中（需要在 Gradle 中引入这个库），而<code>KClass</code>是默认存在于标准库中的，也就是说，要想使用完整的反射，需要引入反射库。</li><li>调用<code>memberProperties</code>返回的是一个集合：<code>Collection&lt;KProperty1&lt;T, *&gt;&gt;</code>，<code>KClass</code>代表的是类的反射，而<code>KProperty1</code>就代表的是属性的反射了，通过调用<code>KProperty1.name</code>就可以拿到属性的名称，然后调用<code>KProperty1.getter.call()</code>就可以获取属性的值。另外这里的<code>getter</code>实际上是<code>KProperty1</code>中的属性，是<code>Getter&lt;T, out V&gt;</code>类型，而它又实现了<code>KProperty.Getter&lt;out V&gt;</code>接口，而它又实现了<code>KFunction&lt;out R&gt;</code>接口，而它又实现了<code>KCallable&lt;out R&gt;</code>，这就是可以调用<code>call()</code>的原因。</li></ul><p>接下来是一个修改属性值的案例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    changeName(Student(<span class="hljs-string">&quot;Aiden&quot;</span>, <span class="hljs-number">23</span>))<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">changeName</span><span class="hljs-params">(obj: <span class="hljs-type">Any</span>)</span></span> &#123;<br>    obj::<span class="hljs-keyword">class</span>.memberProperties.forEach &#123;<br>        <span class="hljs-keyword">if</span> (it.getter.call(obj) == <span class="hljs-string">&quot;Aiden&quot;</span> &amp;&amp; it <span class="hljs-keyword">is</span> KMutableProperty1 &amp;&amp; it.setter.parameters.size == <span class="hljs-number">2</span> &amp;&amp; it.getter.returnType.classifier == String::<span class="hljs-keyword">class</span>) &#123;<br>            it.setter.call(obj, <span class="hljs-string">&quot;Marcus&quot;</span>)<br>            println(it.getter.call(obj))<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果是：</p><blockquote><p>Marcus</p></blockquote><ul><li>在<code>changeName()</code>中遍历属性，并通过反射进行各种判断，包括但不限于：<ul><li>通过<code>it.getter.call(obj) == &quot;Aiden&quot;</code>判断属性的值是否为<code>Aiden</code>；</li><li>通过<code>it is KMutableProperty1</code>判断这个属性是否被<code>var</code>修饰；</li><li>通过<code>it.setter.parameters.size == 2</code>判断如果要修改这个属性的话需要传几个参数，在这里是两个参数，一个是 obj 本身，另一个是新值；</li><li>通过<code>it.getter.returnType.classifier == String::class</code>判断属性的返回值是否为<code>String</code>类型。</li></ul></li><li>接着通过<code>setter.call()</code>来修改属性值。不过在调用这个函数前还需要用<code>it is KMutableProperty1</code>来判断属性是否可被修改，否则就调用不了<code>setter</code>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android 学习笔记 - Service</title>
    <link href="/post/Android-Study-Guide-Service/"/>
    <url>/post/Android-Study-Guide-Service/</url>
    
    <content type="html"><![CDATA[<p>Service 是 Android 中实现程序后台运行的解决方案，它的存在不依赖于任何用户界面。</p><span id="more"></span><p>尽管如此，Service 在创建时仍然依附于创建它的应用进程，如果这个应用进程被杀掉，那么所有依赖于这个进程的 Service 也会停止工作。虽然 Service 是后台运行，但是其并不会自主开启线程，所有的代码默认仍然运行在主线程中。</p><h2 id="使用-Service"><a href="#使用-Service" class="headerlink" title="使用 Service"></a>使用 Service</h2><p>想要使用 Service ，就需要新建一个类去继承<code>Service</code>类，这个操作可以通过 Android Studio 来快捷执行。创建好 Service 后可以重写以下几个方法：</p><ul><li><code>onCreate()</code>：这是最先接收到的回调，在 Service 创建的时候调用。</li><li><code>onStartCommand(intent: Intent?, flags: Int, startId: Int)</code>：在 Service 每次启动的时候调用。如果只需要绑定 Service ，那可以不实现这个方法。</li><li><code>onBind()</code>：当其它组件需要和 Service 进行绑定时，会调用<code>bindService()</code>，这个方法会回调<code>onBind()</code>，<code>onBind()</code>会提供一个 IBinder 接口，该接口用于在绑定的组件和 Service 间进行通信。如果<code>onBind()</code>返回<code>null</code>则表示 Service 不希望被绑定。</li><li><code>onDestroy()</code>：用于清理资源，是 Service 接收的最后一个回调，在 Service 销毁的时候调用。</li></ul><p>Service 在创建好后同样需要在<code>AndroidManifest.xml</code>中注册，只不过如果这个 Service 是通过 Android Studio 快捷创建的话，那么 Android Studio 会自动帮忙完成注册。接着可以通过<code>startService()</code>和<code>stopService()</code>来启动和停止 Service ，这两个方法都是定义在 Context 类中的，所以可以直接在 Activity 中调用。另外也可以在 Service 中调用<code>stopSelf()</code>来自我停止运行。</p><p>从 Android 5.0 API 21 开始，如果往<code>bindService()</code>中传入隐式 Intent 会导致系统抛出异常，所以启动 Service 时应始终使用显式 Intent 。</p><p>可以在<code>AndroidManifest.xml</code>的<code>&lt;service&gt;</code>标签内通过<code>android:description</code>来为该 Service 添加一个简短的描述，告知用户 Service 的用途，避免用户因为不信任而终止 Service 。</p><h2 id="使用-IntentService"><a href="#使用-IntentService" class="headerlink" title="使用 IntentService"></a>使用 IntentService</h2><p><code>IntentService</code>是<code>Service</code>的子类，相比 Service 它更适用于单线程的场景。想要使用 IntentService 只需新建一个类去继承<code>IntentService</code>，然后重写<code>onHandleIntent()</code>即可。IntentService 使用工作线程逐一处理所有启动请求，<code>onHandleIntent()</code>会接收每个启动请求的 Intent ，以便执行后台工作。IntentService 具有以下特点：</p><ul><li>在处理完所有启动请求后自动终止，因此不必调用<code>stopSelf()</code>。</li><li>提供<code>onBind()</code>的默认实现（返回<code>null</code>）。</li><li>提供<code>onStartCommand()</code>的默认实现，可将 Intent 依次发送到工作队列和<code>onHandleIntent()</code>实现。</li><li><code>onHandleIntent()</code>中的操作默认位于子线程中，无需担心出现 ANR 。</li></ul><p>在继承<code>IntentService</code>的时候需要调用其构造函数并传入一个字符串参数，这个字符串将作为工作线程的名称。如果还要实现其它的回调，例如<code>onStartCommand()</code>，则必须要调用父类的方法（<code>onBind()</code>除外），只有这样 IntentService 才能正确处理工作线程的生命周期。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Intent(<span class="hljs-keyword">this</span>, MyIntentService::<span class="hljs-keyword">class</span>.java).also &#123;<br>    it.putExtra(<span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;Hello&quot;</span>)<br>    startService(it)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIntentService</span> : <span class="hljs-type">IntentService</span>(<span class="hljs-string">&quot;MyIntentService&quot;</span>) &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onHandleIntent</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>?)</span></span> &#123;<br>        Thread.sleep(<span class="hljs-number">5000</span>)<br>        Log.d(<span class="hljs-string">&quot;MyIntentService&quot;</span>, <span class="hljs-string">&quot;Sleep over.&quot;</span>)<br>        Log.d(<span class="hljs-string">&quot;MyIntentService&quot;</span>, <span class="hljs-string">&quot;Extra info is: <span class="hljs-subst">$&#123;intent!!.getStringExtra(<span class="hljs-string">&quot;info&quot;</span>)&#125;</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStartCommand</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>?, flags: <span class="hljs-type">Int</span>, startId: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>        Log.d(<span class="hljs-string">&quot;MyIntentService&quot;</span>, <span class="hljs-string">&quot;Service started.&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onStartCommand(intent, flags, startId)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span> &#123;<br>        Log.d(<span class="hljs-string">&quot;MyIntentService&quot;</span>, <span class="hljs-string">&quot;Service destroyed.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Activity 中构建了一个显示 Intent 并为其添加了一个字符串消息，随后调用<code>startService()</code>并将这个 Intent 传入用于启动 Service 。接着在 Service 里重写了<code>onHandleIntent()</code>和其它两个生命周期相关的方法。运行程序，在 Activity 中的<code>startService()</code>执行后，将在日志中相继看到这些输出：</p><blockquote><p>Service started.<br>Sleep over.<br>Extra info is: Hello<br>Service destroyed.</p></blockquote><p>按照前面所说，<code>onDestroy()</code>会自动执行。</p><p><code>onStartCommand()</code>返回一个整型数据，这个整型数据必须是以下 3 者之一：</p><ul><li><code>START_NOT_STICKY</code>：如果系统在<code>onStartCommand()</code>返回后终止 Service ，则除非有待传递的挂起 Intent ，否则系统不会重建 Service 。</li><li><code>START_STICKY</code>：如果系统在<code>onStartCommand()</code>返回后终止 Service ，则其会重建 Service 并调用<code>onStartCommand()</code>，但不会重新传递最后一个 Intent 。除非有挂起的 Intent 要启动 Service ，否则系统会调用包含空 Intent 的<code>onStartCommand()</code>。在此情况下，系统会传递这些 Intent 。此常量适用于不执行命令、但无限期运行并等待作业的 Service（例如媒体播放器）。</li><li><code>START_REDELIVER_INTENT</code>：如果系统在<code>onStartCommand()</code>返回后终止 Service ，则其会重建 Service ，并通过传递给 Service 的最后一个 Intent 来调用<code>onStartCommand()</code>。所有挂起的 Intent 均依次传递。此常量适用于主动执行应立即恢复的作业（例如下载文件）的 Service 。</li></ul><p>实际上，IntentService 已于 API level 30 被废弃，官方建议用 androidx.work.WorkManager 或者 androidx.core.app.JobIntentService 取而代之。</p><h2 id="绑定-Service"><a href="#绑定-Service" class="headerlink" title="绑定 Service"></a>绑定 Service</h2><p>绑定可让其他组件（Activity、Service、ContentProvider）与 Service 进行交互，想要使用绑定，就需要实现 Service 中的<code>onBind()</code>回调，此方法会返回一个 IBinder 对象，该对象定义的接口可供组件用来与 Service 进行交互。</p><p>例如 Activity 通过调用<code>bindService()</code>来和 Service 进行绑定。<code>bindService()</code>接收 3 个参数：</p><ol><li>一个指向 Service 的显式 Intent。</li><li>一个用于监控与 Service 的连接的 ServiceConnection 对象。</li><li>一个可选操作，如要创建尚未处于活动状态的 Service ，此参数通常应为<code>BIND_AUTO_CREATE</code>，其他可能的值为<code>BIND_DEBUG_UNBIND</code>和<code>BIND_NOT_FOREGROUND</code>，或者<code>0</code>（表示无此参数）。</li></ol><p><code>bindService()</code>如果返回<code>false</code>则表示绑定的 Service 不存在或者无权限与其绑定（就算返回<code>false</code>也需要调用<code>unbindService()</code>来关闭空闲的 Service）。ServiceConnection 对象需要重写<code>onServiceConnected()</code>和<code>onServiceDisconnected()</code>，其中<code>onServiceConnected()</code>的参数列表中包含一个 IBinder 类型的参数，这个参数将用于在 Activity 和 Service 间进行通信。</p><p>在实现绑定 Service 的过程中，最重要的环节是定义<code>onBind()</code>回调方法所返回的 IBinder 接口，定义 IBinder 接口主要有三种方式：继承 Binder 类、使用 Messenger、使用 AIDL 。</p><h3 id="继承-Binder-类"><a href="#继承-Binder-类" class="headerlink" title="继承 Binder 类"></a>继承 Binder 类</h3><p>如果 Service 无需跨进程工作，那么可以通过继承 Binder 类并从<code>onBind()</code>返回该类的实例来创建接口。当 Activity 在<code>onServiceConnected()</code>收到 Binder 后，可利用它直接访问 Binder 实现或 Service 中提供的公共方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> : <span class="hljs-type">Service</span>() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mBinder = MusicPlayBinder()  <span class="hljs-comment">// 创建一个实例对象</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getRandomInt</span><span class="hljs-params">()</span></span> = Random(<span class="hljs-number">100</span>).nextInt()<br><br>    <span class="hljs-keyword">inner</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MusicPlayBinder</span> : <span class="hljs-type">Binder</span>() &#123;  <span class="hljs-comment">// 继承 Binder 类</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">startPlay</span><span class="hljs-params">()</span></span> &#123;<br><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getService</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">this</span><span class="hljs-symbol">@MyService</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBind</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>)</span></span>: IBinder &#123;<br>        <span class="hljs-keyword">return</span> mBinder  <span class="hljs-comment">// 在 onBind() 回调中返回这个实例对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> connection = <span class="hljs-keyword">object</span> : ServiceConnection &#123;  <span class="hljs-comment">// 实现一个 ServiceConnection</span><br>        <span class="hljs-comment">// 重写</span><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">(name: <span class="hljs-type">ComponentName</span>?, service: <span class="hljs-type">IBinder</span>?)</span></span> &#123;<br>            <span class="hljs-keyword">val</span> musicPlayBinder = service <span class="hljs-keyword">as</span> MyService.MusicPlayBinder  <span class="hljs-comment">// 向下转型</span><br>            <span class="hljs-keyword">val</span> myService = musicPlayBinder.getService()<br><br>            musicPlayBinder.startPlay()<br>            Log.d(<span class="hljs-string">&quot;myService.RandomInt: &quot;</span>, myService.getRandomInt().toString())<br>        &#125;<br><br>        <span class="hljs-comment">// 重写</span><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceDisconnected</span><span class="hljs-params">(name: <span class="hljs-type">ComponentName</span>?)</span></span> &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 当与 Service 的连接意外中断时，例如 Service 崩溃或被终止时，系统会调用该方法。</span><br><span class="hljs-comment">             * 当 Activity 主动取消绑定时，系统不会调用该方法。</span><br><span class="hljs-comment">             */</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br><br>        <span class="hljs-keyword">val</span> button = findViewById&lt;Button&gt;(R.id.Bt)<br>        button.setOnClickListener &#123;<br>            <span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span>, MyService::<span class="hljs-keyword">class</span>.java)<br>            bindService(intent, connection, Context.BIND_AUTO_CREATE)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDestroy()<br>        unbindService(connection)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用-Messenger"><a href="#使用-Messenger" class="headerlink" title="使用 Messenger"></a>使用 Messenger</h3><p>这是执行进程间通信 (IPC) 最为简单的方式（无需使用 AIDL），就是使用 Messenger 为 Service 提供接口。</p><p><img src="/images/note/Messenger.png" alt="Messenger 流程图"></p><ul><li><a href="https://developer.android.com/guide/components/bound-services#Messenger">https://developer.android.com/guide/components/bound-services#Messenger</a></li></ul><h2 id="Service-生命周期"><a href="#Service-生命周期" class="headerlink" title="Service 生命周期"></a>Service 生命周期</h2><p><code>startService()</code>被调用后 Service 就会启动并回调<code>onStartCommand()</code>，如果这个 Service 之前还没有创建过，在执行<code>onStartCommand()</code>之前还要先执行<code>onCreate()</code>，虽然每调用一次<code>startService()</code>就会执行一次<code>onStartCommand()</code>，但实际上每个 Service 只会存在一个实例，所以不管调用了多少次<code>startService()</code>，只需调用一次<code>stopService()</code>或<code>stopSelf()</code>，Service 就会停止。</p><p>Service 的生命周期独立于启动它的组件，即使系统销毁了启动 Service 的组件，该 Service 仍可在后台无限期地运行。因此，Service 应在其工作完成时通过调用<code>stopSelf()</code>来自行停止运行，或者由另一个组件通过调用<code>stopService()</code>来将其停止。</p><p>调用<code>stopService()</code>后 Service 就会回调<code>onDestroy()</code>并销毁。调用<code>unbindService()</code>也一样。但是想要停止一个既调用了<code>startService()</code>又调用了<code>bindService()</code>的 Service ，就需要同时调用<code>stopService()</code>和<code>unbindService()</code>。</p><p>一个 Service 可以和多个 Activity 进行绑定，只不过系统会缓存 IBinder 服务通信通道，所以只在 Activity 和 Service 第一次绑定时系统才会回调<code>onBind()</code>来生成 IBinder 。接着系统就会将这个 IBinder 传递给其它绑定到这个 Service 的 Activity 。当 Service 与所有 Activity 之间的绑定全部取消时，系统才会销毁该 Service（除非还使用<code>startService()</code>启动了该 Service）。所以如果 Service 是纯粹的绑定服务，则无需对其生命周期进行管理，因为系统会自动根据它是否仍然和其它组件处于绑定状态来管理它的生命周期。</p><p>如果实现了<code>onStartCommand()</code>回调，就必须显式停止 Service ，因为系统已将 Service 视为已启动状态。在此情况下，Service 将一直运行，直到它通过<code>stopSelf()</code>自行停止或其他组件调用<code>stopService()</code>将其停止（与该 Service 是否绑定到任何组件无关）。</p><h2 id="前台-Service"><a href="#前台-Service" class="headerlink" title="前台 Service"></a>前台 Service</h2><p>从 Android 8.0 开始，应用的后台功能被大幅削弱。现在只有当应用保持在前台可见状态的情况下，Service 才能保证稳定运行，一旦应用进入后台之后，Service 随时都有可能被系统回收。如果希望 Service 能够一直保持运行状态，或者正确一点说，在应用需要在后台执行一项需要引起用户注意的任务时，就可以使用前台 Service 。前台 Service 和普通 Service 的区别就在于前者在启动后，会有一个程序图标一直显示在系统状态栏（变相让应用显示在前台，提醒用户该应用在占用资源），当用户下拉状态栏后就可以看到更加详细的信息，类似于通知的效果。系统往往也不会轻易去回收前台 Service 。</p><p>运行 Android 12 API 31 以及更高版本的设备会为短时运行的前台 Service 提供 streamlined experience 。在这些设备上，系统在显示与前台 Service 相关的通知之前会等待 10 秒。但也有少数例外。如果一个前台 Service 具有以下特征之一，则它的通知会立即显示：</p><ul><li>该前台 Service 的通知里包含操作按钮（用于快速响应的按钮，例如回复短信）。</li><li>Service 在<code>AndroidManifest.xml</code>中注册的时候，将<code>android:foregroundServiceType</code>属性设置为<code>mediaPlayback</code>、<code>mediaProjection</code>、<code>phoneCall</code>三者之一。</li><li>该 Service 提供与通话、导航或媒体播放相关的用例，如通知的分类属性中所定义的那样。</li><li>该 Service 在设置通知时调用<code>setForegroundServiceBehavior()</code>并传入<code>FOREGROUND_SERVICE_IMMEDIATE</code>。</li></ul><p>在 Android 13 API 33 之前，想要清除前台 Service 的通知，只能等待这个 Service 停止运行或者被移除前台。但是从 Android 13 API 33 开始，默认情况下，用户可以通过滑动手势清除下拉状态栏中前台 Service 的通知。如果想要通知不能被用户移除，那么就需要在使用<code>Notification.Builder</code>构建通知时调用<code>setOngoing()</code>并传入<code>true</code>。</p><p>以 Android 9.0 API 28 或更高版本为目标 SDK 的应用想要使用前台 Service 需要先在<code>AndroidManifest.xml</code>中申请<code>FOREGROUND_SERVICE</code>权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.FOREGROUND_SERVICE&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>这个权限属于普通权限，系统会自动同意的。如果不申请这个权限，系统会抛出<code>SecurityException</code>异常。</p><h3 id="使用前台-Service"><a href="#使用前台-Service" class="headerlink" title="使用前台 Service"></a>使用前台 Service</h3><p>在将 Service 设置为前台 Service 前需要先通过～～<code>startForegroundService()</code>～～<code>startService()</code>来启动 Service ，然后调用<code>startForeground()</code>来让 Service 在前台运行，<code>startForeground()</code>通常会在 Service 的<code>onStartCommand()</code>中调用，这个方法接收两个参数：第一个是一个正整数，用于唯一标识状态栏中的通知。第二个就是通知对象本身。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> : <span class="hljs-type">Service</span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> notification: Notification<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 创建一个 NotificationManager 用于创建 Channel</span><br>        <span class="hljs-keyword">val</span> manager = getSystemService(Context.NOTIFICATION_SERVICE) <span class="hljs-keyword">as</span> NotificationManager<br><br>        <span class="hljs-comment">// 创建一个 NotificationChannel</span><br>        <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;<br>            <span class="hljs-keyword">val</span> channel = NotificationChannel(<br>                <span class="hljs-string">&quot;testChannel&quot;</span>,  <span class="hljs-comment">// 设置 Channel ID</span><br>                <span class="hljs-string">&quot;前台 Service 测试&quot;</span>,  <span class="hljs-comment">// 设置 Channel 名称（在应用的详情中可以看到）</span><br>                NotificationManager.IMPORTANCE_DEFAULT  <span class="hljs-comment">// 设置 Channel 重要级别</span><br>            )<br>            manager.createNotificationChannel(channel)  <span class="hljs-comment">// 创建这个 Channel</span><br>        &#125;<br><br>        <span class="hljs-comment">// 创建一个 Notification 并将其分配到上方创建的 Channel 中</span><br>        notification = NotificationCompat.Builder(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;testChannel&quot;</span>)<br>            .setContentTitle(<span class="hljs-string">&quot;前台 Service 测试&quot;</span>)<br>            .setContentText(<span class="hljs-string">&quot;通知内容&quot;</span>)<br>            .setSmallIcon(R.drawable.ic_outline_notifications_24)<br>            .setLargeIcon(<br>                BitmapFactory.decodeResource(<br>                    resources,<br>                    R.drawable.ic_outline_notifications_24<br>                )<br>            )<br>            .setForegroundServiceBehavior(FOREGROUND_SERVICE_IMMEDIATE)  <span class="hljs-comment">// 设置通知开启后立即显示</span><br>            .build()<br><br>        start()<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 开启通知</span><br>        startForeground(<span class="hljs-number">473</span>, notification)<br>    &#125;<br><br>    <span class="hljs-keyword">inner</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBinder</span> : <span class="hljs-type">Binder</span>() &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getService</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">this</span><span class="hljs-symbol">@MyService</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> myBinder = MyBinder()<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBind</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>?)</span></span>: IBinder &#123;<br>        <span class="hljs-keyword">return</span> myBinder<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span> &#123;<br>        Log.d(<span class="hljs-string">&quot;MyService&quot;</span>, <span class="hljs-string">&quot;Service destroyed.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先在 Service 中创建一个 NotificationManager 对象用于创建 Channel ，接着初始化一个 NotificationChannel 对象，然后利用 NotificationManager 对象创建这个 Channel 。接着创建一个 Notification 对象，把它的 Channel 设置为上面创建的 Channel 。最后再通过<code>startForeground()</code>让 Service 显示通知即可。另外这里为了和 Activity 进行交互，还额外编写了一些逻辑，包括自定义的 Binder 并在<code>onBind()</code>中返回它的实例对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br>    <span class="hljs-comment">// 获取 MyService 引用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> myService: MyService<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> connection = <span class="hljs-keyword">object</span> : ServiceConnection &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">(name: <span class="hljs-type">ComponentName</span>?, service: <span class="hljs-type">IBinder</span>)</span></span> &#123;<br>            myService = (service <span class="hljs-keyword">as</span> MyService.MyBinder).getService()<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceDisconnected</span><span class="hljs-params">(name: <span class="hljs-type">ComponentName</span>?)</span></span> &#123;<br>            TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br><br>        <span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span>, MyService::<span class="hljs-keyword">class</span>.java)<br>        <span class="hljs-keyword">var</span> <span class="hljs-keyword">init</span> = <span class="hljs-literal">false</span><br><br>        <span class="hljs-keyword">val</span> button = findViewById&lt;Button&gt;(R.id.Bt)<br>        button.setOnClickListener &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">init</span>) &#123;  <span class="hljs-comment">// 如果 Service 还没有启动并绑定</span><br>                <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;<br>                    startForegroundService(intent)  <span class="hljs-comment">// 先启动前台 Service</span><br>                    bindService(intent, connection, Context.BIND_AUTO_CREATE)  <span class="hljs-comment">// 绑定 Service</span><br>                    <span class="hljs-keyword">init</span> = <span class="hljs-literal">true</span>  <span class="hljs-comment">// 更新标志位</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                myService.start()  <span class="hljs-comment">// 否则直接让 Service 显示通知就行了</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">val</span> button2 = findViewById&lt;Button&gt;(R.id.Bt2)<br>        button2.setOnClickListener &#123;<br>            <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;<br>                myService.stopForeground(Service.STOP_FOREGROUND_REMOVE)  <span class="hljs-comment">// 停止显示并移除通知</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">val</span> button3 = findViewById&lt;Button&gt;(R.id.Bt3)<br>        button3.setOnClickListener &#123;<br>            <span class="hljs-comment">// 当前情况下需要同时调用以下两个方法才能停止 Service</span><br>            stopService(intent)<br>            unbindService(connection)<br>            <span class="hljs-keyword">init</span> = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Activity 中主要是为界面上的 3 个按钮编写了点击监听，3 个按钮分别用于启动前台 Service 、停止显示并移除 Service 的通知、终止 Service 。另外还为绑定交互编写了 ServiceConnection 对象并在<code>onServiceConnected()</code>中获取 MyService 的引用。</p><p>程序最终的执行效果是：</p><ul><li>启动后点击按钮 1 ，通知抽屉会显示通知，这个通知会立刻显示，并且在 Android 12 及以下的系统中不可被滑动移除。</li><li>此时点击按钮 2 ，通知会被移除，如果<code>stopForeground(Service.STOP_FOREGROUND_REMOVE)</code>中的参数是<code>STOP_FOREGROUND_DETACH</code>的话，则通知不会立刻被移除，但是可以通过手指滑动来清除它。</li><li>如果不点击按钮 2 而是直接点击按钮 3 ，则 Service 会停止运行，且通知会被移除。</li></ul><p>以 Android 12 API 31 或更高版本为目标 SDK 的应用将不再被允许从后台启动前台 Service ，系统因此会抛出<code>ForegroundServiceStartNotAllowedException</code>异常。当然，这也是有例外的：<a href="https://developer.android.com/guide/components/foreground-services#background-start-restriction-exemptions">background-start-restriction-exemptions</a>。</p><h3 id="用户主动停止前台-Service"><a href="#用户主动停止前台-Service" class="headerlink" title="用户主动停止前台 Service"></a>用户主动停止前台 Service</h3><p>从 Android 13 API 33 开始，用户可以在下拉通知栏中通过「Foreground Services (FGS) Task Manager」也就是「前台 Service 任务管理器」来停止一个正在运行的前台 Service ，无论应用的目标 SDK 版本是多少。被停止的应用会出现以下现象：</p><ul><li>系统会将应用从内存中移除，所以不仅是正在运行的前台 Service ，整个应用都会停止。</li><li>系统会移除应用的 Activity 返回栈。</li><li>任何媒体播放行为都会停止。</li><li>前台 Service 在通知栏对应的通知会被移除。</li></ul><p>但是：</p><ul><li>应用在历史记录中仍然得到保留。</li><li>计划任务得到保留。</li><li>闹钟得到保留。</li></ul><p>并且，系统在停止应用的时候不会有任何回调，但是在应用重启的时候，可以通过<code>ApplicationExitInfo</code> API 的<code>REASON_USER_REQUESTED</code>来尝试找到原因。</p><p>当然，这里也有例外，有那么几种类型的应用，它们在运行前台 Service 的时候并不会出现在 FGS 任务管理器中：</p><ul><li>系统级别的应用。</li><li>与安全相关的应用，这些应用往往持有<code>ROLE_EMERGENCY</code>角色标记。</li><li>一些厂商的预装应用。</li><li>设备处于演示模式。</li></ul><p>而以下这几种类型的应用，虽然会出现在 FGS 任务管理器中，但是界面上也不存在用于终止它们的按钮：</p><ul><li>设备所有者的应用（Device owner apps）。</li><li>资料所有者的应用（Profile owner apps）。</li><li>持久性应用：在<code>AndroidManifest.xml</code>的<code>&lt;application&gt;</code>标签内设置<code>android:persistent=&quot;true&quot;</code>的应用。另外，一般的应用不应该进行这样的设置，持久性应用一般是系统应用。</li><li>应用持有<code>ROLE_DIALER</code>角色标记。</li></ul><h3 id="声明-Service-类型"><a href="#声明-Service-类型" class="headerlink" title="声明 Service 类型"></a>声明 Service 类型</h3><p>以 Android 10 API 29 或更高版本为目标 SDK 的应用如果需要在前台 Service 中访问位置信息的话，需要在<code>AndroidManifest.xml</code>中为 Service 声明其类型，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">service</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MyService&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:foregroundServiceType</span>=<span class="hljs-string">&quot;location&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果在以 Android 11 API 30 或更高版本为目标 SDK 的应用中需要访问位置信息的同时需要访问相机的话，就需要这么写：<code>android:foregroundServiceType=&quot;location|camera&quot;</code>。默认情况下在调用<code>startForeground()</code>以后，系统会允许 Service 使用在<code>AndroidManifest.xml</code>中声明的这些权限，但是在运行时，也可以通过在<code>startForeground()</code>中增加参数来对 Service 获取的权限加以限制，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">startForeground(<span class="hljs-number">473</span>, notification, FOREGROUND_SERVICE_TYPE_LOCATION)<br></code></pre></td></tr></table></figure><p>这么写的话，前台 Service 的类型就会被定性成与位置信息相关。而如果需要限制的权限有多个的话，可以这么写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">startForeground(notification,<br>        FOREGROUND_SERVICE_TYPE_LOCATION or FOREGROUND_SERVICE_TYPE_CAMERA)<br></code></pre></td></tr></table></figure><p>从 Android 11 API 30 开始，为了保护用户隐私，一个位于后台的应用启动了一个前台 Service ，这个前台 Service 将受到以下限制：</p><ul><li>除非用户同意授予该应用<code>ACCESS_BACKGROUND_LOCATION</code>权限，否则这个前台 Service 无法访问位置信息。</li><li>无法访问麦克风和摄像头。</li></ul><p>即使这个应用在<code>AndroidManifest.xml</code>的<code>&lt;service&gt;</code>标签内声明了 Service 类型，它也仍然会受到 Android 11 这个系统的限制。但是，仍然有例外：<a href="https://developer.android.com/guide/components/foreground-services#bg-access-restriction-exemptions">Exemptions from the restrictions</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.android.com/guide/components/services">服务概览</a></li><li>《第一行代码 Android 第3版》郭霖 著</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我真的好喜欢云芝小姐</title>
    <link href="/post/I-really-love-Miss-Yunzhi-so-much/"/>
    <url>/post/I-really-love-Miss-Yunzhi-so-much/</url>
    
    <content type="html"><![CDATA[<p>今天浅谈一下我对《三年之约》的初印象（标题说我喜欢云芝，其实美杜莎老婆我也很喜欢，不过这个以后有机会再说）。</p><span id="more"></span><p>虽然啰哩啰嗦不是我倾向的风格，但是如果有些话不吐露出来、有些感情不表达出来，我可能真的会夜不能寐食不甘味。</p><p>《斗破苍穹》出第一季动画的时候我在上高中，当时是在坐公交车去学校的路上看的，只不过当时因为资源的问题，第 12 集没看到，加之第一季的质量确实比较一般，后来也就不了了之了。</p><p>前段时间在找片子看，无意中看到斗破苍穹已经更新到第四季了……于是乎找了个渠道稍微看了一下，不看不要紧，这一看，确实是发现从第一季特别篇开始整部动画有了质的飞跃（因为换了制作方）。而也就是这短短一个小时不到的时间，直接拉高了我对整部动画的兴趣以及对后续剧情发展的期待。然后我有个坏习惯，对于感兴趣的片子，我会用快进的方式把后面没来得及看的剧集快速过一遍，然后问题就来了。</p><p>昨天晚上没忍住，快进看完了《三年之约》，从九点半一直看到 12 点，看了个大概。只能说尽管只有短短 13 集，但无论是建模、画面、特效、剧情、音乐、配音……我都觉得很满意。虽然三年之约这一部分的小说我也读过（应该吧，差不多十年前上初中那会儿的事情，早忘了），但是动画相比小说和漫画又有着它独特的表达方式，加之剧情中频频不断出现的高手和萧炎一张又一张的底牌实在是让我过足了瘾。</p><p>这几个小时下来，唯有一处地方真是让我又爱又恨，那便是萧炎和云芝的关系。爱，是爱云芝。恨，是恨老天将云芝和萧炎如此戏剧般地安排。云芸作为一宗之主，需要担起相应的责任，但偏偏是这样一个人，却又在魔兽山脉和塔戈尔沙漠和萧炎发生了那样的儿女情长，云芸和云芝的矛盾在动画中被体现得淋漓尽致。有的人说，云芝理论上不应该有现在这么高的人气，之所以有，那也得多亏了制作方的高质量建模和杨梦露老师为其注入灵魂。小说和漫画我都没看完我就不做评价了，但是就现阶段结果而言，我相信动画版的云芝是俘获了包括我在内很多观众的心的。</p><p>所以说我真的服了这个剧组，像个老六一样，从第一季特别篇开始就一直给观众发刀片，从特别篇第一集刀到三年之约最后一集还不肯放过我。尤其是那首 AZA 微唱团的《从别后》，每次一到萧炎和云芝的感情戏的时候这个背景音乐就起来了，每次一听到这个旋律我就一股伤感油然而生，听多了以后搞得我都有生理反应了，现在一听到这首歌我就鼻子发酸眼角湿润，脑子里全是云芝的样子和声音，然后整天无精打采萎靡不振，做事的时候心不在焉…………云芝你带我走吧，没有你我怎么活啊！</p><p>总而言之，《斗破苍穹》是我初中生活的一部分，如今能够看到如此优秀的动画作品，开心中带点欣慰，真心希望这个系列能够保持质量持续连载下去直到完结，给各位粉丝一个交代。</p><p>暂时先说这么多，不说了不代表我没话说，只是没必要说完说透，有些话不说可能是因为我还没组织好甚至不想组织语言，可能是这个地方不适合说，也有可能是我想把这份感情藏在心里……不过其实还有一句想说，那就是：</p><blockquote><p>我现在对第五季动画的期待比 R 星出 GTA6 还高。</p></blockquote><p><img src="/../../images/ACGN/Yunzhi.jpg" alt="云芝"></p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>真的有人觉得《租借女友》好看吗？</title>
    <link href="/post/Review-Kanojo-Okarishimasu/"/>
    <url>/post/Review-Kanojo-Okarishimasu/</url>
    
    <content type="html"><![CDATA[<p>这仍然是一部不能带脑子去认真看的番。</p><span id="more"></span><p>开头看着还行，看到第七集的时候，结合了前面的内容梳理了一下，实在是有些没绷住。后来看到第八集以后更是让我难以接受，整集都是倍速过去的，最后在 5 月 12 日终于把这坨屎吃完了。</p><h2 id="先说说男主"><a href="#先说说男主" class="headerlink" title="先说说男主"></a>先说说男主</h2><p>男主真的挺奇怪的，被前女友甩了就算了，还要想着去租女友，这究竟是为了什么？是为了在别人面前炫耀不属于自己的东西来满足虚荣心？是为了让自己尽快从被甩了的阴影中走出？是为了哄奶奶开心？租来了女友，达成了哄奶奶的目的，且不说完事了以后不仅不撇清与租借女友的交易关系，反而还喜欢上了人家。然后第七集突然杀出来一个各方面都挺不错并且对自己持有好感的女孩子对自己表白了，眼看此时自己终于有机会摆脱单身了，结果这男主还不乐意了，还开始挑剔了。当然，恋爱是双向的，男主有权拒绝，他没做错，只不过我作为观众，看到这样的展开很不爽，所以我也要吐槽吐槽。</p><h2 id="再说说前女友"><a href="#再说说前女友" class="headerlink" title="再说说前女友"></a>再说说前女友</h2><p>前女友这个角色我觉得塑造得很成功，因为在我眼里，这种女人就是神经病。只有当你的角色给读者和观众留下很深刻的印象的时候，这个角色的塑造才能算成功。前女友这个角色好像有什么大病，自从登场了以后就一直在阴阳怪气，排斥恋爱，但是她自己也是谈过恋爱的人，难道她是在否定自己吗？难道她之前和男主谈的恋爱就只是所谓的“玩玩而已”？她实际上就是个绿茶？她是不是绿茶我不知道，但是我能确定她是个合格的阴阳师，她一天到晚在那里冷嘲热讽让我不得不去怀疑她是不是有什么不好的过往，比如说被霸凌之类的，要不然她怎么会这么扭曲？说真的，我宁愿单身一辈子，也不想和这种腹黑来往，太可怕了，哪天我被捅死我都不觉得奇怪。</p><h2 id="男主对前女友的态度"><a href="#男主对前女友的态度" class="headerlink" title="男主对前女友的态度"></a>男主对前女友的态度</h2><p>我是真没见过有人在和女友分手以后还一天到晚意淫人家，然后偶然间见了面，还能抱着复合的态度和想法有说有笑。结合上面我对前女友的看法，我甚至无法理解男主在和她交往的那段时间里是怎么过的，每天和她在一起男主有什么想法。总之男主对前女友这样的态度以及他优柔寡断的样子让我非常厌恶。</p><h2 id="其他人"><a href="#其他人" class="headerlink" title="其他人"></a>其他人</h2><ul><li>这部剧里面唯一正常的人可能就是由 雨宮天 配音的 一之濑千鹤 小姐了。</li><li>除了 一之濑千鹤 小姐以外的那两位租借女友，不能说不正常，只能说不异常。</li><li>木部 作为主角的死党之一，其实也算正常人，只不过一直被主角租借女友的事情蒙在鼓里，变成蒙古人了。</li><li>栗林 作为主角的死党之一，相比 木部 来说，他在整部剧里的行为让他看起来就像个小丑，包括他跟男主一样，也会去使用租借女友的服务来满足虚荣心，只能说臭味相投、人以群分了。</li><li>奶奶这个角色就是典型的长辈形象，在剧中起到一点点推动剧情的作用，剩下的也就那样。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>剧情方面，有很多点我都懒得吐槽，包括穿着衣服海底救人这种超人般的行为。只能说这就是这一类番剧的特点了，看的时候千万不能带脑子，不然真的挺无聊的。从第七集开始男主给我的形象就非常差，到目前为止看来，男主全身上下除了编剧给硬套上去的日漫当中已经用烂了的极其老套的温柔属性以外，没有任何优点。优柔寡断、屌丝、不知足、知道自己有不足的地方但是又不愿意去努力改变、整天意淫、痴心妄想、纯纯一憨批，越看越让人觉得厌烦。</p><p>在看完最后一集的时候我还非常感动，为什么？因为男主到了最后一刻也没让我失望，他真的可以把无能贯彻到底，把屌丝发挥到极致。前面铺垫了那么多，到了最后最关键的时刻，竟然还是说不出最关键的话，我整个人都懵了！我甚至开始怀疑是作者真的想为了把故事写长一些所以让男主愣是把到了口中的话憋回去，还是只是单纯地在把观众当猴耍，如果是前者，那他那又没人家火影海贼死神写长篇的水平，如果是后者纯纯恶心人，那确实是跟谏山创一样可能有点精神问题。</p><p>这部番，无论是从恋爱、校园、喜剧哪一个角度来说，都是弟中弟。我看的番不多，在我看过的番剧中，校园恋爱，它不如春物，甚至可能不如冰菓，感觉还比伪恋差一点。喜剧，它又比不过银魂……反正我真的想不明白作者是以什么样的心态发表这样的作品。而且我隐约感觉到作者在刻画每个人物的时候，为了让每个人物的性格特点看起来更加不同或者更加突出，也不知道他是有意地还是无意地去让这些角色在他们那条人设线上越走越远，再结合作者自己的脑回路，就让这些角色在正常人眼中看起来显得特别的奇怪，就像是为了突出角色而突出角色。稍微反观一下春物，春物中的每个角色都有自己的特点，但是这个特点只会让这个角色看起来就像是那一类人的其中之一……</p><p>男主，上大学还兼职，长得也可以，为什么就是不敢表白？如果明知自己不足，为什么不去努力改变？整天只会搁那意淫，虚荣心还强，又自欺欺人……这样的人活该一辈子找不到女朋友。顺带一提，如果他拿他自己租借女友的钱去嫖，都不知道可以透多少个批了。</p><p>最后，这种看完第一季就已经用了我半条命甚至颠覆我三观的番剧，只有真正的抖M才会去看第二季，能坚持看完第一季只能说明我是强迫症，但是虐完一遍就够了。只有喜欢反复自虐的，才能算是真正的抖M。</p><p><img src="/../../images/ACGN/KanojoOkarishimasu12.jpg" alt="有租借女友这个钱我拿来干什么不好？"></p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>劳动节假期结束了</title>
    <link href="/post/Labor-Day-holiday-is-over/"/>
    <url>/post/Labor-Day-holiday-is-over/</url>
    
    <content type="html"><![CDATA[<p>随便写写，发点牢骚。</p><span id="more"></span><h2 id="五一之前"><a href="#五一之前" class="headerlink" title="五一之前"></a>五一之前</h2><p>4 月底在少数派看到个新闻，说是 5 月 15 日之前访问育碧商城的某个链接，即可获得一周的育碧会员，类似于西瓜皮订阅那样的东西，所有游戏免费畅玩。结果假期前一天晚上我点进链接，直接跳到法国区的育碧商店了，只不过如果账号不在法国是领不了的，顿时感觉当时小编发那个新闻是不是太随意了。</p><h2 id="五一之间"><a href="#五一之间" class="headerlink" title="五一之间"></a>五一之间</h2><h3 id="玩游戏"><a href="#玩游戏" class="headerlink" title="玩游戏"></a>玩游戏</h3><p>玩了两部老游戏，一部是《神奇蜘蛛侠 2》，一部是《虐杀原形》。前三天玩前者，第四天玩后者，第五天没玩游戏。玩蜘蛛侠的时候想着自己这么多年来不知道为什么一直没把它玩通，这次一定要把它玩通。玩通以后发现自己原来可能早都已经玩通了，只不过是忘了而已……从中反映出两个问题，一是没有一个好的记录游戏进度的方案；二是这游戏的流程确实太短了，不过作为电影配套的游戏，整体上其实也还可以了。另外就是我发现这游戏以前的时候似乎是在 Steam 有售的，只不过现在可能已经下架了。这游戏有个启动器，用于调整一些游戏相关的设置，比如画质和分辨率等等，想要使用这个启动器好像还要装 DX9 ，把画质拉满以后发现不能开 V-Sync 否则帧数会很低。至于虐杀原形，时间不多了所以没玩通，不过能在 2022 年用桌面的分辨率以及破百的帧率玩这个游戏，可以说是我五一最开心的一件事。</p><h3 id="看电影"><a href="#看电影" class="headerlink" title="看电影"></a>看电影</h3><p>看了两部电影，一部是《速度与激情3》，一部是《蚁人》。两部电影也都相当精彩，尤其是蚁人，本来想只看一半，剩下一半下次看的，但是实在是太好看了没忍住就把它看完了。所以事实上年轻人爱看这些外国电影不是没有理由的，毕竟人家拍得是真的好。接下来的漫威电影计划看奇异博士和尚气，由于蜘蛛侠三代同框的蓝光在 4 月份的时候发售了，所以高清盗版也已经流出了，不过这种好东西还是到时候找个机会再慢慢享受。</p><h2 id="五一之后"><a href="#五一之后" class="headerlink" title="五一之后"></a>五一之后</h2><h3 id="记录游戏进度"><a href="#记录游戏进度" class="headerlink" title="记录游戏进度"></a>记录游戏进度</h3><p>正常情况下，游戏运行过一次以后，应该都能找到它的存档文件。所以从今往后，只要是我玩过的游戏，我都会将它的存档上传到网盘，一是为了备份，二是作为一个提醒，代表我已经玩过这个游戏了。</p><h3 id="又要上班了"><a href="#又要上班了" class="headerlink" title="又要上班了"></a>又要上班了</h3><p>有点烦，首先是安排的工作似乎、好像、可能——不是我非常想干的。再者就是这些工作有点难度，所以这里有个很矛盾的地方，工作有难度，做了才能进步，聘用你就是去解决问题的。但是解决困难的过程也比较痛苦，不太想干。有时候在胡思乱想自己到底有什么用。想当码农但是又不想解决困难，那如何才能进步，难道要每天都重复一样的工作，然后干到 35 岁就直接另谋高就是吧。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android 学习笔记 - 广播&amp;通知</title>
    <link href="/post/Android-Study-Guide-Broadcast-And-Notification/"/>
    <url>/post/Android-Study-Guide-Broadcast-And-Notification/</url>
    
    <content type="html"><![CDATA[<p>Android apps 可以发送广播，亦可接受来自系统或者其他 apps 的广播并针对其做一些工作。广播还可以作为一个跨应用程序和正常用户流之外的信息传递系统使用；通知是指在应用界面之外显示的消息，其旨在向用户提供提醒、来自他人的通信信息或应用中的其他实时信息。用户可以点按通知来打开应用，或直接从通知中执行操作。</p><span id="more"></span><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><h3 id="接收广播"><a href="#接收广播" class="headerlink" title="接收广播"></a>接收广播</h3><p>程序可以通过两种方式来接受广播：</p><ul><li>注册上下文接收器（context-registered receivers）（动态注册）</li><li>基于 manifest 的接收器（manifest-declared receivers）（静态注册）</li></ul><p>其中动态注册一般是需要在程序启动之后才能接收广播，因为上下文接收器的「上下文」必须要有效，例如在 Activity 上下文中注册，只要 Activity 没有被销毁，就可以收到广播。如果在应用上下文中注册，那么只要应用还在运行，就可以收到广播；而静态注册可以在广播发出后由系统来启动程序。不过无论哪种方式，都需要通过 BroadcastReceiver 来实现。进一步说就是创建一个类，使其继承于<code>BroadcastReceiver</code>类，然后重写<code>onReceive()</code>，这样当程序接收到对应的广播时，<code>onReceive()</code>中的代码就会执行。</p><h4 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h4><p>因为静态注册可以在程序未启动的情况下接收广播，从 Android 8.0 (API level 26) 开始，静态注册将不再能接收大部分的隐式广播，所谓隐式广播就是没有特别指定由哪一个程序接收的广播。</p><p>静态注册的大致步骤：</p><ul><li>创建一个类，使其继承于<code>BroadcastReceiver</code>类，然后重写<code>onReceive()</code>。</li><li>在<code>AndroidManifest.xml</code>对这个 receiver 进行注册（创建<code>&lt;receiver&gt;</code>标签，标签的<code>android:name</code>属性为第一步中创建的类的类名）。</li></ul><p>如果是通过 Android Studio 直接创建一个 BroadcastReceiver 则可以省去以上两步，因为 Android Studio 已经自动完成了，此时在<code>AndroidManifest.xml</code>中可以看到在<code>&lt;application&gt;</code>标签中，也就是和<code>&lt;activity&gt;</code>标签同级的位置多出来一个<code>&lt;receiver&gt;</code>（假设类名为「BatteryChangeReceiver」）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.BatteryChangeReceiver&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>接下来在<code>&lt;receiver&gt;</code>标签中的<code>&lt;intent-filter&gt;</code>声明需要接收的广播，例如通过<code>&lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;</code>便可以收到手机开机完成后发送的广播：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.BatteryChangeReceiver&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.BOOT_COMPLETED&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><br></code></pre></td></tr></table></figure><p>不过如果是要接受开机完成的广播，则还需要声明权限：<code>&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;</code>。</p><ul><li>最后在<code>onReceive()</code>中编写非耗时操作即可。</li></ul><h4 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h4><p>此处以接收电池电量的变化为例记录一下动态注册的主要步骤及代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">ComponentActivity</span>() &#123;<br>    <span class="hljs-comment">// 3. 创建一个第一步中定义的类的实例对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> batteryChangeReceiver = BatteryChangeReceiver()<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        <span class="hljs-comment">// 2. 创建一个`IntentFilter`的实例对象并根据广播类型为其添加相应的 action</span><br>        <span class="hljs-keyword">val</span> intentFilter =<br>            IntentFilter().apply &#123; addAction(<span class="hljs-string">&quot;android.intent.action.BATTERY_CHANGED&quot;</span>) &#125;<br>        <span class="hljs-comment">// 4. 调用 registerReceiver() 并将第三步和第二步中的对象作为参数传入</span><br>        registerReceiver(batteryChangeReceiver, intentFilter)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDestroy()<br>        <span class="hljs-comment">// 5. 在适当的位置调用`unregisterReceiver()`以取消注册释放资源</span><br>        unregisterReceiver(batteryChangeReceiver)<br>    &#125;<br><br>    <span class="hljs-comment">// 1. 定义一个类继承自`BroadcastReceiver`并重写`onReceive()`</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">BatteryChangeReceiver</span> : <span class="hljs-type">BroadcastReceiver</span>() &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onReceive</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>?, intent: <span class="hljs-type">Intent</span>?)</span></span> &#123;<br>            <span class="hljs-comment">// 简单地显示一个吐司</span><br>            Toast.makeText(context, <span class="hljs-string">&quot;当前电量：%<span class="hljs-subst">$&#123;intent?.getIntExtra(<span class="hljs-string">&quot;level&quot;</span>, <span class="hljs-number">0</span>)&#125;</span>&quot;</span>, Toast.LENGTH_SHORT)<br>                .show()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时当程序接收到来自系统发出的电量变化的广播时将会弹出一个吐司。此外，还可以在<code>/&lt;计算机的 Android SDK 目录&gt;/platforms/&lt;相应的Android API 版本&gt;/data/broadcast_actions.txt</code>中找到完整的广播列表。</p><h3 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h3><h4 id="普通广播"><a href="#普通广播" class="headerlink" title="普通广播"></a>普通广播</h4><p>通过使用<code>sendBroadcast(Intent)</code>来发送普通广播，普通广播是一种异步执行的广播，所有接收器几乎会在同一时间收到该广播信息。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">button.setOnClickListener &#123;<br>    Intent().also &#123; intent -&gt;<br>        intent.action = <span class="hljs-string">&quot;com.risingsun.learnandroid.MY_BROADCAST&quot;</span>  <span class="hljs-comment">// 设置 intent</span><br>        intent.putExtra(<span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;This is my broadcast&quot;</span>)  <span class="hljs-comment">// 存储额外信息</span><br>        intent.setPackage(packageName)  <span class="hljs-comment">// 指定接收广播的应用</span><br>        sendBroadcast(intent)  <span class="hljs-comment">// 发送广播</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此处的<code>com.risingsun.learnandroid.MY_BROADCAST</code>属于自定义广播，自定义广播往往是隐式广播，前面提到，Android 8.0 开始将不再能通过静态注册接收隐式广播（哪怕是自己给自己广播），所以这里还需要通过<code>setPackage(packageName)</code>来指定接收广播的应用，其中<code>packageName</code>属于语法糖，<code>setPackage(packageName)</code>的意思其实就是广播给应用自己。</p><p>然后在程序中添加一个静态注册的 BroadcastReceiver 并重写<code>onReceive()</code>来接收这个广播：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onReceive</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, intent: <span class="hljs-type">Intent</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> info = intent.getStringExtra(<span class="hljs-string">&quot;info&quot;</span>)<br>    Toast.makeText(context, info, Toast.LENGTH_LONG).show()<br>&#125;<br></code></pre></td></tr></table></figure><p>运行程序点击按钮将会看到一个内容为「This is my broadcast」的吐司。</p><h4 id="有序广播"><a href="#有序广播" class="headerlink" title="有序广播"></a>有序广播</h4><p>通过使用<code>sendOrderedBroadcast(Intent, String)</code>来发送有序广播，有序广播是一种同步执行的广播，一次只向一个接收器发送广播，接收器在处理完之后可以将结果传播给下一个接收器，也可以完全中止广播。静态注册的接收器可以通过在<code>&lt;intent-filter&gt;</code>内定义<code>android:priority</code>的值来决定优先级，动态注册的接收器直接设置<code>IntentFilter</code>对象的<code>priority</code>即可。当存在多个相同优先级的接收器时，将随机执行。</p><p>在发送普通广播的代码基础上，只需要将<code>sendBroadcast(intent)</code>更改为<code>sendOrderedBroadcast(intent, null)</code>即可发送有序广播，其中第二个参数对应权限相关的字符串，若将<code>null</code>改为<code>android.permission.INTERNET</code>，那么只有在<code>AndroidManifest</code>中声明<code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</code>的程序的接收器才能收到广播。</p><h4 id="向下一个接收器传递结果"><a href="#向下一个接收器传递结果" class="headerlink" title="向下一个接收器传递结果"></a>向下一个接收器传递结果</h4><p>在当前接收器收到广播以后可以在<code>onReceive()</code>中使用 setResultXxx() 来设定结果信息，当下个接收器收到广播时可以从中取出信息，同时也可以为再下一个接收器继续设置结果信息。</p><p>例如在当前接收器中的<code>onReceive()</code>中写上<code>resultData = &quot;result from MyBroadcastReceiver&quot;</code>，那么下个接收器可以直接使用<code>resultData</code>这个变量，其值就是<code>result from MyBroadcastReceiver</code>。</p><h4 id="阻断广播"><a href="#阻断广播" class="headerlink" title="阻断广播"></a>阻断广播</h4><p>在<code>onReceive()</code>中使用<code>abortBroadcast()</code>可以终止广播的发送，即下一个接收器无法收到广播。</p><h3 id="通过权限限制广播"><a href="#通过权限限制广播" class="headerlink" title="通过权限限制广播"></a>通过权限限制广播</h3><p>在调用<code>sendBroadcast()</code>或<code>sendOrderedBroadcast()</code>时可以向其中传入权限参数，此时只有在<code>AndroidManifest.xml</code>申请了相关权限的 apps 的接收器可以收到这个广播。</p><p>相反，如果在注册接收器时填入指定权限，那么就只有在<code>AndroidManifest.xml</code>申请了相关权限的 apps 可以向这些接收器所属的 app 发送广播，例如在静态注册时：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MyBroadcastReceiver&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:permission</span>=<span class="hljs-string">&quot;android.permission.SEND_SMS&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.AIRPLANE_MODE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或者在动态注册时：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> filter = IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED)<br>registerReceiver(receiver, filter, Manifest.permission.SEND_SMS, <span class="hljs-literal">null</span> )<br></code></pre></td></tr></table></figure><p>那么发送方必须申请<code>&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;/&gt;</code>权限才能向这些接收器发送广播。</p><h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><h3 id="NotificationChannel"><a href="#NotificationChannel" class="headerlink" title="NotificationChannel"></a>NotificationChannel</h3><p>「NotificationChannel」意为「通知渠道」，简单理解就是站在应用的角度来对通知进行分类，例如 Android 端的 YouTube 会创建很多个通知类别，其中包括「订阅内容」、「直播」、「评论和回复」等等。从 Android 8.0 API 26 开始，必须为所有通知分配渠道，否则通知将不会显示。将通知进行分类可以让用户知道每个通知的意图，也可以让用户对每个类别的通知的提醒方式以及是否允许提醒进行自定义，不至于一个开关直接关掉所有的通知。然而在 Android 7.1 API 25 及更低版本的设备上，用户就真的只能一刀切（只能单独对每个应用是否允许通知进行设置）。</p><p>分配渠道之前要先创建一个<code>NotificationChannel</code>对象，然后在创建<code>Notification</code>对象也就是构建通知本体时才将渠道传递过去。创建通知渠道一般有这么几步：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 1</span><br><span class="hljs-keyword">val</span> mannager = getSystemService(Context.NOTIFICATION_SERVICE) <span class="hljs-keyword">as</span> NotificationManager<br><br><span class="hljs-comment">// 2</span><br><span class="hljs-keyword">val</span> channel = <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;<br>    NotificationChannel(<span class="hljs-string">&quot;testChannel&quot;</span>, <span class="hljs-string">&quot;通知测试&quot;</span>, NotificationManager.IMPORTANCE_DEFAULT)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    TODO(<span class="hljs-string">&quot;VERSION.SDK_INT &lt; O&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 3</span><br>mannager.createNotificationChannel(channel)<br></code></pre></td></tr></table></figure><ol><li>通过<code>getSystemService()</code>创建一个<code>NotificationManager</code>对象。</li><li>创建一个<code>NotificationChannel</code>对象，构造函数接收 3 个参数，分别是：<ol><li>渠道的 ID ，字符串类型。此处设置的 ID 会在创建<code>Notification</code>对象的时候用到，设置了这个 ID 的通知就会归属到这个渠道（类别）下。</li><li>渠道的名称，字符串类型。名称会在系统设置的应用详情中的通知管理里显示，例如此处将会显示「通知测试」，然后后面会跟上一个允许通知的开关。</li><li>渠道的重要性，整型。该值会影响通知出现时形式，包括是否在界面上弹出以及是否发出声音等。需要注意，无论在此处将其设置为什么级别，用户都可以在安装应用后手动修改，并且重要性一旦设置好以后，就算后期在代码上进行修改，改动也无法生效。例如一开始设置为<code>NotificationManager.IMPORTANCE_DEFAULT</code>，后期修改为<code>NotificationManager.IMPORTANCE_HIGH</code>（重要性为<code>NotificationManager.IMPORTANCE_HIGH</code>的通知将会以提醒式通知的形式出现，也就是像微信收到联系人消息一样，在手机顶部弹出，这是 5.0 引入的特性），实际运行的时候，通知的出现形式仍然和原来一样，这种情况下就算清除应用缓存和数据也没用，就算调用<code>NotificationManager</code>对象的<code>deleteNotificationChannel()</code>将通知渠道删除然后再重新创建也没用，解决方案只有卸载重装应用或者新建一个通知渠道。尽管重要性无法再被修改，但是渠道的名称和说明仍然可以修改。</li></ol></li><li>最后通过调用<code>NotificationManager</code>对象的<code>createNotificationChannel()</code>方法并将<code>NotificationChannel</code>对象传入即可创建通知渠道。</li></ol><p>创建好的通知渠道会保留在系统设置的应用详情中的通知管理里，如需删除则需要调用<code>NotificationManager</code>对象的<code>deleteNotificationChannel()</code>。另外，系统并不会响应重复创建现有的通知渠道的操作，所以这段代码允许被重复执行。</p><p>除了将每条通知添加到相应的通知渠道之外，还应考虑通过调用<code>.setCategory()</code>为拥有特别用途的通知设置对应的分类，例如在构建闹钟通知时设置<code>.setCategory(CATEGORY_ALARM)</code>。</p><p>在后期如果想知道用户对某个通知渠道做了怎样的设置，可以通过调用<code>NotificationManager</code>对象的<code>getNotificationChannel()</code>并传入对应通知渠道的 ID 来获取到一个<code>NotificationChannel</code>对象，然后再调用这个<code>NotificationChannel</code>对象的<code>vibrationPattern</code>、<code>sound</code>、<code>importance</code>等属性就可以获取渠道的震动、声音、重要性设置，从而判断当前设置是否满足开发者的期望，如果不满足，可以尝试向用户发出消息，请求用户修改相关设置。</p><h3 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h3><p>创建好通知渠道后，就可以着手于创建通知的本体（<code>Notification</code>对象）了。一般为了兼容性考虑，创建<code>Notification</code>对象时会使用位于<code>androidx</code>中的<code>NotificationCompat</code>而不是<code>Notification</code>。<code>NotificationCompat</code>允许在构建通知时向其添加仅在较新版本 Android 上可用的功能，同时仍向后兼容至 Android 4.0 API 14 ，尽管这会导致诸如内嵌回复操作等部分新功能在旧版本 Android 上会变成空操作。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> notification = NotificationCompat.Builder(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;testChannel&quot;</span>).build()<br></code></pre></td></tr></table></figure><p><code>Builder()</code>接收两个参数，分别是上下文和通知渠道的 ID（这里填入了前面设置的<code>testChannel</code>），然后再调用<code>build()</code>就可以创建出一个<code>Notification</code>对象。不过这样创建的通知没有什么内容，所以一般会在调用<code>build()</code>之前调用其它的设置方法来完善这个通知，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> notification =<br>    NotificationCompat.Builder(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;testChannel&quot;</span>)<br>        .setContentTitle(<span class="hljs-string">&quot;通知标题&quot;</span>)  <span class="hljs-comment">// 设置标题，可选</span><br>        .setContentText(<span class="hljs-string">&quot;通知内容&quot;</span>)  <span class="hljs-comment">// 设置内容，可选</span><br>        .setSmallIcon(R.drawable.ic_baseline_notifications_none_24)  <span class="hljs-comment">// 设置小图标，必须</span><br>        .setLargeIcon(  <span class="hljs-comment">// 设置大图标，可选</span><br>            BitmapFactory.decodeResource(<br>                Resources.getSystem(),<br>                R.drawable.ic_baseline_notifications_none_24<br>            )<br>        )<br>        .setPriority(NotificationCompat.PRIORITY_DEFAULT)  <span class="hljs-comment">// 设置通知在 Android 7.1 和更低版本上的干扰程度</span><br>        .build()<br></code></pre></td></tr></table></figure><p>最后通过调用<code>NotificationManager</code>对象的<code>notify()</code>来发送通知，<code>notify()</code>接收两个参数，分别是应用内唯一的通知 ID 以及<code>Notification</code>对象。</p><h3 id="展开式通知"><a href="#展开式通知" class="headerlink" title="展开式通知"></a>展开式通知</h3><h4 id="长文本"><a href="#长文本" class="headerlink" title="长文本"></a>长文本</h4><p>在一般的通知中，通知的内容就是一小句话，简明扼要，但是有时候会出现需要在<code>setContentText()</code>中增加大量的文字说明的情况，这时通知会在显示的时候将过多的文字用省略号代替。所以当通知需要显示大量文本的时候，正确的方法是在构建通知时使用<code>setStyle()</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">.setStyle(<br>    NotificationCompat.BigTextStyle()<br>        .bigText(<span class="hljs-string">&quot;这是一个非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常长的通知&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><p>另外，如需对文本添加格式（粗体、斜体、换行等等），还可以使用 HTML 标记添加样式。</p><h4 id="内容是图片"><a href="#内容是图片" class="headerlink" title="内容是图片"></a>内容是图片</h4><p><code>setStyle()</code>除了设置长文本的通知，还能在通知里增加图片，例如在<code>drawable</code>文件夹内有一个图片文件<code>pic.jpg</code>，那么这么做便可以将这张图片显示在通知中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">.setStyle(<br>    NotificationCompat.BigPictureStyle()<br>        .bigPicture(BitmapFactory.decodeResource(resources, R.drawable.pic))<br>)<br></code></pre></td></tr></table></figure><p>拥有图片的通知可以展开或收起，当通知展开时，将在内容区域显示图片，而当通知收起时，可以通过调用<code>bigLargeIcon()</code>和<code>setLargeIcon()</code>来在通知的右方区域显示图片的缩略图。例如，现在假设在<code>drawable</code>文件夹内有一个图片文件<code>pic.jpg</code>，那么在构建通知时需要向其添加<code>setLargeIcon()</code>并传递图片，同时调用<code>BigPictureStyle.bigLargeIcon()</code>并传递<code>null</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> pic = BitmapFactory.decodeResource(resources, R.drawable.pic)<br><span class="hljs-keyword">val</span> notification =<br>    NotificationCompat.Builder(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;testChannel&quot;</span>).setContentTitle(<span class="hljs-string">&quot;通知标题&quot;</span>)<br>        .setContentText(<span class="hljs-string">&quot;通知内容&quot;</span>)<br>        .setSmallIcon(R.drawable.ic_baseline_notifications_none_24)<br>        .setLargeIcon(pic)  <span class="hljs-comment">// 注意</span><br>        .setStyle(BigPictureStyle().bigPicture(pic).bigLargeIcon(<span class="hljs-literal">null</span>))  <span class="hljs-comment">// 注意</span><br>        .build()<br></code></pre></td></tr></table></figure><h4 id="addLine"><a href="#addLine" class="headerlink" title="addLine()"></a>addLine()</h4><p>通过多次调用<code>addLine()</code>可以在通知中显示多行文本，每行文本之间都会再空一行，最多显示前 6 行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> cs1: CharSequence = <span class="hljs-string">&quot;第一行内容&quot;</span><br><span class="hljs-keyword">val</span> cs2: CharSequence = <span class="hljs-string">&quot;第二行内容&quot;</span><br><span class="hljs-keyword">val</span> notification =<br>    NotificationCompat.Builder(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;testChannel&quot;</span>).setContentTitle(<span class="hljs-string">&quot;通知标题&quot;</span>)<br>        .setContentText(<span class="hljs-string">&quot;通知内容&quot;</span>)<br>        .setSmallIcon(R.drawable.ic_baseline_notifications_none_24)<br>        .setStyle(<br>            NotificationCompat.InboxStyle().addLine(cs1).addLine(cs2)<br>        ).build()<br></code></pre></td></tr></table></figure><h4 id="在通知中显示对话"><a href="#在通知中显示对话" class="headerlink" title="在通知中显示对话"></a>在通知中显示对话</h4><p><a href="https://developer.android.com/training/notify-user/expanded#message-style">在通知中显示对话</a></p><h4 id="使用媒体控件创建通知"><a href="#使用媒体控件创建通知" class="headerlink" title="使用媒体控件创建通知"></a>使用媒体控件创建通知</h4><p><a href="https://developer.android.com/training/notify-user/expanded#media-style">使用媒体控件创建通知</a></p><h3 id="可交互通知"><a href="#可交互通知" class="headerlink" title="可交互通知"></a>可交互通知</h3><h4 id="通知点击操作"><a href="#通知点击操作" class="headerlink" title="通知点击操作"></a>通知点击操作</h4><p>在日常使用中，用户往往可以和应用发出的通知进行交互，例如收到微信联系人的消息，微信会弹出通知，此时点击通知就可以进入聊天界面。想要让通知对用户的点击做出响应，就需要用到 PendingIntent 。</p><p>要使用 PendingIntent ，需要先创建一个<code>Intent</code>对象，这个对象指向在用户点击通知时需要启动的 Activity 或者 Service 或者 Broadcast 。随后就是创建<code>PendingIntent</code>对象，可以通过<code>PendingIntent</code>类的<code>getActivity()</code>或者<code>getService()</code>或者<code>getBroadcast()</code>来创建<code>PendingIntent</code>对象（3 个方法各自对应<code>Intent</code>对象的目标），这里以<code>getActivity()</code>为例，<code>getActivity()</code>接收 4 个参数，分别是：</p><ol><li>上下文。</li><li>请求代码，不知道怎么用，一般填入<code>0</code>。</li><li><code>Intent</code>对象。</li><li>标记位，不知道怎么用，一般填入<code>0</code>。但是在 Android 12 API 31 及以上版本中，这个值必须要是<code>FLAG_IMMUTABLE</code>或者<code>FLAG_MUTABLE</code>二者之一。</li></ol><p>最后在构建通知时添加<code>setContentIntent()</code>并将<code>PendingIntent</code>对象传入即可。</p><p>当用户点击了设置好 PendingIntent 的通知后，程序会去执行对应的操作，但是通知仍然存在于抽屉式通知栏，此时如果想让通知在用户点击后自动消失的话，就需要在构建通知时添加<code>setAutoCancel(true)</code>，或者手动调用<code>NotificationManager</code>对象的<code>cancel()</code>，<code>cancel()</code>接收一个整型参数，这个整型参数是通知的 ID 。</p><h4 id="通知中增加按钮"><a href="#通知中增加按钮" class="headerlink" title="通知中增加按钮"></a>通知中增加按钮</h4><p>一个通知最多可以提供三个操作按钮供用户对通知进行快速响应，例如暂停闹钟提醒、回复短信，只不过这些按钮对应的操作不应该和用户在点按通知时执行的操作一样。想要添加操作按钮，就需要在构建通知时添加<code>addAction()</code>，<code>addAction()</code>接收 3 个参数，分别是代表这个操作的图标、这个操作的描述，以及一个 PendingIntent 。</p><h4 id="添加回复操作"><a href="#添加回复操作" class="headerlink" title="添加回复操作"></a>添加回复操作</h4><p>Android 7.0 API 24 引入的直接回复操作允许用户直接在通知中输入文本以响应通知，这种行为在收到短信时很常见，当收到一条短信时，可以直接点击「回复」按钮进行回复，而无需打开短信。并且当用户完成输入后，系统会将文本附加到为通知操作指定的 Intent 中，然后将 Intent 发送给应用。</p><p><a href="https://developer.android.com/training/notify-user/build-notification#reply-action">添加直接回复操作</a></p><h4 id="添加进度条"><a href="#添加进度条" class="headerlink" title="添加进度条"></a>添加进度条</h4><p>通知可以包含动画形式的进度指示器，向用户显示正在进行的操作的状态。</p><p><a href="https://developer.android.com/training/notify-user/build-notification#progressbar">添加进度条</a></p><h3 id="打开通知渠道设置"><a href="#打开通知渠道设置" class="headerlink" title="打开通知渠道设置"></a>打开通知渠道设置</h3><p>一个很好的例子是，在微信设置中，如果想要修改收到消息时通知的震动和响铃，微信会直接打开系统设置中的通知渠道设置，而不是在微信中进行修改，因为微信本身已经无法修改通知渠道的视觉和听觉行为，微信能做的就只有重定向至系统设置，然后让用户去修改。</p><p>想要实现这种重定向，仍然需要使用到 Intent ，通过构造一个<code>Intent</code>对象，并设置其动作为<code>Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS</code>，同时设置两个额外参数，分别是应用的包名和通知渠道的 ID ，最后调用<code>startActivity()</code>并将<code>Intent</code>对象传入即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent = Intent(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS).apply &#123;<br>    putExtra(Settings.EXTRA_APP_PACKAGE, packageName)<br>    putExtra(Settings.EXTRA_CHANNEL_ID, <span class="hljs-string">&quot;testChannel&quot;</span>)<br>&#125;<br><br>startActivity(intent)<br></code></pre></td></tr></table></figure><h3 id="即时通讯应用的通知"><a href="#即时通讯应用的通知" class="headerlink" title="即时通讯应用的通知"></a>即时通讯应用的通知</h3><p><a href="https://developer.android.com/training/notify-user/build-notification#messaging-best-practices">有关即时通讯应用的最佳做法</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.android.com/guide/components/broadcasts">Broadcasts overview | Android Developers</a></li><li><a href="https://developer.android.com/guide/topics/ui/notifiers/notifications">通知概览 | Android 开发者 | Android Developers</a></li><li>《第一行代码 Android 第3版》郭霖 著</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android 学习笔记 - Activity</title>
    <link href="/post/Android-Study-Guide-Activity/"/>
    <url>/post/Android-Study-Guide-Activity/</url>
    
    <content type="html"><![CDATA[<p>主要记录一下 Activity 的生命周期、启动模式，以及 Intent 。</p><span id="more"></span><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Activity 存储在栈这种先进后出的结构中，位于栈顶的 Activity 将会展示给用户，执行「返回」操作的时候栈顶的 Activity 也会先出栈。</p><p>Activity 在生命周期中会存在 4 种状态：</p><ul><li>运行：当打开一个 Activity 的时候，它就会位于栈顶，并且处于运行状态。</li><li>暂停：不是每一个 Activity 都会占满整个屏幕，例如对话框。而当我们将一个对话框形式的 Activity 入栈时，位于其之下的 Activity 也就是原来位于栈顶的 Activity 就会进入暂停状态。因为这个 Activity 被对话框挡住了，但又没完全不可见，尤其是对话框还导致这个 Activity 变得不可交互，所以就进入了暂停状态。</li><li>停止：当一个 Activity 不再处于栈顶位置时，且完全不可视时，将会进入此状态。处于该状态的 Activity 有可能会被系统回收。</li><li>销毁：当 Activity 出栈后就会变成这个状态。</li></ul><p>这 4 种状态伴随着 7 个回调方法：</p><ol><li><code>onCreate()</code>：在 Activity 在第一次创建的时候调用，在里面执行一些初始化操作。</li><li><code>onStart()</code>：在 Activity 由不可见变为可见时调用。</li><li><code>onResume()</code>：在 Activity 准备好和用户进行交互的时候调用。此时的 Activity 一定位于栈顶。</li><li><code>onPause()</code>：在系统准备去启动或者恢复另一个 Activity 的时候调用。通常会在这个方法中将一些消耗 CPU 的资源释放掉，以及保存一些关键数据。这个方法的执行速度一定要快，不然会影响到新的栈顶 Activity 的使用。</li><li><code>onStop()</code>：在 Activity 完全不可见的时候调用。和<code>onPause()</code>的主要区别在于，如果启动的新 Activity 是一个对话框形式的 Activity ，那么<code>onPause()</code>会得到执行。</li><li><code>onDestroy()</code>：在 Activity 被销毁之前调用。</li><li><code>onRestart()</code>：这个方法在 Activity 由停止状态变为运行状态之前调用。</li></ol><p>以上 7 个方法中除了<code>onRestart()</code>，其它都是两两对应的，可以这样简单理解：Activity 的创建和销毁对应 1 和 6 ，可见和完全不可见对应 2 和 5 并且 7 穿插在 5 到 2 之间，4 是部分可见，3 是从部分可见恢复到完全可见。</p><p><img src="/images/note/Activity_Life_Cycle.jpg" alt="Android 生命周期"></p><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>Intent 是 Android 程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据。Intent一般可用于启动 Activity 、启动 Service 以及发送广播等场景。</p><h3 id="显式-Intent"><a href="#显式-Intent" class="headerlink" title="显式 Intent"></a>显式 Intent</h3><p>最简单的用于启动 Activity 的方式，只需要提供两个参数，一是启动 Activity 的上下文，二是指定要启动的目标 Activity 。假设当前项目中有一个 Activity 的名称为「SecondActivity」。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span>, SecondActivity::<span class="hljs-keyword">class</span>.java)  <span class="hljs-comment">// 构建一个 Intent 对象</span><br>startActivity(intent)  <span class="hljs-comment">// 通过 Intent 对象启动 Activity</span><br></code></pre></td></tr></table></figure><p>Kotlin 中的<code>SecondActivity::class.java</code>相当于 Java 中的<code>SecondActivity.class</code>。</p><h3 id="隐式-Intent"><a href="#隐式-Intent" class="headerlink" title="隐式 Intent"></a>隐式 Intent</h3><p>隐式 Intent 并不明确指出想要启动哪一个 Activity ，而是预先在<code>AndroidManifest.xml</code>的<code>&lt;intent-filter&gt;</code>中设置<code>&lt;action&gt;</code>、<code>&lt;catagories&gt;</code>，来让同时满足这两个条件的 Activity 响应。</p><p>如果有多个应用可处理 Intent ，系统会为用户显示一个对话框，供其选择要使用的应用。</p><h4 id="启动自己程序的-Activity"><a href="#启动自己程序的-Activity" class="headerlink" title="启动自己程序的 Activity"></a>启动自己程序的 Activity</h4><p>假设在程序中有一个叫「SecondActivity」的 Activity ，那么此时需要在<code>AndroidManifest.xml</code>中对名为「.SecondActivity」的 Activity 标签进行设置，具体操作就是为其增加<code>&lt;intent-filter&gt;</code>标签，并且在其中按需指定 action 和 category ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.SecondActivity&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;Start Second Activity&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 指定 action --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 指定 category --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.app.lib_name&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:value</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接下来需要在调用处新建 Intent 对象并指定 action 和 category 信息，然后如果存在某个 Activity ，它在<code>AndroidManifest.xml</code>中注册了 Intent 对象中一摸一样的 action 和 category （比如上面提到的「SecondActivity」），那么该 Activity 将会响应<code>startActivity()</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-string">&quot;Start Second Activity&quot;</span>)  <span class="hljs-comment">// 指定 action</span><br>startActivity(intent)<br></code></pre></td></tr></table></figure><p>不同于显式 Intent 使用的构造函数，此处构建 Intent 对象传入的参数是一个 action 。并且此处没有明确指定 category ，是因为默认就会使用<code>android.intent.category.DEFAULT</code>这个 category 。除了默认的 category ，也可以通过<code>intent.addCategory()</code>手动为 Intent 对象添加多个 category ，但是 action 只能有一个。当<code>startActivity(intent)</code>执行后，将成功启动「SecondActivity」。</p><h4 id="启动其它程序的-Activity"><a href="#启动其它程序的-Activity" class="headerlink" title="启动其它程序的 Activity"></a>启动其它程序的 Activity</h4><p>根据需求在构建 Intent 对象时指定相应的 action ，就可以启动其它程序的 Activity。</p><ul><li>网络浏览器加载网址</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent = Intent(Intent.ACTION_VIEW, Uri.parse(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>))<br>startActivity(intent)<br></code></pre></td></tr></table></figure><ul><li>发起通话</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent = Intent(Intent.ACTION_DIAL, Uri.parse(<span class="hljs-string">&quot;tel:10086&quot;</span>))<br>startActivity(intent)<br></code></pre></td></tr></table></figure><h2 id="Activity-间传递数据"><a href="#Activity-间传递数据" class="headerlink" title="Activity 间传递数据"></a>Activity 间传递数据</h2><p>Intent 提供了一系列<code>putExtra()</code>方法的重载，可以把想要传递的数据暂存在 Intent 中，在启动另一个 Activity 后，再把这些数据从 Intent 中取出就可以了。</p><h3 id="向下一个-Activity-传递"><a href="#向下一个-Activity-传递" class="headerlink" title="向下一个 Activity 传递"></a>向下一个 Activity 传递</h3><p>存储消息并启动 Activity ，其中<code>putExtra()</code>需要两个参数，可以视为键值对，第一个是键，第二个才是值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/* MainActivity */</span><br><br><span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = <span class="hljs-string">&quot;Greetings to SecondActivity!&quot;</span><br><span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span>, SecondActivity::<span class="hljs-keyword">class</span>.java).apply &#123;<br>    putExtra(<span class="hljs-string">&quot;dataFromMainActivity&quot;</span>, <span class="hljs-keyword">data</span>)<br>&#125;<br>startActivity(intent)<br></code></pre></td></tr></table></figure><p>接下来取出消息并打印，取消息时需要根据数据类型来使用不同的 getXxxExtra 方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/* SecondActivity */</span><br><br><span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = intent.getStringExtra(<span class="hljs-string">&quot;dataFromMainActivity&quot;</span>)<br>Log.d(<span class="hljs-string">&quot;SecondActivity&quot;</span>, <span class="hljs-string">&quot;传递过来的消息是：<span class="hljs-variable">$data</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>在「SecondActivity」中并没有定义名为<code>intent</code>的 Intent 对象，<code>intent.getStringExtra(&quot;dataFromMainActivity&quot;)</code>中的<code>intent</code>实际上是调用了父类的<code>getIntent()</code>，该方法会获取用于启动「SecondActivity」的 Intent ，然后再通过 getXxxExtra 方法并传入键（dataFromMainActivity），就可以取出相应的值。</p><p>除了上方代码中的<code>getStringExtra()</code>以及其它用于接收基本数据类型的方法之外，还有<code>getSerializableExtra()</code>、<code>getParcelableExtra()</code>、<code>getBundleExtra()</code>、<code>getCharSequenceExtra()</code>这四个方法用于接收相对应的对象。</p><h3 id="返回给上一个-Activity"><a href="#返回给上一个-Activity" class="headerlink" title="返回给上一个 Activity"></a>返回给上一个 Activity</h3><p>在<code>androidx.appcompat:appcompat:1.3.0</code>以及更高的版本当中，<code>startActivityForResult()</code>已被废弃，同时被废弃的还有<code>requestPermissions()</code>。取而代之的是 Activity Result API ，通过这个 API 来实现两个 Activity 间的数据交换以及请求运行时权限。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/* MainActivity */</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> requestDataLauncher =<br>    <span class="hljs-comment">// 调用 registerForActivityResult() 来注册一个对 Activity 结果的监听</span><br>    registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123;<br>        <span class="hljs-comment">// 若有结果发返回则会回调此处的 Lambda 表达式对结果进行处理</span><br>        <span class="hljs-keyword">if</span> (it.resultCode == RESULT_OK) &#123;<br>            <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = it.<span class="hljs-keyword">data</span>?.getStringExtra(<span class="hljs-string">&quot;dataFromSecondActivity&quot;</span>)<br>            Log.d(<span class="hljs-string">&quot;dataFromSecondActivity&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-variable">$data</span>&quot;</span>)<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>    <span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span>, SecondActivity::<span class="hljs-keyword">class</span>.java)<br>    setContent &#123;<br>        <span class="hljs-comment">// 使用 ActivityResultLauncher 对象的 launch() 来启动 Intent</span><br>        Button(onClick = &#123; requestDataLauncher.launch(intent) &#125;) &#123;<br>            Text(text = <span class="hljs-string">&quot;启动 SecondActivity&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/* SecondActivity */</span><br><br>Button(onClick = &#123;<br>    <span class="hljs-keyword">val</span> intent = Intent()<br>    intent.putExtra(<span class="hljs-string">&quot;dataFromSecondActivity&quot;</span>, <span class="hljs-string">&quot;Greetings to MainActivity!&quot;</span>)<br>    setResult(RESULT_OK, intent)<br>    finish()  <span class="hljs-comment">// 销毁当前 Activity</span><br>&#125;) &#123;<br>    Text(text = <span class="hljs-string">&quot;结束 SecondActivity 并返回数据&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 MainActivity 中已经完全移除了对<code>onActivityResult()</code>的重写，而是调用<code>registerForActivityResult()</code>方法来注册一个对 Activity 结果的监听。<code>registerForActivityResult()</code>方法接收两个参数，第一个参数是一种 Contract 类型，由于是从另外一个 Activity 中请求数据，因此这里使用了 StartActivityForResult 这种 Contract 。第二个参数是一个 Lambda 表达式，当有结果返回时则会回调到这里，然后在这里获取并处理数据即可。</p><p><code>registerForActivityResult()</code>方法的返回值是一个<code>ActivityResultLauncher</code>对象，这个对象当中有一个<code>launch()</code>可以用于去启用 Intent。这样就不需要再调用<code>startActivityForResult()</code>了，而是直接调用<code>launch()</code>并把 Intent 传入即可。</p><h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><p>某个 Activity 的启动模式是在清单文件中其对应的<code>&lt;activity&gt;</code>标签内进行设置的，例如此处将 MainActivity 的启动模式设置为<code>singleTask</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:launchMode</span>=<span class="hljs-string">&quot;singleTask&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 将启动模式设置为 singleTask --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br></code></pre></td></tr></table></figure><p>启动模式可分为两大类，<code>standard</code>和<code>singleTop</code>是一类，<code>singleTask</code>、<code>singleInstance</code>和<code>singleInstancePerTask</code>是另一类。如此分类的依据是前者可以对 Activity 进行多次实例化。</p><h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p><code>standard</code>是 Activity 默认的启动模式，对于使用该模式的 Activity ，系统每次都会在当前任务栈顶创建一个新实例而不会理会栈中是否已经存在实例。每个实例可以属于不同的任务，而一个任务可以有多个实例。</p><h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>在该模式下，如果 Activity 已经处于当前任务栈栈顶，那么系统将不会创建新的实例，而是复用已有的实例，并调用其<code>onNewIntent()</code>。</p><p><code>onNewIntent()</code>可以在 Activity 中被重写，其在<code>onPause()</code>之后，<code>onResume()</code>之前被调用，并且接收一个<code>Intent</code>类型的参数，这个 Intent 就是在调用<code>startActivity()</code>时传递的 Intent 。</p><h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>如果要启动的 Activity 已经存在于某个任务栈中，那么系统会把该任务栈调到前台，并将其之上的所有 Activity 通通出栈，然后再调用其<code>onNewIntent()</code>。如果要启动的 Activity 不存在于任何任务栈中，那么系统会创建一个新的任务栈并在其根位置创建实例。</p><p>接下来是一个简单的测试用例，假设有两个 Activity 分别为 MainActivity 和 SecondActivity ，且 MainActivity 的<code>launchMode</code>设置为<code>singleTask</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">ComponentActivity</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContent &#123;<br>            Button(onClick = &#123;startActivity(Intent(<span class="hljs-keyword">this</span>, SecondActivity::<span class="hljs-keyword">class</span>.java))&#125;) &#123;<br>                Text(text = <span class="hljs-string">&quot;启动 SecondActivity&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onPause()<br>        Log.i(<span class="hljs-string">&quot;@@@&quot;</span>, <span class="hljs-string">&quot;MainActivity onPause() 被调用&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onResume()<br>        Log.i(<span class="hljs-string">&quot;@@@&quot;</span>, <span class="hljs-string">&quot;MainActivity onResume() 被调用&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNewIntent</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onNewIntent(intent)<br>        Log.i(<span class="hljs-string">&quot;@@@&quot;</span>, <span class="hljs-string">&quot;MainActivity onNewIntent() 被调用&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SecondActivity</span> : <span class="hljs-type">ComponentActivity</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContent &#123;<br>            Button(onClick = &#123; startActivity(Intent(<span class="hljs-keyword">this</span>, MainActivity::<span class="hljs-keyword">class</span>.java)) &#125;) &#123;<br>                Text(text = <span class="hljs-string">&quot;启动 MainActivity&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDestroy()<br>        Log.i(<span class="hljs-string">&quot;@@@&quot;</span>, <span class="hljs-string">&quot;SecondActivity onDestroy() 被调用&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序运行，在 MainActivity 中点击按钮启动 SecondActivity 会得到如下打印：</p><blockquote><p>MainActivity onPause() 被调用</p></blockquote><p>随后在 SecondActivity 中点击按钮启动 MainActivity 会得到如下打印：</p><blockquote><p>MainActivity onNewIntent() 被调用<br>MainActivity onResume() 被调用<br>SecondActivity onDestroy() 被调用</p></blockquote><h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>在该模式下，只允许一个 Activity 的实例存在，并且该实例会运行在一个单独的任务栈中。如果要启动的 Activity 已经存在于该任务栈中，那么系统会直接调用其 onNewIntent() 方法。</p><p>接下来是一个简单的测试用例，假设程序中有三个 Activity ：</p><ul><li>MainActivity 用来启动 SecondActivity 。</li><li>SecondActivity 的启动模式设置为<code>singleInstance</code>且用来启动 ThirdActivity 。</li><li>三个 Activity 的<code>onCreate()</code>中都会打印<code>taskId</code>。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">ComponentActivity</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        <span class="hljs-keyword">val</span> context = <span class="hljs-keyword">this</span><br>        Log.i(<span class="hljs-string">&quot;@@@&quot;</span>, <span class="hljs-string">&quot;MainActivity 启动，任务 ID 为：<span class="hljs-variable">$taskId</span>&quot;</span>)<br>        setContent &#123;<br>            Column(modifier = Modifier.fillMaxSize()) &#123;<br>                Text(text = <span class="hljs-string">&quot;目前位于 MainActivity&quot;</span>)<br>                Button(onClick = &#123; startActivity(Intent(context, SecondActivity::<span class="hljs-keyword">class</span>.java)) &#125;) &#123;<br>                    Text(text = <span class="hljs-string">&quot;启动 SecondActivity&quot;</span>)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SecondActivity</span> : <span class="hljs-type">ComponentActivity</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        <span class="hljs-keyword">val</span> context = <span class="hljs-keyword">this</span><br>        Log.i(<span class="hljs-string">&quot;@@@&quot;</span>, <span class="hljs-string">&quot;SecondActivity 启动，任务 ID 为：<span class="hljs-variable">$taskId</span>&quot;</span>)<br>        setContent &#123;<br>            Column(modifier = Modifier.fillMaxSize()) &#123;<br>                Text(text = <span class="hljs-string">&quot;目前位于 SecondActivity&quot;</span>)<br>                Button(onClick = &#123; startActivity(Intent(context, ThirdActivity::<span class="hljs-keyword">class</span>.java)) &#125;) &#123;<br>                    Text(text = <span class="hljs-string">&quot;启动 ThirdActivity&quot;</span>)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNewIntent</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onNewIntent(intent)<br>        Log.i(<span class="hljs-string">&quot;@@@&quot;</span>, <span class="hljs-string">&quot;SecondActivity onNewIntent() 被调用&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThirdActivity</span> : <span class="hljs-type">ComponentActivity</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        <span class="hljs-keyword">val</span> context = <span class="hljs-keyword">this</span><br>        Log.i(<span class="hljs-string">&quot;@@@&quot;</span>, <span class="hljs-string">&quot;ThirdActivity 启动，任务 ID 为：<span class="hljs-variable">$taskId</span>&quot;</span>)<br>        setContent &#123;<br>            Column(modifier = Modifier.fillMaxSize()) &#123;<br>                Text(text = <span class="hljs-string">&quot;目前位于 ThirdActivity&quot;</span>)<br>                Button(onClick = &#123; startActivity(Intent(context, SecondActivity::<span class="hljs-keyword">class</span>.java)) &#125;) &#123;<br>                    Text(text = <span class="hljs-string">&quot;启动 ThirdActivity&quot;</span>)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序运行，会得到第一个打印：</p><blockquote><p>MainActivity 启动，任务 ID 为：55</p></blockquote><p>接着点击按钮启动 SecondActivity 会得到第二个打印：</p><blockquote><p>SecondActivity 启动，任务 ID 为：56</p></blockquote><p>接着点击按钮启动 ThirdActivity 会得到第三个打印：</p><blockquote><p>ThirdActivity 启动，任务 ID 为：55</p></blockquote><p>可以看到，MainActivity 和 ThirdActivity 的<code>taskId</code>是一致的，说明它们位于同一个栈内，而 SecondActivity 由于将启动模式设置成了<code>singleInstance</code>，使其单独被放置在一个栈中进行管理。这时候在设备上进行「返回」操作，会发现 ThirdActivity 会直接返回到 MainActivity ，然后再返回到 SecondActivity ，最后才退出程序。</p><p>而当在 ThirdActivity 中点击按钮启动 SecondActivity 时，由于其已经实例化过了，所以会直接被复用并且调用其<code>onNewIntent()</code>。</p><h3 id="singleInstancePerTask"><a href="#singleInstancePerTask" class="headerlink" title="singleInstancePerTask"></a>singleInstancePerTask</h3><p>真的是永远有学不完的新东西……<code>singleInstancePerTask</code>是 Android 12 新增的第五种启动模式，它的作用是让 Activity 只能作为任务栈的根 Activity 存在，并且每个任务栈内只能有一个实例。但是在不同的任务栈中可以有不同的实例，如果想要这么做，就需要在 Intent 内设置<code>Intent.FLAG_ACTIVITY_MULTIPLE_TASK</code>或<code>Intent.FLAG_ACTIVITY_NEW_DOCUMENT</code>标志。而<code>singleTask</code>是在整个应用内只有一个实例，但是它可以是也可以不是一个任务栈的根，这将由任务的亲和性决定，也就是清单文件中的<code>&lt;activity&gt;</code>标签内<code>taskAffinity</code>属性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://mp.weixin.qq.com/s/C62WVau-AU0MH7S4Ix85ew">Activity Result API详解，是时候放弃startActivityForResult了</a></li><li><a href="https://developer.android.com/guide/components/intents-common">通用 Intent | Android 开发者 | Android Developers</a></li><li>《第一行代码 Android 第3版》郭霖 著</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>假面骑士 01 - Review</title>
    <link href="/post/Review-Kamen-Rider-Zero-One/"/>
    <url>/post/Review-Kamen-Rider-Zero-One/</url>
    
    <content type="html"><![CDATA[<p>被大家喷成屎的令和第一部假面骑士真的有这么烂吗？</p><span id="more"></span><p><img src="/../../images/ACGN/Kamen-Rider-Zero-One-review.jpg" alt="大结局中的一幕"></p><h2 id="演员"><a href="#演员" class="headerlink" title="演员"></a>演员</h2><p>无论是选角还是演员的演技，该剧的水平都不算差。就比如身为搞笑艺人讲的笑话却无法令人发笑、一身正气的、相信人类和仿生人终会和睦相处的年轻社长，以及始终相信着、辅佐着社长的超高颜值超可爱的社长秘书……这些都是让人印象深刻的角色。</p><h2 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h2><p>整部剧从第一集就表明了，当或人拿起 01 驱动器时，就说出了“梦想不是检索一下就能明白的随随便便的东西”。自那时起我就知道，除了人工智能，01 还融入了梦想这一元素。然而这个词由于在剧中被过多地被提到以至于观众们把它当成梗来玩，尽管这无伤大雅。</p><p>01 的前几集都是在讲仿生人如何与人类相处，或人一行人又是怎样改变人们对仿生人的看法，其过程中充满了曲折，在多处都展现了仿生人买家与卖家或人浓厚的感情表达。</p><h3 id="仿生人-VS-ZAIA终端"><a href="#仿生人-VS-ZAIA终端" class="headerlink" title="仿生人 VS ZAIA终端"></a>仿生人 VS ZAIA终端</h3><p>有些人说 Hiden 和 ZAIA 展开的仿生人和 ZAIA 终端的比试那几集很拉跨，其实我觉得不然，恰恰是那几集，真的非常精彩。</p><p>第一场比试是关于插花的，飞电输了，我觉得这在情理之中。因为就算仿生人能够在短时间内通过学习来获得大量知识，但终究无法获得一些实战经验，尤其是对于艺术品，在仿生人没能完全“成为”人类之前，只有人类能够通过艺术品来表达丰富的感情。再加上评委也是人类，这就让对方——搭载 ZAIA 终端的插花大师有了很大的优势。</p><p>第二场比试是关于卖房子的，飞电又输了，但是尽管输了比赛，我觉得飞电赢了人心。在比试的最后，是仿生人了解到了富豪内心真正的需求，从而给他推荐了一套山间的小房子，用于让他与家人聚在一起。但就是因为这个小房子的价格太低，导致飞电最终的销售额不及 ZAIA ，从而输了比试。</p><p>第三场是关于法庭上的比试，这一场比试很有意思，一是因为如果这一场飞电输了，那五局三胜的比赛就不用再进行下去了，因为 ZAIA 已经三胜了。所以综合各种情况，从剧情上来说，这一场比试应该是飞电要赢。二是设定上，飞电负责为被告人辩护，而 ZAIA 则需要为被告人定下罪名。但是这一场比试从一开始，在表现手法上，官方就告诉了观众，这个被告人是无罪的。这就很有意思，首先要知道，假面骑士的受众群体中是有小孩子的，如果这场比试飞电输了，那这个被告人必定是被冤枉的，这就是一场冤案。这大概率就会在小朋友们的心中产生阴影，让他们觉得这个世界很灰暗，为什么明明是好人却会被当作坏人，正义不仅迟到了，而且压根就没来。所以综合以上两个原因，飞电胜得毫无悬念。</p><p>第四场是关于消防救援能力的比试，这场比试也很有意思，首先仿生人的本质是机器人，机器人不像人类一样需要呼吸，那么在极端环境下例如火灾现场等，理论上应该比人类要更有优势，所以这场比试理论上来说应该是飞电赢。当然最终结果确实是飞电赢了，只不过不是靠机器人的优势赢的，而是到了最后，仿生人通过向对手学习，知道了“人命关天，当消防员救人，不应该单纯地相信数据分析，不应该放弃一丝救援的机会”，利用自己的优势，贡献了自己，帮助对手把火场的最后一批人救了出来……是的，贡献了自己，帮助了对手……这场比试的评判标准就是哪一方救的人多哪一方就获胜，然而仿生人却贡献了自己，自己都没了还怎么救人了呢。所以以结果来说，最后应该是 ZAIA 获胜，但是因为 ZAIA 方的参赛选手被仿生人的行为所感动，将自己的胜利位置让给了仿生人了，所以获胜方又变成了飞电。</p><p>第五场则是政治方面的比试，通过政治宣讲来号召人们进行投票支持，以票数来决定胜负。这一场比试说实话没啥意思，感觉就是单纯地为了让飞电输而让飞电输，故而不想多做评价。</p><h3 id="拉跨迫于无奈"><a href="#拉跨迫于无奈" class="headerlink" title="拉跨迫于无奈"></a>拉跨迫于无奈</h3><p>飞电和ZAIA的比试不算拉跨，真正拉跨的只能说是伊兹这个角色连续两次送的人头。但是这两次送人头又是极大地推动了剧情的发展，所以我只好理解为这是剧组的无奈之举。</p><h2 id="皮套特效和音效"><a href="#皮套特效和音效" class="headerlink" title="皮套特效和音效"></a>皮套特效和音效</h2><p>01 的皮套做得真心炫酷，简约而不简单，此外音效方面也没有时王这么吵，同时加入了非常标准的美式英语作为每个形态描述的配音。当然，说了那么多，不如把钱掏出来来得实在：<img src="/../../images/ACGN/ThousanDriver.jpg" alt="Thousan Driver"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作为令和第一假面骑士，01 的表现并没有让我很失望，如果满分十分，我给这部剧七分。至于它的接档假面骑士 Saber ，单纯从皮套设计来说，我真的不是很喜欢。</p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>正当吐槽</title>
    <link href="/post/Review-Just-Cause-2/"/>
    <url>/post/Review-Just-Cause-2/</url>
    
    <content type="html"><![CDATA[<p>历时 20 个小时，终于把《正当防卫 2》的主线推完了。尽管它只花了我 4 块钱，但是我仍然有话要说。</p><span id="more"></span><h2 id="玩法"><a href="#玩法" class="headerlink" title="玩法"></a>玩法</h2><p>这是一个沙盘类型的游戏，其玩法很简单，如果想要开启新任务推动剧情发展，就一直“炸炸炸”就好了。但就是因为简单，这些重复的工作可能会让玩家觉得无聊，而我个人觉得还好，至少炸炸炸看着分数增长能让我有满足感。</p><h2 id="画质"><a href="#画质" class="headerlink" title="画质"></a>画质</h2><p>2020 年玩这款游戏，不应该去奢求画面，而应该去欣赏、品味它，因为这就是那个年代的味道。</p><h2 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h2><p>游戏的流程不算长，游戏的最后由 Rico 终结了独裁者的统治来收尾，Panau 小岛也迎来了一位亲美的总统，这样的结局不由得让人联想到现实……<img src="/../../images/ACGN/JustCause2Ending.jpg" alt="大结局中的一幕"></p><h2 id="不满意的地方"><a href="#不满意的地方" class="headerlink" title="不满意的地方"></a>不满意的地方</h2><ul><li>这游戏跟 GTA 一样也有通缉状态，想要逃离通缉也很简单，只需要脱离敌人的视线就行了，比如快速位移到另一个地方。但问题在于，被通缉也很简单，或者说很莫名其妙……有时候一进入敌人视野就会被通缉。试想一下，你在玩 GTA ，你刚上街遇到个警察，你明明什么都没做你就被通缉了——恶心至极的体验；顺带吐槽一下敌人的强度，一旦通缉等级高到一定程度，武装直升机就来了，这种情况下如果想用手头上的枪械解决直升机就需要找到一个很好的掩体才可以。为什么？因为 Rico 正面根本顶不住直升机上搭载的加特林！我的建议是站在原地被扫死然后重新开。此外，我在游玩的过程中安装了爪钩的 MOD ，其功能为突破原来爪钩的限制，可以一次位移至一公里以外甚至更远的位置。我利用了这个 MOD 来脱离敌人的视线，以此来达到逃避通缉的目的。然而当我到达新的地点的时候，直升机却是一下子就追了上来，我一度怀疑这是 BUG ……</li><li>爪钩的体验大部分时候很差。游戏过程中，除了上街抢载具、叫空投（最好别想了，没那么多钱）、搭“顺风车”这三种方式以外，想要快速移动就只能靠爪钩，但是爪钩钩中目标的判定有时候很迷，因为它有时候能钩到很远的目标，有时候明明很近的地方它又不让钩。</li><li>从高中落下俯冲的体验真的像坨屎，下落的时候感觉就像是我趴在床上滚一样，根本没法好好控制。</li><li>偶尔闪退。</li><li>没有中文。</li><li>重复的工作太多，建议打 MOD 节省时间和精力，安装一些合理的 MOD 可以在提升游玩的快感的同时不会因为过于逆天而破坏了游戏体验。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果不是盗版补票的话其实可以不用买了，尽管只卖 4 块钱。虽然我没玩过 3 代和 4 代，但个人感觉从这两者入坑或许好一点，不过如果想体验 2 代的剧情的话，那又只能买了。</p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记一次刷机历程</title>
    <link href="/post/Flashed-a-3rd-party-ROM-for-my-OnePlus-6/"/>
    <url>/post/Flashed-a-3rd-party-ROM-for-my-OnePlus-6/</url>
    
    <content type="html"><![CDATA[<p>2020 年 2 月 27 日，我成功地将 Lineage OS 16 刷入我的 OnePlus 6 中。</p><span id="more"></span><h2 id="万事开头难"><a href="#万事开头难" class="headerlink" title="万事开头难"></a>万事开头难</h2><p>25 号的晚上至 26 号的凌晨，我尝试通过参照 Lineage OS 官网的 WiKi 来将 ROM 刷入我的一加 6 中，结果是失败了，有点出乎意料。虽然我早就做好了心理准备，但是没想到我连 TWRP 都进不去……</p><p>一加 6 据说是采用了一加前所未有的 A&#x2F;B 分区结构，这使得相对其他非 A&#x2F;B 分区结构的手机，一加 6 刷机的难度更大，操作更加复杂。</p><p>我一开始是参照 WiKi 刷入 TWRP 的，逐一键入：<code>fastboot set_active a</code>和<code>fastboot flash boot_a &lt;recovery_filename&gt;.img</code>，然后重启至 recovery 的时候就卡住了，懵了，心里想着要出问题怎么也得等到刷入 ROM 重启至系统的时候再出吧，结果刚起跑没多远就摔了。随后也都有尝试单独<code>fastboot set_active b</code>和<code>fastboot flash boot_b &lt;recovery_filename&gt;.img</code>以及 a 和 b 一起刷的，没用，这期间也持续在百度和 Google ，全都无果。最后狼狈地跑到 reddit 发贴求助，一直到凌晨 3 点钟才上床睡觉，闭上眼睛的同时感到非常无助和绝望。</p><h2 id="中间难"><a href="#中间难" class="headerlink" title="中间难"></a>中间难</h2><p>早上起来继续寻找解决问题的方法，期间发现 reddit 发的贴子有人回复了，其大致意思就是：就算是一加 6 最新的 TWRP ，亦都有可能无法运行在 Android 10 上，看到这一点后着实感到了一丝希望，因为尽管昨天晚上折腾了很久，但很有可能就是在瞎折腾。这位网友还向我推荐了 xda 的一个大佬，说是他有合适的 TWRP 。看完他的回复我也有了大致的前进方向。</p><p>晚上去到 xda 后利用我<del>的聪明才智和</del>这么多年来对电脑操作的经验我很快找到了这个作者以及他发布 TWRP 的贴子，事不宜迟立刻下载尝试。经过一天的阅览和学习，我意识到了其实还可以直接使用<code>fastboot flash boot &lt;recovery_filename&gt;.img</code>和<code>fastboot boot &lt;recovery_filename&gt;.img</code>这两条命令而不再加上 a 或 b 分区，不过这貌似也不是什么重点……</p><p>敲入命令 -&gt; 重启至 recovery ，这一切表面上看起来和昨晚没什么区别，然而这一次，一切正常运作了起来。手机重启 -&gt; 带有黄色感叹号的界面出现，到了这里，一时间感到很紧张，因为昨晚就是卡在这里的。不过当我在害怕它仍然会卡住而焦急等待之时，TWRP 的 logo 出现了！我成功地进入了 TWRP。</p><p>一阵狂喜，但我深知工作还没完成。进入 TWRP 之后就继续按照 WiKi 说的去做，对数据进行格式化：Format Data 和擦除 System 分区的数据，然后就到最关键的一步——利用<code>Sideload</code>来安装系统包，结果又出问题了。当我键入<code>adb sideload filename.zip</code>并按下回车以后，电脑上的命令提示符显示了一个百分比，然而当它跑到 47% 左右的时候，<code>Sideload</code>就自动关闭了，随后命令提示符就会显示：</p><blockquote><p>Total Xfer 1.00x</p></blockquote><p>这种情况无论我试了多少遍都还是一样，随后就又到处找解决方法，最后还是靠 WiKi 已有的页面得出一个可行方案，即可以通过<code>adb push filename.zip /sdcard/</code>这条命令将<code>.zip</code>包先丢到 SD 卡里然后再进入 TWRP 的安装界面进行安装。这个方法其实是在教你安装 GApps 的时候提到的，虽然我不知道它跟<code>Sideload</code>有什么区别，但能解决问题就行。</p><p>这次是真的成功刷入了，TWRP 自己显示成功，不是我说的。成功了以后当然是要重启手机了：Android Logo -&gt; 带有黄色感叹号的界面出现——然后呢手机就黑了（我？？），黑了以后又自动开机到 Fastboot Mode ，当然，这当然是一个循环，无论开关机多少次都是这样。没办法了，去 reddit 报喜的同时还得报忧……</p><h2 id="结尾难"><a href="#结尾难" class="headerlink" title="结尾难"></a>结尾难</h2><p>凌晨两点才睡，早上九点才醒，醒了第一件事就是跑去 reddit 看看贴子怎么样了，然而这一次却没人回复我了。心里想着看来还得靠自己去找答案了。午饭过后通过 Google 找到一篇文章，主要内容就是教你怎么给 OnePlus 6 安装 Lineage OS 16 ，写得非常详细，不仅有图，步骤也分得非常清楚，每一步该干什么，为什么这么做，都写得很明白。看来天无绝人之路，好戏才刚刚开始。</p><p>用渣渣英语大致看过一遍以后就动手开始照做了。其实在此之前，关于为什么手机开机不进系统而只会进到 Fastboot Mode 我已经大概有个头绪了，很有可能就是因为该打的驱动或者说是该有的固件没刷上，同时这篇文章也提到，Lineage OS 虽然自称是个「OS」，然而它却不具备一个完整的操作系统该有的，所以我现在要做的第一件事就是跑去一加的论坛，下载他们当时发布的 Android P 的最后稳定版本，用它来作底包，然后再刷入 Lineage OS 。好家伙, 氢OS 9.0.7 全量包的大小有将近两个G，然后再回过头来看看<code>lineage-16.0-20200223-nightly-enchilada-signed.zip</code>的大小只有 486 MB。</p><p>在阅读教程的过程中我还了解到，原来在刷包的时候，受影响的槽并不是当前所在的槽。也就是说，如果现在处在 A 槽，那么这个包将被刷入到 B 槽中，这和大多数操作的效果是相反的，例如，擦除 System 分区的数据，擦的就是当前槽的 System 分区，而另外一个槽是不受影响的。我根本不知道还有这种设定！</p><p>在刷入底包以后，我需要做的就是切换到另一个槽，即底包所在的槽，对其执行擦除<code>System</code>分区的操作。这样就说得通了，我刷入底包，把驱动固件什么的刷进去，然后单独把系统抹掉，这样我就可以刷入新的系统而不用担心驱动问题了。当然，直接滑动条块恢复出厂设置也是必要的。这两者操作完以后，就可以切换回原来的槽上主菜了。当然，这些操作执行完一次以后，还需要切换到另一个槽重复一遍。</p><p>刷入 Lineage OS 以后，当然要同时刷入 TWRP ，因为这是一个强大的 recovery ，并且此时刷入，将使其在手机的两槽上永久可用，同时在重启时，TWRP 还会隐式地为我们交换槽。重启至 recovery(TWRP) 了以后就可以刷入 GApps 和对手机进行 Root 了。</p><p>在进行完所有的工作以后就可以重启至系统了，最终，功夫不负有心人，我成功看到了 Lineage OS 的开机动画，直接原地起飞好吧。</p><h2 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h2><p>终于写到这里了。这次刷机，可以说是搞机生涯中的一个里程碑，因为我遇到并尝试去解决了很多问题。其实我完全可以不去折腾，氢OS 也用得好好的，我完全没必要吃饱没事干去把手机搞坏，而且就算我把手机整得不能正常开机了，我也完全可以把它返修，虽然过了保修期，不过我想他们帮我刷个系统最多也就几百块的事情，顺丰快递，今天去明天回。但是我并没有这么做，系统进不去了，但是 Fastboot Mode 还能进，我知道我还没有彻底失败。</p><p>其实我前段时间也有刷过一台 三星 Note 3 ，那是一台 2013 年的机器，而一加 6 是 2018 年的。这两者的区别就在于一加 6 是 A&#x2F;B 分区的机器，而 A&#x2F;B 分区说不定将会是未来安卓手机都会采用的技术，因为它从用户体验的角度来说真的很不错。我在一开始买回一加 6 更新系统的时候我就注意到了，它下载完更新包是直接安装的，安装完了以后再重启手机。而我以前的手机，就例如红米 1S ，当时更新系统的时候下载完更新包就得关机更新了。从用户体验的角度来看，当 A&#x2F;B 分区的手机更新系统时，你仍然可以去干别的事，直到它安装完了提示需要重启的时候再进行重启即可。所以现如今我学会了如何给 A&#x2F;B 分区的机器刷机，无论将来是否有机会派上用场，但是如果我不刷，或者是刷坏了就直接返修，那这就是另一个故事了。</p><p>我觉得无论是在什么行业做什么，都应该要带有一点折腾的精神。折腾，它一定会需要投入大量的时间和精力，并且不一定有所回报。但是如果没有折腾，或许就不会有进步。尽管折腾会消耗大量的时间，但这个消耗应该是值得的，甚至是超值的，而如果做一件事情毫不费力，那一定就是在浪费时间。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>假面骑士时王 - Review</title>
    <link href="/post/Review-Kamen-Rider-Zio/"/>
    <url>/post/Review-Kamen-Rider-Zio/</url>
    
    <content type="html"><![CDATA[<p>01 更新到 11 集的时候，我把时王补完了。</p><span id="more"></span><p><img src="/../../images/ACGN/Heiseikamenrider20.jpg" alt="平成系列第 20 部纪念作"></p><p>作为平成的最后一部假面骑士，我觉得还行，真的只是还行。本来我觉得作为一部有时代意义的作品（因为是平成结束的代表），你总得给人以震撼，但是没有，只不过也没有让人很失望就是了。</p><p>首先，以时间为主题讲述故事，我觉得挺难的，到底什么是过去，什么是未来？会陷入一种死循环，就好像超兽武装，我记得当初我看超兽武装的时候，狮王来到了现代，把异能锁还给了火麟飞，然后火麟飞在结局的时候又在古代把异能锁借给狮王，那到底是你先还给我我才借给你还是我先借给你你才还给我？时王同时还引入了平行世界的概念，也就是说，虽然我们都在地球上，我们都在日本，但是有我没有你，有你没有我。在 Decade 中，士他们要通过穿越来到下一位骑士的世界，但是在时王里又没有“穿越”这一说法，骑士们都是直接出现的，但是在时王结局，又谈到要毁灭世界就要把所有世界融合……做设定太难了。此外还有一个人人诟病的设定，那就是时王二阶，请问你已经有预知未来和时间倒流的能力了，你还有什么事做不了？</p><p>此外，变身音效太吵了、太杂了、太长了、花里胡哨的…这我也不喜欢。</p><p>除了以上的，其他的我觉得都做得很好：</p><ul><li>演员选得好，颜值够高，我还挺喜欢盖兹和月读那种稍微有点沙哑的声音。演技也够好，感情表达真的很到位！</li><li>前辈骑士的人间体也有大量回归，情怀加分。</li><li>幽默恶搞的戏份也是一如既往，令人开怀大笑。</li></ul><p>以上就是目前对时王整部剧的看法吧，有些东西还能继续说，但是懒得写了。01 见。</p><hr><p>这一次除了看剧，我还买了人生中的第一条腰带，也算是纪念平成的结束了<del>（上了东映的当 ）</del> 。XD<img src="/../../images/ACGN/ZikuDriver.jpg" alt="时空驱动器"></p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《地铁：最后的曙光》通关感想</title>
    <link href="/post/Review-Metro-Last-Light/"/>
    <url>/post/Review-Metro-Last-Light/</url>
    
    <content type="html"><![CDATA[<p>前天晚上刚把《Metro: Last Light Redux》的主线推完。</p><span id="more"></span><p>作为《Metro 2033》的续作，不仅延续了前作的很多操作特色，还在其它方面做了优化、增加了细节。例如可以按<code>G</code>擦干净防毒面具上的雨水和血迹；除此之外，在战斗方面，击杀敌人的手感也得到了改善，不会出现说一个弹夹打完了都杀不死一个人的情况……除了新的武器之外还增加了武器定制的功能，我记得前作是没有的；最最重要的是，这一作增加了很多福利镜头，再加上游戏建模本身还算不错——这真的让人很社保。</p><p>游戏过程中该恐怖的地方还是有点恐怖的。不过相对前作来说感觉是差了一点，也有可能是玩多了变得不那么怕了吧……</p><p>剧情方面，本作的结尾不像前作那样那么魔幻，而是以阿尔乔姆的死来收尾……这就让我很期待续作的剧情。另外在游戏中小黑怪多次提到阿尔乔姆害死了他的家人和同类，最后在结局中它和剩余的黑怪离开了<img src="/../../images/ACGN/MetroLL1.jpg" alt="大结局中的一幕">，不知道这是不是为了给续作埋伏笔之类的。</p><p>总体来说算是我蛮喜欢的游戏了，以后有机会再把 2033 的 Redux 版玩一遍吧，之前玩的是 2010 年发行的 2033。到时候想试试另一个结局。<img src="/../../images/ACGN/MetroLL2.jpg" alt="大结局中的一幕"></p><p>最后附上乔伊做的一期对本游戏的剧情解说视频，做得挺好。<a href="https://www.bilibili.com/video/BV1R5411M7wT">核爆后的《地铁》究竟讲了什么样的故事？〖游戏不止〗</a></p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
